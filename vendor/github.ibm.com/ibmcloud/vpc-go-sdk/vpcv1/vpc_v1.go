/**
 * (C) Copyright IBM Corp. 2020.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcv1 : Operations and models for the VpcV1 service
package vpcv1

import (
	"fmt"
	"github.com/IBM/go-sdk-core/v3/core"
	"github.com/go-openapi/strfmt"
	common "github.ibm.com/ibmcloud/vpc-go-sdk/common"
)

// VpcV1 : No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
//
// Version: 2020-03-24
type VpcV1 struct {
	Service *core.BaseService

	// Requests the version of the API as of a date in the format `YYYY-MM-DD`. Any date up to the current date may be
	// provided. Specify the current date to request the latest version.
	Version *string

	// The infrastructure generation for the request. For the API behavior documented here, use
	// `2`.
	generation *int64
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://us-south.iaas.cloud.ibm.com/v1"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "vpc"

// VpcV1Options : Service options
type VpcV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator

	// Requests the version of the API as of a date in the format `YYYY-MM-DD`. Any date up to the current date may be
	// provided. Specify the current date to request the latest version.
	Version *string
}

// NewVpcV1UsingExternalConfig : constructs an instance of VpcV1 with passed in options and external configuration.
func NewVpcV1UsingExternalConfig(options *VpcV1Options) (vpc *VpcV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	vpc, err = NewVpcV1(options)
	if err != nil {
		return
	}

	err = vpc.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = vpc.Service.SetServiceURL(options.URL)
	}
	return
}

// NewVpcV1 : constructs an instance of VpcV1 with passed in options.
func NewVpcV1(options *VpcV1Options) (service *VpcV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	if options.Version == nil {
		options.Version = core.StringPtr("2020-03-24")
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	service = &VpcV1{
		Service:    baseService,
		Version:    options.Version,
		generation: core.Int64Ptr(2),
	}

	return
}

// SetServiceURL sets the service URL
func (vpc *VpcV1) SetServiceURL(url string) error {
	return vpc.Service.SetServiceURL(url)
}

// ListFloatingIps : List all floating IPs
// This request retrieves all floating IPs in the region. Floating IPs allow inbound and outbound traffic from the
// Internet to an instance.
func (vpc *VpcV1) ListFloatingIps(listFloatingIpsOptions *ListFloatingIpsOptions) (result *FloatingIPCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listFloatingIpsOptions, "listFloatingIpsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"floating_ips"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listFloatingIpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListFloatingIps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listFloatingIpsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listFloatingIpsOptions.Start))
	}
	if listFloatingIpsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listFloatingIpsOptions.Limit))
	}
	if listFloatingIpsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listFloatingIpsOptions.ResourceGroupID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalFloatingIPCollection(m)
		response.Result = result
	}

	return
}

// ReserveFloatingIp : Reserve a floating IP
// This request reserves a new floating IP.
func (vpc *VpcV1) ReserveFloatingIp(reserveFloatingIpOptions *ReserveFloatingIpOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(reserveFloatingIpOptions, "reserveFloatingIpOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(reserveFloatingIpOptions, "reserveFloatingIpOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"floating_ips"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range reserveFloatingIpOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ReserveFloatingIp")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(reserveFloatingIpOptions.FloatingIPPrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalFloatingIP(m)
		response.Result = result
	}

	return
}

// ReleaseFloatingIp : Release the specified floating IP
// This request disassociates (if associated) and releases a floating IP. This operation cannot be reversed. For this
// request to succeed, the floating IP must not be required by another resource, such as a public gateway.
func (vpc *VpcV1) ReleaseFloatingIp(releaseFloatingIpOptions *ReleaseFloatingIpOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(releaseFloatingIpOptions, "releaseFloatingIpOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(releaseFloatingIpOptions, "releaseFloatingIpOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"floating_ips"}
	pathParameters := []string{*releaseFloatingIpOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range releaseFloatingIpOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ReleaseFloatingIp")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetFloatingIp : Retrieve the specified floating IP
// This request retrieves a single floating IP specified by the identifier in the URL.
func (vpc *VpcV1) GetFloatingIp(getFloatingIpOptions *GetFloatingIpOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getFloatingIpOptions, "getFloatingIpOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getFloatingIpOptions, "getFloatingIpOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"floating_ips"}
	pathParameters := []string{*getFloatingIpOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getFloatingIpOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetFloatingIp")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalFloatingIP(m)
		response.Result = result
	}

	return
}

// UpdateFloatingIp : Update the specified floating IP
// This request updates a floating IP's name and/or target.
func (vpc *VpcV1) UpdateFloatingIp(updateFloatingIpOptions *UpdateFloatingIpOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateFloatingIpOptions, "updateFloatingIpOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateFloatingIpOptions, "updateFloatingIpOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"floating_ips"}
	pathParameters := []string{*updateFloatingIpOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateFloatingIpOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateFloatingIp")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateFloatingIpOptions.Name != nil {
		body["name"] = updateFloatingIpOptions.Name
	}
	if updateFloatingIpOptions.Target != nil {
		body["target"] = updateFloatingIpOptions.Target
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalFloatingIP(m)
		response.Result = result
	}

	return
}

// ListRegions : List all regions
// This request lists all regions. Each region is a separate geographic area that contains multiple isolated zones.
// Resources can be provisioned into a one or more zones in a region. Each zone is isolated, but connected to other
// zones in the same region with low-latency and high-bandwidth links. Regions represent the top-level of fault
// isolation available. Resources deployed within a single region also benefit from the low latency afforded by
// geographic proximity.
func (vpc *VpcV1) ListRegions(listRegionsOptions *ListRegionsOptions) (result *RegionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listRegionsOptions, "listRegionsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"regions"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listRegionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListRegions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalRegionCollection(m)
		response.Result = result
	}

	return
}

// GetRegion : Retrieve a region
// This request retrieves a single region specified by the name in the URL.
func (vpc *VpcV1) GetRegion(getRegionOptions *GetRegionOptions) (result *Region, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getRegionOptions, "getRegionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getRegionOptions, "getRegionOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"regions"}
	pathParameters := []string{*getRegionOptions.Name}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getRegionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetRegion")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalRegion(m)
		response.Result = result
	}

	return
}

// ListZones : List all zones in a region
// This request lists all zones in a region. Zones represent logically-isolated data centers with high-bandwidth and
// low-latency interconnects to other zones in the same region. Faults in a zone do not affect other zones.
func (vpc *VpcV1) ListZones(listZonesOptions *ListZonesOptions) (result *ZoneCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listZonesOptions, "listZonesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listZonesOptions, "listZonesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"regions", "zones"}
	pathParameters := []string{*listZonesOptions.RegionName}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listZonesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListZones")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalZoneCollection(m)
		response.Result = result
	}

	return
}

// GetZone : Retrieve a zone
// This request retrieves a single zone specified by the region and zone names in the URL.
func (vpc *VpcV1) GetZone(getZoneOptions *GetZoneOptions) (result *Zone, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getZoneOptions, "getZoneOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getZoneOptions, "getZoneOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"regions", "zones"}
	pathParameters := []string{*getZoneOptions.RegionName, *getZoneOptions.ZoneName}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getZoneOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetZone")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalZone(m)
		response.Result = result
	}

	return
}

// ListImages : List all images
// This request lists all images available in the region. An image provides source data for a volume. Images are either
// system-provided, or created from another source, such as importing from object storage.
func (vpc *VpcV1) ListImages(listImagesOptions *ListImagesOptions) (result *ImageCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listImagesOptions, "listImagesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"images"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listImagesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListImages")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listImagesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listImagesOptions.Start))
	}
	if listImagesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listImagesOptions.Limit))
	}
	if listImagesOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listImagesOptions.ResourceGroupID))
	}
	if listImagesOptions.Visibility != nil {
		builder.AddQuery("visibility", fmt.Sprint(*listImagesOptions.Visibility))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalImageCollection(m)
		response.Result = result
	}

	return
}

// CreateImage : Create an image
// This request creates a new image from an image prototype object. The prototype object is structured in the same way
// as a retrieved image, and contains the information necessary to create the new image. A URL to the image file on
// object storage must be provided.
func (vpc *VpcV1) CreateImage(createImageOptions *CreateImageOptions) (result *Image, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createImageOptions, "createImageOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createImageOptions, "createImageOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"images"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createImageOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateImage")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createImageOptions.ImagePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalImage(m)
		response.Result = result
	}

	return
}

// DeleteImage : Delete specified image
// This request deletes an image. This operation cannot be reversed. System-provided images are not allowed to be
// deleted. An image with a `status` of `pending`, `tentative`, or `deleting` cannot be deleted.
func (vpc *VpcV1) DeleteImage(deleteImageOptions *DeleteImageOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteImageOptions, "deleteImageOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteImageOptions, "deleteImageOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"images"}
	pathParameters := []string{*deleteImageOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteImageOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteImage")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetImage : Retrieve the specified image
// This request retrieves a single image specified by the identifier in the URL.
func (vpc *VpcV1) GetImage(getImageOptions *GetImageOptions) (result *Image, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getImageOptions, "getImageOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getImageOptions, "getImageOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"images"}
	pathParameters := []string{*getImageOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getImageOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetImage")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalImage(m)
		response.Result = result
	}

	return
}

// UpdateImage : Update specified image
// This request updates an image with the information in a provided image patch. The image patch object is structured in
// the same way as a retrieved image and contains only the information to be updated. System-provided images are not
// allowed to be updated. An image with a `status` of `deleting` cannot be updated.
func (vpc *VpcV1) UpdateImage(updateImageOptions *UpdateImageOptions) (result *Image, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateImageOptions, "updateImageOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateImageOptions, "updateImageOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"images"}
	pathParameters := []string{*updateImageOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateImageOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateImage")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateImageOptions.Name != nil {
		body["name"] = updateImageOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalImage(m)
		response.Result = result
	}

	return
}

// ListOperatingSystems : Retrieves all operating systems
// This request retrieves all operating systems.
func (vpc *VpcV1) ListOperatingSystems(listOperatingSystemsOptions *ListOperatingSystemsOptions) (result *OperatingSystemCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listOperatingSystemsOptions, "listOperatingSystemsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"operating_systems"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listOperatingSystemsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListOperatingSystems")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listOperatingSystemsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listOperatingSystemsOptions.Start))
	}
	if listOperatingSystemsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listOperatingSystemsOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalOperatingSystemCollection(m)
		response.Result = result
	}

	return
}

// GetOperatingSystem : Retrieves an operating system
// This request retrieves a single operating system specified by the name in the URL.
func (vpc *VpcV1) GetOperatingSystem(getOperatingSystemOptions *GetOperatingSystemOptions) (result *OperatingSystem, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getOperatingSystemOptions, "getOperatingSystemOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getOperatingSystemOptions, "getOperatingSystemOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"operating_systems"}
	pathParameters := []string{*getOperatingSystemOptions.Name}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getOperatingSystemOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetOperatingSystem")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalOperatingSystem(m)
		response.Result = result
	}

	return
}

// ListInstanceProfiles : List all instance profiles
// This request lists all instance profiles available in the region. An instance profile specifies the performance
// characteristics and pricing model for an instance.
func (vpc *VpcV1) ListInstanceProfiles(listInstanceProfilesOptions *ListInstanceProfilesOptions) (result *InstanceProfileCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listInstanceProfilesOptions, "listInstanceProfilesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance/profiles"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceProfilesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceProfiles")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalInstanceProfileCollection(m)
		response.Result = result
	}

	return
}

// GetInstanceProfile : Retrieve specified instance profile
// This request retrieves a single instance profile specified by the name in the URL.
func (vpc *VpcV1) GetInstanceProfile(getInstanceProfileOptions *GetInstanceProfileOptions) (result *InstanceProfile, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceProfileOptions, "getInstanceProfileOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceProfileOptions, "getInstanceProfileOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance/profiles"}
	pathParameters := []string{*getInstanceProfileOptions.Name}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceProfileOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceProfile")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalInstanceProfile(m)
		response.Result = result
	}

	return
}

// ListInstances : List all instances
// This request lists all instances in the region.
func (vpc *VpcV1) ListInstances(listInstancesOptions *ListInstancesOptions) (result *InstanceCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listInstancesOptions, "listInstancesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstancesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstances")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listInstancesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listInstancesOptions.Start))
	}
	if listInstancesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listInstancesOptions.Limit))
	}
	if listInstancesOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listInstancesOptions.ResourceGroupID))
	}
	if listInstancesOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listInstancesOptions.Name))
	}
	if listInstancesOptions.VpcID != nil {
		builder.AddQuery("vpc.id", fmt.Sprint(*listInstancesOptions.VpcID))
	}
	if listInstancesOptions.VpcCrn != nil {
		builder.AddQuery("vpc.crn", fmt.Sprint(*listInstancesOptions.VpcCrn))
	}
	if listInstancesOptions.VpcName != nil {
		builder.AddQuery("vpc.name", fmt.Sprint(*listInstancesOptions.VpcName))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalInstanceCollection(m)
		response.Result = result
	}

	return
}

// CreateInstance : Create an instance
// This request provisions a new instance from an instance prototype object. The prototype object is structured in the
// same way as a retrieved instance, and contains the information necessary to provision the new instance. The instance
// is automatically started.
func (vpc *VpcV1) CreateInstance(createInstanceOptions *CreateInstanceOptions) (result *Instance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceOptions, "createInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceOptions, "createInstanceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createInstanceOptions.InstancePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalInstance(m)
		response.Result = result
	}

	return
}

// DeleteInstance : Delete specified instance
// This request deletes an instance. This operation cannot be reversed. Any floating IPs associated with the instance's
// network interfaces are implicitly disassociated.
func (vpc *VpcV1) DeleteInstance(deleteInstanceOptions *DeleteInstanceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceOptions, "deleteInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceOptions, "deleteInstanceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances"}
	pathParameters := []string{*deleteInstanceOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstance : Retrieve an instance
// This request retrieves a single instance specified by the identifier in the URL.
func (vpc *VpcV1) GetInstance(getInstanceOptions *GetInstanceOptions) (result *Instance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceOptions, "getInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceOptions, "getInstanceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances"}
	pathParameters := []string{*getInstanceOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalInstance(m)
		response.Result = result
	}

	return
}

// UpdateInstance : Update specified instance
// This request updates an instance with the information in a provided instance patch. The instance patch object is
// structured in the same way as a retrieved instance and contains only the information to be updated.
func (vpc *VpcV1) UpdateInstance(updateInstanceOptions *UpdateInstanceOptions) (result *Instance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateInstanceOptions, "updateInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateInstanceOptions, "updateInstanceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances"}
	pathParameters := []string{*updateInstanceOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateInstanceOptions.Name != nil {
		body["name"] = updateInstanceOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalInstance(m)
		response.Result = result
	}

	return
}

// GetInstanceInitialization : Retrieve configuration used to initialize the instance
// This request retrieves configuration variables used to initialize the instance, such as SSH keys and the Windows
// administrator password.
func (vpc *VpcV1) GetInstanceInitialization(getInstanceInitializationOptions *GetInstanceInitializationOptions) (result *InstanceInitialization, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceInitializationOptions, "getInstanceInitializationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceInitializationOptions, "getInstanceInitializationOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "initialization"}
	pathParameters := []string{*getInstanceInitializationOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceInitializationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceInitialization")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalInstanceInitialization(m)
		response.Result = result
	}

	return
}

// CreateInstanceAction : Create an instance action
// This request creates a new action which will be queued up to run as soon as any pending or running actions have
// completed.
func (vpc *VpcV1) CreateInstanceAction(createInstanceActionOptions *CreateInstanceActionOptions) (result *InstanceAction, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceActionOptions, "createInstanceActionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceActionOptions, "createInstanceActionOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "actions"}
	pathParameters := []string{*createInstanceActionOptions.InstanceID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceActionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstanceAction")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createInstanceActionOptions.Type != nil {
		body["type"] = createInstanceActionOptions.Type
	}
	if createInstanceActionOptions.Force != nil {
		body["force"] = createInstanceActionOptions.Force
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalInstanceAction(m)
		response.Result = result
	}

	return
}

// ListNetworkInterfaces : List all network interfaces on an instance
// This request lists all network interfaces on an instance. A network interface is an abstract representation of a
// network interface card and connects an instance to a subnet. While each network interface can attach to only one
// subnet, multiple network interfaces can be created to attach to multiple subnets. Multiple interfaces may also attach
// to the same subnet.
func (vpc *VpcV1) ListNetworkInterfaces(listNetworkInterfacesOptions *ListNetworkInterfacesOptions) (result *NetworkInterfaceCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listNetworkInterfacesOptions, "listNetworkInterfacesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listNetworkInterfacesOptions, "listNetworkInterfacesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "network_interfaces"}
	pathParameters := []string{*listNetworkInterfacesOptions.InstanceID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listNetworkInterfacesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListNetworkInterfaces")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalNetworkInterfaceCollection(m)
		response.Result = result
	}

	return
}

// CreateNetworkInterface : Create a network interface
// This request creates a new network interface from a network interface prototype object. The prototype object is
// structured in the same way as a retrieved network interface, and contains the information necessary to create the new
// network interface. Any subnet in the instance's VPC may be specified, even if it is already attached to another
// network interface. Addresses on the network interface must be within the specified subnet's CIDR blocks.
func (vpc *VpcV1) CreateNetworkInterface(createNetworkInterfaceOptions *CreateNetworkInterfaceOptions) (result *NetworkInterface, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createNetworkInterfaceOptions, "createNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createNetworkInterfaceOptions, "createNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "network_interfaces"}
	pathParameters := []string{*createNetworkInterfaceOptions.InstanceID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createNetworkInterfaceOptions.Subnet != nil {
		body["subnet"] = createNetworkInterfaceOptions.Subnet
	}
	if createNetworkInterfaceOptions.Name != nil {
		body["name"] = createNetworkInterfaceOptions.Name
	}
	if createNetworkInterfaceOptions.PrimaryIpv4Address != nil {
		body["primary_ipv4_address"] = createNetworkInterfaceOptions.PrimaryIpv4Address
	}
	if createNetworkInterfaceOptions.SecurityGroups != nil {
		body["security_groups"] = createNetworkInterfaceOptions.SecurityGroups
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalNetworkInterface(m)
		response.Result = result
	}

	return
}

// DeleteNetworkInterface : Delete specified network interface
// This request deletes a network interface. This operation cannot be reversed. Any floating IPs associated with the
// network interface are implicitly disassociated.  The primary network interface is not allowed to be deleted.
func (vpc *VpcV1) DeleteNetworkInterface(deleteNetworkInterfaceOptions *DeleteNetworkInterfaceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteNetworkInterfaceOptions, "deleteNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteNetworkInterfaceOptions, "deleteNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "network_interfaces"}
	pathParameters := []string{*deleteNetworkInterfaceOptions.InstanceID, *deleteNetworkInterfaceOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetNetworkInterface : Retrieve specified network interface
// This request retrieves a single network interface specified by the identifier in the URL.
func (vpc *VpcV1) GetNetworkInterface(getNetworkInterfaceOptions *GetNetworkInterfaceOptions) (result *NetworkInterface, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getNetworkInterfaceOptions, "getNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getNetworkInterfaceOptions, "getNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "network_interfaces"}
	pathParameters := []string{*getNetworkInterfaceOptions.InstanceID, *getNetworkInterfaceOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalNetworkInterface(m)
		response.Result = result
	}

	return
}

// UpdateNetworkInterface : Update a network interface
// This request updates a network interface with the information in a provided network interface patch. The network
// interface patch object is structured in the same way as a retrieved network interface and can contain an updated name
// and/or port speed.
func (vpc *VpcV1) UpdateNetworkInterface(updateNetworkInterfaceOptions *UpdateNetworkInterfaceOptions) (result *NetworkInterface, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateNetworkInterfaceOptions, "updateNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateNetworkInterfaceOptions, "updateNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "network_interfaces"}
	pathParameters := []string{*updateNetworkInterfaceOptions.InstanceID, *updateNetworkInterfaceOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateNetworkInterfaceOptions.Name != nil {
		body["name"] = updateNetworkInterfaceOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalNetworkInterface(m)
		response.Result = result
	}

	return
}

// ListNetworkInterfaceFloatingIps : List all floating IPs associated with a network interface
// This request lists all floating IPs associated with a network interface.
func (vpc *VpcV1) ListNetworkInterfaceFloatingIps(listNetworkInterfaceFloatingIpsOptions *ListNetworkInterfaceFloatingIpsOptions) (result *FloatingIPUnpaginatedCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listNetworkInterfaceFloatingIpsOptions, "listNetworkInterfaceFloatingIpsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listNetworkInterfaceFloatingIpsOptions, "listNetworkInterfaceFloatingIpsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "network_interfaces", "floating_ips"}
	pathParameters := []string{*listNetworkInterfaceFloatingIpsOptions.InstanceID, *listNetworkInterfaceFloatingIpsOptions.NetworkInterfaceID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listNetworkInterfaceFloatingIpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListNetworkInterfaceFloatingIps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalFloatingIPUnpaginatedCollection(m)
		response.Result = result
	}

	return
}

// DeleteNetworkInterfaceFloatingIpBinding : Disassociate specified floating IP
// This request disassociates the specified floating IP from the specified network interface.
func (vpc *VpcV1) DeleteNetworkInterfaceFloatingIpBinding(deleteNetworkInterfaceFloatingIpBindingOptions *DeleteNetworkInterfaceFloatingIpBindingOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteNetworkInterfaceFloatingIpBindingOptions, "deleteNetworkInterfaceFloatingIpBindingOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteNetworkInterfaceFloatingIpBindingOptions, "deleteNetworkInterfaceFloatingIpBindingOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "network_interfaces", "floating_ips"}
	pathParameters := []string{*deleteNetworkInterfaceFloatingIpBindingOptions.InstanceID, *deleteNetworkInterfaceFloatingIpBindingOptions.NetworkInterfaceID, *deleteNetworkInterfaceFloatingIpBindingOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteNetworkInterfaceFloatingIpBindingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteNetworkInterfaceFloatingIpBinding")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetNetworkInterfaceFloatingIp : Retrieve associated floating IP
// This request a retrieves a specified floating IP address if it is associated with the network interface and instance
// specified in the URL.
func (vpc *VpcV1) GetNetworkInterfaceFloatingIp(getNetworkInterfaceFloatingIpOptions *GetNetworkInterfaceFloatingIpOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getNetworkInterfaceFloatingIpOptions, "getNetworkInterfaceFloatingIpOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getNetworkInterfaceFloatingIpOptions, "getNetworkInterfaceFloatingIpOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "network_interfaces", "floating_ips"}
	pathParameters := []string{*getNetworkInterfaceFloatingIpOptions.InstanceID, *getNetworkInterfaceFloatingIpOptions.NetworkInterfaceID, *getNetworkInterfaceFloatingIpOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getNetworkInterfaceFloatingIpOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetNetworkInterfaceFloatingIp")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalFloatingIP(m)
		response.Result = result
	}

	return
}

// CreateNetworkInterfaceFloatingIpBinding : Associate a floating IP with a network interface
// This request associates the specified floating IP with the specified network interface, replacing any existing
// association. For this request to succeed, the existing floating IP must not be required by another resource, such as
// a public gateway. A request body is not required, and if supplied, is ignored.
func (vpc *VpcV1) CreateNetworkInterfaceFloatingIpBinding(createNetworkInterfaceFloatingIpBindingOptions *CreateNetworkInterfaceFloatingIpBindingOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createNetworkInterfaceFloatingIpBindingOptions, "createNetworkInterfaceFloatingIpBindingOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createNetworkInterfaceFloatingIpBindingOptions, "createNetworkInterfaceFloatingIpBindingOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "network_interfaces", "floating_ips"}
	pathParameters := []string{*createNetworkInterfaceFloatingIpBindingOptions.InstanceID, *createNetworkInterfaceFloatingIpBindingOptions.NetworkInterfaceID, *createNetworkInterfaceFloatingIpBindingOptions.ID}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createNetworkInterfaceFloatingIpBindingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateNetworkInterfaceFloatingIpBinding")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalFloatingIP(m)
		response.Result = result
	}

	return
}

// ListVolumeAttachments : List all volumes attached to an instance
// This request lists all volume attachments for an instance. A volume attachment connects a volume to an instance. Each
// instance may have many volume attachments but each volume attachment connects exactly one instance to exactly one
// volume.
func (vpc *VpcV1) ListVolumeAttachments(listVolumeAttachmentsOptions *ListVolumeAttachmentsOptions) (result *VolumeAttachmentCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVolumeAttachmentsOptions, "listVolumeAttachmentsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVolumeAttachmentsOptions, "listVolumeAttachmentsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "volume_attachments"}
	pathParameters := []string{*listVolumeAttachmentsOptions.InstanceID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVolumeAttachmentsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVolumeAttachments")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVolumeAttachmentCollection(m)
		response.Result = result
	}

	return
}

// CreateVolumeAttachment : Create a volume attachment, connecting a volume to an instance
// This request creates a new volume attachment from a volume attachment prototype object. The prototype object is
// structured in the same way as a retrieved volume attachment, and contains the information necessary to create the new
// volume attachment. The creation of a new volume attachment connects a volume to an instance.
func (vpc *VpcV1) CreateVolumeAttachment(createVolumeAttachmentOptions *CreateVolumeAttachmentOptions) (result *VolumeAttachment, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVolumeAttachmentOptions, "createVolumeAttachmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVolumeAttachmentOptions, "createVolumeAttachmentOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "volume_attachments"}
	pathParameters := []string{*createVolumeAttachmentOptions.InstanceID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVolumeAttachmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVolumeAttachment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVolumeAttachmentOptions.Volume != nil {
		body["volume"] = createVolumeAttachmentOptions.Volume
	}
	if createVolumeAttachmentOptions.DeleteVolumeOnInstanceDelete != nil {
		body["delete_volume_on_instance_delete"] = createVolumeAttachmentOptions.DeleteVolumeOnInstanceDelete
	}
	if createVolumeAttachmentOptions.Name != nil {
		body["name"] = createVolumeAttachmentOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVolumeAttachment(m)
		response.Result = result
	}

	return
}

// DeleteVolumeAttachment : Delete a volume attachment, detaching a volume from an instance
// This request deletes a volume attachment. The deletion of a volume attachment detaches a volume from an instance.
func (vpc *VpcV1) DeleteVolumeAttachment(deleteVolumeAttachmentOptions *DeleteVolumeAttachmentOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVolumeAttachmentOptions, "deleteVolumeAttachmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVolumeAttachmentOptions, "deleteVolumeAttachmentOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "volume_attachments"}
	pathParameters := []string{*deleteVolumeAttachmentOptions.InstanceID, *deleteVolumeAttachmentOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVolumeAttachmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVolumeAttachment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVolumeAttachment : Retrieve specified volume attachment
// This request retrieves a single volume attachment specified by the identifier in the URL.
func (vpc *VpcV1) GetVolumeAttachment(getVolumeAttachmentOptions *GetVolumeAttachmentOptions) (result *VolumeAttachment, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVolumeAttachmentOptions, "getVolumeAttachmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVolumeAttachmentOptions, "getVolumeAttachmentOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "volume_attachments"}
	pathParameters := []string{*getVolumeAttachmentOptions.InstanceID, *getVolumeAttachmentOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVolumeAttachmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVolumeAttachment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVolumeAttachment(m)
		response.Result = result
	}

	return
}

// UpdateVolumeAttachment : Update a volume attachment
// This request updates a volume attachment with the information in a provided volume attachment patch. The volume
// attachment patch object is structured in the same way as a retrieved volume attachment and can contain an updated
// name.
func (vpc *VpcV1) UpdateVolumeAttachment(updateVolumeAttachmentOptions *UpdateVolumeAttachmentOptions) (result *VolumeAttachment, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVolumeAttachmentOptions, "updateVolumeAttachmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVolumeAttachmentOptions, "updateVolumeAttachmentOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "volume_attachments"}
	pathParameters := []string{*updateVolumeAttachmentOptions.InstanceID, *updateVolumeAttachmentOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVolumeAttachmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVolumeAttachment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateVolumeAttachmentOptions.DeleteVolumeOnInstanceDelete != nil {
		body["delete_volume_on_instance_delete"] = updateVolumeAttachmentOptions.DeleteVolumeOnInstanceDelete
	}
	if updateVolumeAttachmentOptions.Name != nil {
		body["name"] = updateVolumeAttachmentOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVolumeAttachment(m)
		response.Result = result
	}

	return
}

// ListLoadBalancers : List all load balancers
// This request retrieves a paginated list of all load balancers that belong to this account.
func (vpc *VpcV1) ListLoadBalancers(listLoadBalancersOptions *ListLoadBalancersOptions) (result *LoadBalancerCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listLoadBalancersOptions, "listLoadBalancersOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancers")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerCollection(m)
		response.Result = result
	}

	return
}

// CreateLoadBalancer : Create and provision a load balancer
// This request creates and provisions a new load balancer.
func (vpc *VpcV1) CreateLoadBalancer(createLoadBalancerOptions *CreateLoadBalancerOptions) (result *LoadBalancer, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoadBalancerOptions, "createLoadBalancerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoadBalancerOptions, "createLoadBalancerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoadBalancerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateLoadBalancer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createLoadBalancerOptions.IsPublic != nil {
		body["is_public"] = createLoadBalancerOptions.IsPublic
	}
	if createLoadBalancerOptions.Subnets != nil {
		body["subnets"] = createLoadBalancerOptions.Subnets
	}
	if createLoadBalancerOptions.Listeners != nil {
		body["listeners"] = createLoadBalancerOptions.Listeners
	}
	if createLoadBalancerOptions.Name != nil {
		body["name"] = createLoadBalancerOptions.Name
	}
	if createLoadBalancerOptions.Pools != nil {
		body["pools"] = createLoadBalancerOptions.Pools
	}
	if createLoadBalancerOptions.ResourceGroup != nil {
		body["resource_group"] = createLoadBalancerOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancer(m)
		response.Result = result
	}

	return
}

// DeleteLoadBalancer : Delete a load balancer
// This request deletes a load balancer. This operation cannot be reversed.
func (vpc *VpcV1) DeleteLoadBalancer(deleteLoadBalancerOptions *DeleteLoadBalancerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoadBalancerOptions, "deleteLoadBalancerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoadBalancerOptions, "deleteLoadBalancerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers"}
	pathParameters := []string{*deleteLoadBalancerOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoadBalancerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteLoadBalancer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetLoadBalancer : Retrieve a load balancer
// This request retrieves a single load balancer specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancer(getLoadBalancerOptions *GetLoadBalancerOptions) (result *LoadBalancer, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerOptions, "getLoadBalancerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerOptions, "getLoadBalancerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers"}
	pathParameters := []string{*getLoadBalancerOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancer(m)
		response.Result = result
	}

	return
}

// UpdateLoadBalancer : Update a load balancer
// This request updates a load balancer.
func (vpc *VpcV1) UpdateLoadBalancer(updateLoadBalancerOptions *UpdateLoadBalancerOptions) (result *LoadBalancer, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoadBalancerOptions, "updateLoadBalancerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoadBalancerOptions, "updateLoadBalancerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers"}
	pathParameters := []string{*updateLoadBalancerOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoadBalancerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateLoadBalancer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateLoadBalancerOptions.Name != nil {
		body["name"] = updateLoadBalancerOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancer(m)
		response.Result = result
	}

	return
}

// GetLoadBalancerStatistics : List statistics of a load balancer
// This request lists statistics of a load balancer specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancerStatistics(getLoadBalancerStatisticsOptions *GetLoadBalancerStatisticsOptions) (result *LoadBalancerStatistics, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerStatisticsOptions, "getLoadBalancerStatisticsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerStatisticsOptions, "getLoadBalancerStatisticsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "statistics"}
	pathParameters := []string{*getLoadBalancerStatisticsOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerStatisticsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerStatistics")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerStatistics(m)
		response.Result = result
	}

	return
}

// ListLoadBalancerListeners : List all listeners of the load balancer
// This request retrieves a list of all listeners that belong to the load balancer.
func (vpc *VpcV1) ListLoadBalancerListeners(listLoadBalancerListenersOptions *ListLoadBalancerListenersOptions) (result *LoadBalancerListenerCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listLoadBalancerListenersOptions, "listLoadBalancerListenersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listLoadBalancerListenersOptions, "listLoadBalancerListenersOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners"}
	pathParameters := []string{*listLoadBalancerListenersOptions.LoadBalancerID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancerListenersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancerListeners")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerListenerCollection(m)
		response.Result = result
	}

	return
}

// CreateLoadBalancerListener : Create a listener
// This request creates a new listener to the load balancer.
func (vpc *VpcV1) CreateLoadBalancerListener(createLoadBalancerListenerOptions *CreateLoadBalancerListenerOptions) (result *LoadBalancerListener, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoadBalancerListenerOptions, "createLoadBalancerListenerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoadBalancerListenerOptions, "createLoadBalancerListenerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners"}
	pathParameters := []string{*createLoadBalancerListenerOptions.LoadBalancerID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoadBalancerListenerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateLoadBalancerListener")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createLoadBalancerListenerOptions.Port != nil {
		body["port"] = createLoadBalancerListenerOptions.Port
	}
	if createLoadBalancerListenerOptions.Protocol != nil {
		body["protocol"] = createLoadBalancerListenerOptions.Protocol
	}
	if createLoadBalancerListenerOptions.CertificateInstance != nil {
		body["certificate_instance"] = createLoadBalancerListenerOptions.CertificateInstance
	}
	if createLoadBalancerListenerOptions.ConnectionLimit != nil {
		body["connection_limit"] = createLoadBalancerListenerOptions.ConnectionLimit
	}
	if createLoadBalancerListenerOptions.DefaultPool != nil {
		body["default_pool"] = createLoadBalancerListenerOptions.DefaultPool
	}
	if createLoadBalancerListenerOptions.Policies != nil {
		body["policies"] = createLoadBalancerListenerOptions.Policies
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerListener(m)
		response.Result = result
	}

	return
}

// DeleteLoadBalancerListener : Delete a listener
// This request deletes a load balancer listener. This operation cannot be reversed.
func (vpc *VpcV1) DeleteLoadBalancerListener(deleteLoadBalancerListenerOptions *DeleteLoadBalancerListenerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoadBalancerListenerOptions, "deleteLoadBalancerListenerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoadBalancerListenerOptions, "deleteLoadBalancerListenerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners"}
	pathParameters := []string{*deleteLoadBalancerListenerOptions.LoadBalancerID, *deleteLoadBalancerListenerOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoadBalancerListenerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteLoadBalancerListener")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetLoadBalancerListener : Retrieve a listener
// This request retrieves a single listener specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancerListener(getLoadBalancerListenerOptions *GetLoadBalancerListenerOptions) (result *LoadBalancerListener, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerListenerOptions, "getLoadBalancerListenerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerListenerOptions, "getLoadBalancerListenerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners"}
	pathParameters := []string{*getLoadBalancerListenerOptions.LoadBalancerID, *getLoadBalancerListenerOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerListenerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerListener")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerListener(m)
		response.Result = result
	}

	return
}

// UpdateLoadBalancerListener : Update a listener
// This request updates a load balancer listener from a listener patch.
func (vpc *VpcV1) UpdateLoadBalancerListener(updateLoadBalancerListenerOptions *UpdateLoadBalancerListenerOptions) (result *LoadBalancerListener, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoadBalancerListenerOptions, "updateLoadBalancerListenerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoadBalancerListenerOptions, "updateLoadBalancerListenerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners"}
	pathParameters := []string{*updateLoadBalancerListenerOptions.LoadBalancerID, *updateLoadBalancerListenerOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoadBalancerListenerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateLoadBalancerListener")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateLoadBalancerListenerOptions.CertificateInstance != nil {
		body["certificate_instance"] = updateLoadBalancerListenerOptions.CertificateInstance
	}
	if updateLoadBalancerListenerOptions.ConnectionLimit != nil {
		body["connection_limit"] = updateLoadBalancerListenerOptions.ConnectionLimit
	}
	if updateLoadBalancerListenerOptions.DefaultPool != nil {
		body["default_pool"] = updateLoadBalancerListenerOptions.DefaultPool
	}
	if updateLoadBalancerListenerOptions.Port != nil {
		body["port"] = updateLoadBalancerListenerOptions.Port
	}
	if updateLoadBalancerListenerOptions.Protocol != nil {
		body["protocol"] = updateLoadBalancerListenerOptions.Protocol
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerListener(m)
		response.Result = result
	}

	return
}

// ListLoadBalancerListenerPolicies : List all policies of the load balancer listener
// Retrieves a list of all policies belonging to the load balancer listener.
func (vpc *VpcV1) ListLoadBalancerListenerPolicies(listLoadBalancerListenerPoliciesOptions *ListLoadBalancerListenerPoliciesOptions) (result *LoadBalancerListenerPolicyCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listLoadBalancerListenerPoliciesOptions, "listLoadBalancerListenerPoliciesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listLoadBalancerListenerPoliciesOptions, "listLoadBalancerListenerPoliciesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies"}
	pathParameters := []string{*listLoadBalancerListenerPoliciesOptions.LoadBalancerID, *listLoadBalancerListenerPoliciesOptions.ListenerID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancerListenerPoliciesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancerListenerPolicies")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyCollection(m)
		response.Result = result
	}

	return
}

// CreateLoadBalancerListenerPolicy : Create a policy for the load balancer listener
// Creates a new policy to the load balancer listener.
func (vpc *VpcV1) CreateLoadBalancerListenerPolicy(createLoadBalancerListenerPolicyOptions *CreateLoadBalancerListenerPolicyOptions) (result *LoadBalancerListenerPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoadBalancerListenerPolicyOptions, "createLoadBalancerListenerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoadBalancerListenerPolicyOptions, "createLoadBalancerListenerPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies"}
	pathParameters := []string{*createLoadBalancerListenerPolicyOptions.LoadBalancerID, *createLoadBalancerListenerPolicyOptions.ListenerID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoadBalancerListenerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateLoadBalancerListenerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createLoadBalancerListenerPolicyOptions.Action != nil {
		body["action"] = createLoadBalancerListenerPolicyOptions.Action
	}
	if createLoadBalancerListenerPolicyOptions.Priority != nil {
		body["priority"] = createLoadBalancerListenerPolicyOptions.Priority
	}
	if createLoadBalancerListenerPolicyOptions.Name != nil {
		body["name"] = createLoadBalancerListenerPolicyOptions.Name
	}
	if createLoadBalancerListenerPolicyOptions.Rules != nil {
		body["rules"] = createLoadBalancerListenerPolicyOptions.Rules
	}
	if createLoadBalancerListenerPolicyOptions.Target != nil {
		body["target"] = createLoadBalancerListenerPolicyOptions.Target
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicy(m)
		response.Result = result
	}

	return
}

// DeleteLoadBalancerListenerPolicy : Delete a policy of the load balancer listener
// Deletes a policy of the load balancer listener. This operation cannot be reversed.
func (vpc *VpcV1) DeleteLoadBalancerListenerPolicy(deleteLoadBalancerListenerPolicyOptions *DeleteLoadBalancerListenerPolicyOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoadBalancerListenerPolicyOptions, "deleteLoadBalancerListenerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoadBalancerListenerPolicyOptions, "deleteLoadBalancerListenerPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies"}
	pathParameters := []string{*deleteLoadBalancerListenerPolicyOptions.LoadBalancerID, *deleteLoadBalancerListenerPolicyOptions.ListenerID, *deleteLoadBalancerListenerPolicyOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoadBalancerListenerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteLoadBalancerListenerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetLoadBalancerListenerPolicy : Retrieve a policy of the load balancer listener
// Retrieve a single policy specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancerListenerPolicy(getLoadBalancerListenerPolicyOptions *GetLoadBalancerListenerPolicyOptions) (result *LoadBalancerListenerPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerListenerPolicyOptions, "getLoadBalancerListenerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerListenerPolicyOptions, "getLoadBalancerListenerPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies"}
	pathParameters := []string{*getLoadBalancerListenerPolicyOptions.LoadBalancerID, *getLoadBalancerListenerPolicyOptions.ListenerID, *getLoadBalancerListenerPolicyOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerListenerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerListenerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicy(m)
		response.Result = result
	}

	return
}

// UpdateLoadBalancerListenerPolicy : Update a policy of the load balancer listener
// Updates a policy from a policy patch.
func (vpc *VpcV1) UpdateLoadBalancerListenerPolicy(updateLoadBalancerListenerPolicyOptions *UpdateLoadBalancerListenerPolicyOptions) (result *LoadBalancerListenerPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoadBalancerListenerPolicyOptions, "updateLoadBalancerListenerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoadBalancerListenerPolicyOptions, "updateLoadBalancerListenerPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies"}
	pathParameters := []string{*updateLoadBalancerListenerPolicyOptions.LoadBalancerID, *updateLoadBalancerListenerPolicyOptions.ListenerID, *updateLoadBalancerListenerPolicyOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoadBalancerListenerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateLoadBalancerListenerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateLoadBalancerListenerPolicyOptions.Name != nil {
		body["name"] = updateLoadBalancerListenerPolicyOptions.Name
	}
	if updateLoadBalancerListenerPolicyOptions.Priority != nil {
		body["priority"] = updateLoadBalancerListenerPolicyOptions.Priority
	}
	if updateLoadBalancerListenerPolicyOptions.Target != nil {
		body["target"] = updateLoadBalancerListenerPolicyOptions.Target
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicy(m)
		response.Result = result
	}

	return
}

// ListLoadBalancerListenerPolicyRules : List all rules of the load balancer listener policy
// Retrieves a list of all rules belonging to the load balancer listener policy.
func (vpc *VpcV1) ListLoadBalancerListenerPolicyRules(listLoadBalancerListenerPolicyRulesOptions *ListLoadBalancerListenerPolicyRulesOptions) (result *LoadBalancerListenerPolicyRuleCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listLoadBalancerListenerPolicyRulesOptions, "listLoadBalancerListenerPolicyRulesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listLoadBalancerListenerPolicyRulesOptions, "listLoadBalancerListenerPolicyRulesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies", "rules"}
	pathParameters := []string{*listLoadBalancerListenerPolicyRulesOptions.LoadBalancerID, *listLoadBalancerListenerPolicyRulesOptions.ListenerID, *listLoadBalancerListenerPolicyRulesOptions.PolicyID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancerListenerPolicyRulesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancerListenerPolicyRules")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyRuleCollection(m)
		response.Result = result
	}

	return
}

// CreateLoadBalancerListenerPolicyRule : Create a rule for the load balancer listener policy
// Creates a new rule for the load balancer listener policy.
func (vpc *VpcV1) CreateLoadBalancerListenerPolicyRule(createLoadBalancerListenerPolicyRuleOptions *CreateLoadBalancerListenerPolicyRuleOptions) (result *LoadBalancerListenerPolicyRule, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoadBalancerListenerPolicyRuleOptions, "createLoadBalancerListenerPolicyRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoadBalancerListenerPolicyRuleOptions, "createLoadBalancerListenerPolicyRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies", "rules"}
	pathParameters := []string{*createLoadBalancerListenerPolicyRuleOptions.LoadBalancerID, *createLoadBalancerListenerPolicyRuleOptions.ListenerID, *createLoadBalancerListenerPolicyRuleOptions.PolicyID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoadBalancerListenerPolicyRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateLoadBalancerListenerPolicyRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createLoadBalancerListenerPolicyRuleOptions.Condition != nil {
		body["condition"] = createLoadBalancerListenerPolicyRuleOptions.Condition
	}
	if createLoadBalancerListenerPolicyRuleOptions.Type != nil {
		body["type"] = createLoadBalancerListenerPolicyRuleOptions.Type
	}
	if createLoadBalancerListenerPolicyRuleOptions.Value != nil {
		body["value"] = createLoadBalancerListenerPolicyRuleOptions.Value
	}
	if createLoadBalancerListenerPolicyRuleOptions.Field != nil {
		body["field"] = createLoadBalancerListenerPolicyRuleOptions.Field
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyRule(m)
		response.Result = result
	}

	return
}

// DeleteLoadBalancerListenerPolicyRule : Delete a rule from the load balancer listener policy
// Deletes a rule from the load balancer listener policy. This operation cannot be reversed.
func (vpc *VpcV1) DeleteLoadBalancerListenerPolicyRule(deleteLoadBalancerListenerPolicyRuleOptions *DeleteLoadBalancerListenerPolicyRuleOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoadBalancerListenerPolicyRuleOptions, "deleteLoadBalancerListenerPolicyRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoadBalancerListenerPolicyRuleOptions, "deleteLoadBalancerListenerPolicyRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies", "rules"}
	pathParameters := []string{*deleteLoadBalancerListenerPolicyRuleOptions.LoadBalancerID, *deleteLoadBalancerListenerPolicyRuleOptions.ListenerID, *deleteLoadBalancerListenerPolicyRuleOptions.PolicyID, *deleteLoadBalancerListenerPolicyRuleOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoadBalancerListenerPolicyRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteLoadBalancerListenerPolicyRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetLoadBalancerListenerPolicyRule : Retrieve a rule of the load balancer listener policy
// Retrieves a single rule specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancerListenerPolicyRule(getLoadBalancerListenerPolicyRuleOptions *GetLoadBalancerListenerPolicyRuleOptions) (result *LoadBalancerListenerPolicyRule, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerListenerPolicyRuleOptions, "getLoadBalancerListenerPolicyRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerListenerPolicyRuleOptions, "getLoadBalancerListenerPolicyRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies", "rules"}
	pathParameters := []string{*getLoadBalancerListenerPolicyRuleOptions.LoadBalancerID, *getLoadBalancerListenerPolicyRuleOptions.ListenerID, *getLoadBalancerListenerPolicyRuleOptions.PolicyID, *getLoadBalancerListenerPolicyRuleOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerListenerPolicyRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerListenerPolicyRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyRule(m)
		response.Result = result
	}

	return
}

// UpdateLoadBalancerListenerPolicyRule : Update a rule of the load balancer listener policy
// Updates a rule of the load balancer listener policy.
func (vpc *VpcV1) UpdateLoadBalancerListenerPolicyRule(updateLoadBalancerListenerPolicyRuleOptions *UpdateLoadBalancerListenerPolicyRuleOptions) (result *LoadBalancerListenerPolicyRule, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoadBalancerListenerPolicyRuleOptions, "updateLoadBalancerListenerPolicyRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoadBalancerListenerPolicyRuleOptions, "updateLoadBalancerListenerPolicyRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies", "rules"}
	pathParameters := []string{*updateLoadBalancerListenerPolicyRuleOptions.LoadBalancerID, *updateLoadBalancerListenerPolicyRuleOptions.ListenerID, *updateLoadBalancerListenerPolicyRuleOptions.PolicyID, *updateLoadBalancerListenerPolicyRuleOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoadBalancerListenerPolicyRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateLoadBalancerListenerPolicyRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateLoadBalancerListenerPolicyRuleOptions.Condition != nil {
		body["condition"] = updateLoadBalancerListenerPolicyRuleOptions.Condition
	}
	if updateLoadBalancerListenerPolicyRuleOptions.Field != nil {
		body["field"] = updateLoadBalancerListenerPolicyRuleOptions.Field
	}
	if updateLoadBalancerListenerPolicyRuleOptions.Type != nil {
		body["type"] = updateLoadBalancerListenerPolicyRuleOptions.Type
	}
	if updateLoadBalancerListenerPolicyRuleOptions.Value != nil {
		body["value"] = updateLoadBalancerListenerPolicyRuleOptions.Value
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyRule(m)
		response.Result = result
	}

	return
}

// ListLoadBalancerPools : List all pools of the load balancer
// This request lists all pools that belong to the load balancer.
func (vpc *VpcV1) ListLoadBalancerPools(listLoadBalancerPoolsOptions *ListLoadBalancerPoolsOptions) (result *LoadBalancerPoolCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listLoadBalancerPoolsOptions, "listLoadBalancerPoolsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listLoadBalancerPoolsOptions, "listLoadBalancerPoolsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools"}
	pathParameters := []string{*listLoadBalancerPoolsOptions.LoadBalancerID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancerPoolsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancerPools")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerPoolCollection(m)
		response.Result = result
	}

	return
}

// CreateLoadBalancerPool : Create a load balancer pool
// This request creates a new pool from a pool prototype object.
func (vpc *VpcV1) CreateLoadBalancerPool(createLoadBalancerPoolOptions *CreateLoadBalancerPoolOptions) (result *LoadBalancerPool, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoadBalancerPoolOptions, "createLoadBalancerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoadBalancerPoolOptions, "createLoadBalancerPoolOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools"}
	pathParameters := []string{*createLoadBalancerPoolOptions.LoadBalancerID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoadBalancerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateLoadBalancerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createLoadBalancerPoolOptions.Algorithm != nil {
		body["algorithm"] = createLoadBalancerPoolOptions.Algorithm
	}
	if createLoadBalancerPoolOptions.HealthMonitor != nil {
		body["health_monitor"] = createLoadBalancerPoolOptions.HealthMonitor
	}
	if createLoadBalancerPoolOptions.Protocol != nil {
		body["protocol"] = createLoadBalancerPoolOptions.Protocol
	}
	if createLoadBalancerPoolOptions.Members != nil {
		body["members"] = createLoadBalancerPoolOptions.Members
	}
	if createLoadBalancerPoolOptions.Name != nil {
		body["name"] = createLoadBalancerPoolOptions.Name
	}
	if createLoadBalancerPoolOptions.SessionPersistence != nil {
		body["session_persistence"] = createLoadBalancerPoolOptions.SessionPersistence
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerPool(m)
		response.Result = result
	}

	return
}

// DeleteLoadBalancerPool : Delete a pool
// This request deletes a load balancer pool. This operation cannot be reversed.
func (vpc *VpcV1) DeleteLoadBalancerPool(deleteLoadBalancerPoolOptions *DeleteLoadBalancerPoolOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoadBalancerPoolOptions, "deleteLoadBalancerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoadBalancerPoolOptions, "deleteLoadBalancerPoolOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools"}
	pathParameters := []string{*deleteLoadBalancerPoolOptions.LoadBalancerID, *deleteLoadBalancerPoolOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoadBalancerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteLoadBalancerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetLoadBalancerPool : Retrieve a load balancer pool
// This request retrieves a single pool specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancerPool(getLoadBalancerPoolOptions *GetLoadBalancerPoolOptions) (result *LoadBalancerPool, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerPoolOptions, "getLoadBalancerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerPoolOptions, "getLoadBalancerPoolOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools"}
	pathParameters := []string{*getLoadBalancerPoolOptions.LoadBalancerID, *getLoadBalancerPoolOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerPool(m)
		response.Result = result
	}

	return
}

// UpdateLoadBalancerPool : Update a load balancer pool
// This request updates a load balancer pool from a pool patch.
func (vpc *VpcV1) UpdateLoadBalancerPool(updateLoadBalancerPoolOptions *UpdateLoadBalancerPoolOptions) (result *LoadBalancerPool, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoadBalancerPoolOptions, "updateLoadBalancerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoadBalancerPoolOptions, "updateLoadBalancerPoolOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools"}
	pathParameters := []string{*updateLoadBalancerPoolOptions.LoadBalancerID, *updateLoadBalancerPoolOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoadBalancerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateLoadBalancerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateLoadBalancerPoolOptions.Algorithm != nil {
		body["algorithm"] = updateLoadBalancerPoolOptions.Algorithm
	}
	if updateLoadBalancerPoolOptions.HealthMonitor != nil {
		body["health_monitor"] = updateLoadBalancerPoolOptions.HealthMonitor
	}
	if updateLoadBalancerPoolOptions.Name != nil {
		body["name"] = updateLoadBalancerPoolOptions.Name
	}
	if updateLoadBalancerPoolOptions.Protocol != nil {
		body["protocol"] = updateLoadBalancerPoolOptions.Protocol
	}
	if updateLoadBalancerPoolOptions.SessionPersistence != nil {
		body["session_persistence"] = updateLoadBalancerPoolOptions.SessionPersistence
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerPool(m)
		response.Result = result
	}

	return
}

// ListLoadBalancerPoolMembers : List all members of the load balancer pool
// This request retrieves a paginated list of all members that belong to the pool.
func (vpc *VpcV1) ListLoadBalancerPoolMembers(listLoadBalancerPoolMembersOptions *ListLoadBalancerPoolMembersOptions) (result *LoadBalancerPoolMemberCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listLoadBalancerPoolMembersOptions, "listLoadBalancerPoolMembersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listLoadBalancerPoolMembersOptions, "listLoadBalancerPoolMembersOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools", "members"}
	pathParameters := []string{*listLoadBalancerPoolMembersOptions.LoadBalancerID, *listLoadBalancerPoolMembersOptions.PoolID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancerPoolMembersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancerPoolMembers")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerPoolMemberCollection(m)
		response.Result = result
	}

	return
}

// CreateLoadBalancerPoolMember : Create a member in the load balancer pool
// This request creates a new member and adds the member to the pool.
func (vpc *VpcV1) CreateLoadBalancerPoolMember(createLoadBalancerPoolMemberOptions *CreateLoadBalancerPoolMemberOptions) (result *LoadBalancerPoolMember, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoadBalancerPoolMemberOptions, "createLoadBalancerPoolMemberOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoadBalancerPoolMemberOptions, "createLoadBalancerPoolMemberOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools", "members"}
	pathParameters := []string{*createLoadBalancerPoolMemberOptions.LoadBalancerID, *createLoadBalancerPoolMemberOptions.PoolID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoadBalancerPoolMemberOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateLoadBalancerPoolMember")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createLoadBalancerPoolMemberOptions.Port != nil {
		body["port"] = createLoadBalancerPoolMemberOptions.Port
	}
	if createLoadBalancerPoolMemberOptions.Target != nil {
		body["target"] = createLoadBalancerPoolMemberOptions.Target
	}
	if createLoadBalancerPoolMemberOptions.Weight != nil {
		body["weight"] = createLoadBalancerPoolMemberOptions.Weight
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerPoolMember(m)
		response.Result = result
	}

	return
}

// UpdateLoadBalancerPoolMembers : Update members of the load balancer pool
// This request updates members of the load balancer pool from a collection of member prototype objects.
func (vpc *VpcV1) UpdateLoadBalancerPoolMembers(updateLoadBalancerPoolMembersOptions *UpdateLoadBalancerPoolMembersOptions) (result *LoadBalancerPoolMemberCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoadBalancerPoolMembersOptions, "updateLoadBalancerPoolMembersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoadBalancerPoolMembersOptions, "updateLoadBalancerPoolMembersOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools", "members"}
	pathParameters := []string{*updateLoadBalancerPoolMembersOptions.LoadBalancerID, *updateLoadBalancerPoolMembersOptions.PoolID}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoadBalancerPoolMembersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateLoadBalancerPoolMembers")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateLoadBalancerPoolMembersOptions.Members != nil {
		body["members"] = updateLoadBalancerPoolMembersOptions.Members
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerPoolMemberCollection(m)
		response.Result = result
	}

	return
}

// DeleteLoadBalancerPoolMember : Delete a member from the load balancer pool
// This request deletes a member from the pool. This operation cannot be reversed.
func (vpc *VpcV1) DeleteLoadBalancerPoolMember(deleteLoadBalancerPoolMemberOptions *DeleteLoadBalancerPoolMemberOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoadBalancerPoolMemberOptions, "deleteLoadBalancerPoolMemberOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoadBalancerPoolMemberOptions, "deleteLoadBalancerPoolMemberOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools", "members"}
	pathParameters := []string{*deleteLoadBalancerPoolMemberOptions.LoadBalancerID, *deleteLoadBalancerPoolMemberOptions.PoolID, *deleteLoadBalancerPoolMemberOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoadBalancerPoolMemberOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteLoadBalancerPoolMember")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetLoadBalancerPoolMember : Retrieve a member in the load balancer pool
// This request retrieves a single member specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancerPoolMember(getLoadBalancerPoolMemberOptions *GetLoadBalancerPoolMemberOptions) (result *LoadBalancerPoolMember, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerPoolMemberOptions, "getLoadBalancerPoolMemberOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerPoolMemberOptions, "getLoadBalancerPoolMemberOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools", "members"}
	pathParameters := []string{*getLoadBalancerPoolMemberOptions.LoadBalancerID, *getLoadBalancerPoolMemberOptions.PoolID, *getLoadBalancerPoolMemberOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerPoolMemberOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerPoolMember")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerPoolMember(m)
		response.Result = result
	}

	return
}

// UpdateLoadBalancerPoolMember : Update a member in the load balancer pool
// This request updates an existing member from a member patch.
func (vpc *VpcV1) UpdateLoadBalancerPoolMember(updateLoadBalancerPoolMemberOptions *UpdateLoadBalancerPoolMemberOptions) (result *LoadBalancerPoolMember, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoadBalancerPoolMemberOptions, "updateLoadBalancerPoolMemberOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoadBalancerPoolMemberOptions, "updateLoadBalancerPoolMemberOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools", "members"}
	pathParameters := []string{*updateLoadBalancerPoolMemberOptions.LoadBalancerID, *updateLoadBalancerPoolMemberOptions.PoolID, *updateLoadBalancerPoolMemberOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoadBalancerPoolMemberOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateLoadBalancerPoolMember")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateLoadBalancerPoolMemberOptions.Port != nil {
		body["port"] = updateLoadBalancerPoolMemberOptions.Port
	}
	if updateLoadBalancerPoolMemberOptions.Target != nil {
		body["target"] = updateLoadBalancerPoolMemberOptions.Target
	}
	if updateLoadBalancerPoolMemberOptions.Weight != nil {
		body["weight"] = updateLoadBalancerPoolMemberOptions.Weight
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalLoadBalancerPoolMember(m)
		response.Result = result
	}

	return
}

// ListNetworkAcls : List all network ACLs
// This request lists all network ACLs in the region. A network ACL defines a set of packet filtering (5-tuple) rules
// for all traffic in and out of a subnet. Both allow and deny rules can be defined, and rules are stateless such that
// reverse traffic in response to allowed traffic is not automatically permitted.
func (vpc *VpcV1) ListNetworkAcls(listNetworkAclsOptions *ListNetworkAclsOptions) (result *NetworkACLCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listNetworkAclsOptions, "listNetworkAclsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listNetworkAclsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListNetworkAcls")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listNetworkAclsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listNetworkAclsOptions.Start))
	}
	if listNetworkAclsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listNetworkAclsOptions.Limit))
	}
	if listNetworkAclsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listNetworkAclsOptions.ResourceGroupID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalNetworkACLCollection(m)
		response.Result = result
	}

	return
}

// CreateNetworkAcl : Create a network ACL
// This request creates a new network ACL from a network ACL prototype object. The prototype object is structured in the
// same way as a retrieved network ACL, and contains the information necessary to create the new network ACL.
func (vpc *VpcV1) CreateNetworkAcl(createNetworkAclOptions *CreateNetworkAclOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(createNetworkAclOptions, "createNetworkAclOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createNetworkAclOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateNetworkAcl")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	if createNetworkAclOptions.NetworkACLPrototype != nil {
		_, err = builder.SetBodyContentJSON(createNetworkAclOptions.NetworkACLPrototype)
		if err != nil {
			return
		}
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalNetworkACL(m)
		response.Result = result
	}

	return
}

// DeleteNetworkAcl : Delete specified network ACL
// This request deletes a network ACL. This operation cannot be reversed. For this request to succeed, the network ACL
// must not be the default network ACL for any VPCs, and the network ACL must not be attached to any subnets.
func (vpc *VpcV1) DeleteNetworkAcl(deleteNetworkAclOptions *DeleteNetworkAclOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteNetworkAclOptions, "deleteNetworkAclOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteNetworkAclOptions, "deleteNetworkAclOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls"}
	pathParameters := []string{*deleteNetworkAclOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteNetworkAclOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteNetworkAcl")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetNetworkAcl : Retrieve specified network ACL
// This request retrieves a single network ACL specified by the identifier in the URL.
func (vpc *VpcV1) GetNetworkAcl(getNetworkAclOptions *GetNetworkAclOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getNetworkAclOptions, "getNetworkAclOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getNetworkAclOptions, "getNetworkAclOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls"}
	pathParameters := []string{*getNetworkAclOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getNetworkAclOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetNetworkAcl")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalNetworkACL(m)
		response.Result = result
	}

	return
}

// UpdateNetworkAcl : Update a network ACL
// This request updates a network ACL's name.
func (vpc *VpcV1) UpdateNetworkAcl(updateNetworkAclOptions *UpdateNetworkAclOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateNetworkAclOptions, "updateNetworkAclOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateNetworkAclOptions, "updateNetworkAclOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls"}
	pathParameters := []string{*updateNetworkAclOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateNetworkAclOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateNetworkAcl")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateNetworkAclOptions.Name != nil {
		body["name"] = updateNetworkAclOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalNetworkACL(m)
		response.Result = result
	}

	return
}

// ListNetworkAclRules : List all rules for a network ACL
// This request lists all rules for a network ACL. These rules can allow or deny traffic between a source CIDR block and
// a destination CIDR block over a particular protocol and port range.
func (vpc *VpcV1) ListNetworkAclRules(listNetworkAclRulesOptions *ListNetworkAclRulesOptions) (result *NetworkACLRuleCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listNetworkAclRulesOptions, "listNetworkAclRulesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listNetworkAclRulesOptions, "listNetworkAclRulesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls", "rules"}
	pathParameters := []string{*listNetworkAclRulesOptions.NetworkAclID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listNetworkAclRulesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListNetworkAclRules")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listNetworkAclRulesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listNetworkAclRulesOptions.Start))
	}
	if listNetworkAclRulesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listNetworkAclRulesOptions.Limit))
	}
	if listNetworkAclRulesOptions.Direction != nil {
		builder.AddQuery("direction", fmt.Sprint(*listNetworkAclRulesOptions.Direction))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalNetworkACLRuleCollection(m)
		response.Result = result
	}

	return
}

// CreateNetworkAclRule : Create a rule
// This request creates a new rule from a network ACL rule prototype object. The prototype object is structured in the
// same way as a retrieved rule, and contains the information necessary to create the new rule.
func (vpc *VpcV1) CreateNetworkAclRule(createNetworkAclRuleOptions *CreateNetworkAclRuleOptions) (result NetworkACLRuleIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createNetworkAclRuleOptions, "createNetworkAclRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createNetworkAclRuleOptions, "createNetworkAclRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls", "rules"}
	pathParameters := []string{*createNetworkAclRuleOptions.NetworkAclID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createNetworkAclRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateNetworkAclRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createNetworkAclRuleOptions.NetworkACLRulePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalNetworkACLRule(m)
		response.Result = result
	}

	return
}

// DeleteNetworkAclRule : Delete specified rule
// This request deletes a rule. This operation cannot be reversed.
func (vpc *VpcV1) DeleteNetworkAclRule(deleteNetworkAclRuleOptions *DeleteNetworkAclRuleOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteNetworkAclRuleOptions, "deleteNetworkAclRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteNetworkAclRuleOptions, "deleteNetworkAclRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls", "rules"}
	pathParameters := []string{*deleteNetworkAclRuleOptions.NetworkAclID, *deleteNetworkAclRuleOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteNetworkAclRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteNetworkAclRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetNetworkAclRule : Retrieve specified rule
// This request retrieves a single rule specified by the identifier in the URL.
func (vpc *VpcV1) GetNetworkAclRule(getNetworkAclRuleOptions *GetNetworkAclRuleOptions) (result NetworkACLRuleIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getNetworkAclRuleOptions, "getNetworkAclRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getNetworkAclRuleOptions, "getNetworkAclRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls", "rules"}
	pathParameters := []string{*getNetworkAclRuleOptions.NetworkAclID, *getNetworkAclRuleOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getNetworkAclRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetNetworkAclRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalNetworkACLRule(m)
		response.Result = result
	}

	return
}

// UpdateNetworkAclRule : Update a rule
// This request updates a rule with the information in a provided rule patch. The rule patch object contains only the
// information to be updated. The request will fail if the information is not applicable to the rule's protocol.
func (vpc *VpcV1) UpdateNetworkAclRule(updateNetworkAclRuleOptions *UpdateNetworkAclRuleOptions) (result NetworkACLRuleIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateNetworkAclRuleOptions, "updateNetworkAclRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateNetworkAclRuleOptions, "updateNetworkAclRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls", "rules"}
	pathParameters := []string{*updateNetworkAclRuleOptions.NetworkAclID, *updateNetworkAclRuleOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateNetworkAclRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateNetworkAclRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateNetworkAclRuleOptions.Action != nil {
		body["action"] = updateNetworkAclRuleOptions.Action
	}
	if updateNetworkAclRuleOptions.Before != nil {
		body["before"] = updateNetworkAclRuleOptions.Before
	}
	if updateNetworkAclRuleOptions.Code != nil {
		body["code"] = updateNetworkAclRuleOptions.Code
	}
	if updateNetworkAclRuleOptions.Destination != nil {
		body["destination"] = updateNetworkAclRuleOptions.Destination
	}
	if updateNetworkAclRuleOptions.DestinationPortMax != nil {
		body["destination_port_max"] = updateNetworkAclRuleOptions.DestinationPortMax
	}
	if updateNetworkAclRuleOptions.DestinationPortMin != nil {
		body["destination_port_min"] = updateNetworkAclRuleOptions.DestinationPortMin
	}
	if updateNetworkAclRuleOptions.Direction != nil {
		body["direction"] = updateNetworkAclRuleOptions.Direction
	}
	if updateNetworkAclRuleOptions.Name != nil {
		body["name"] = updateNetworkAclRuleOptions.Name
	}
	if updateNetworkAclRuleOptions.Source != nil {
		body["source"] = updateNetworkAclRuleOptions.Source
	}
	if updateNetworkAclRuleOptions.SourcePortMax != nil {
		body["source_port_max"] = updateNetworkAclRuleOptions.SourcePortMax
	}
	if updateNetworkAclRuleOptions.SourcePortMin != nil {
		body["source_port_min"] = updateNetworkAclRuleOptions.SourcePortMin
	}
	if updateNetworkAclRuleOptions.Type != nil {
		body["type"] = updateNetworkAclRuleOptions.Type
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalNetworkACLRule(m)
		response.Result = result
	}

	return
}

// ListPublicGateways : List all public gateways
// This request lists all public gateways. A public gateway is a virtual network device associated with a VPC, which
// allows access to the Internet. A public gateway resides in a zone and can be connected to subnets in the same zone
// only.
func (vpc *VpcV1) ListPublicGateways(listPublicGatewaysOptions *ListPublicGatewaysOptions) (result *PublicGatewayCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listPublicGatewaysOptions, "listPublicGatewaysOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"public_gateways"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listPublicGatewaysOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListPublicGateways")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listPublicGatewaysOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listPublicGatewaysOptions.Start))
	}
	if listPublicGatewaysOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listPublicGatewaysOptions.Limit))
	}
	if listPublicGatewaysOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listPublicGatewaysOptions.ResourceGroupID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalPublicGatewayCollection(m)
		response.Result = result
	}

	return
}

// CreatePublicGateway : Create a public gateway
// This request creates a new public gateway from a public gateway prototype object. If a floating IP is provided, it
// must be unbound. If a floating IP is not provided, one will be created and bound to the public gateway. Once a public
// gateway has been created, its floating IP cannot be unbound. A public gateway must be explicitly attached to each
// subnet it will provide connectivity for.
func (vpc *VpcV1) CreatePublicGateway(createPublicGatewayOptions *CreatePublicGatewayOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createPublicGatewayOptions, "createPublicGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createPublicGatewayOptions, "createPublicGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"public_gateways"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createPublicGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreatePublicGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createPublicGatewayOptions.Vpc != nil {
		body["vpc"] = createPublicGatewayOptions.Vpc
	}
	if createPublicGatewayOptions.Zone != nil {
		body["zone"] = createPublicGatewayOptions.Zone
	}
	if createPublicGatewayOptions.FloatingIp != nil {
		body["floating_ip"] = createPublicGatewayOptions.FloatingIp
	}
	if createPublicGatewayOptions.Name != nil {
		body["name"] = createPublicGatewayOptions.Name
	}
	if createPublicGatewayOptions.ResourceGroup != nil {
		body["resource_group"] = createPublicGatewayOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalPublicGateway(m)
		response.Result = result
	}

	return
}

// DeletePublicGateway : Delete specified public gateway
// This request deletes a public gateway. This operation cannot be reversed. For this request to succeed, the public
// gateway must not be attached to any subnets. The public gateway's floating IP will be automatically unbound. If the
// floating IP was created when the public gateway was created, it will be deleted.
func (vpc *VpcV1) DeletePublicGateway(deletePublicGatewayOptions *DeletePublicGatewayOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deletePublicGatewayOptions, "deletePublicGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deletePublicGatewayOptions, "deletePublicGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"public_gateways"}
	pathParameters := []string{*deletePublicGatewayOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deletePublicGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeletePublicGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetPublicGateway : Retrieve specified public gateway
// This request retrieves a single public gateway specified by the identifier in the URL.
func (vpc *VpcV1) GetPublicGateway(getPublicGatewayOptions *GetPublicGatewayOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getPublicGatewayOptions, "getPublicGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getPublicGatewayOptions, "getPublicGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"public_gateways"}
	pathParameters := []string{*getPublicGatewayOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getPublicGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetPublicGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalPublicGateway(m)
		response.Result = result
	}

	return
}

// UpdatePublicGateway : Update a public gateway's name
// This request updates a public gateway's name.
func (vpc *VpcV1) UpdatePublicGateway(updatePublicGatewayOptions *UpdatePublicGatewayOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updatePublicGatewayOptions, "updatePublicGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updatePublicGatewayOptions, "updatePublicGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"public_gateways"}
	pathParameters := []string{*updatePublicGatewayOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updatePublicGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdatePublicGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updatePublicGatewayOptions.Name != nil {
		body["name"] = updatePublicGatewayOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalPublicGateway(m)
		response.Result = result
	}

	return
}

// ListKeys : List all keys
// This request lists all keys. A key contains a public SSH key which may be installed on instances when they are
// created. Private keys are not stored.
func (vpc *VpcV1) ListKeys(listKeysOptions *ListKeysOptions) (result *KeyCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listKeysOptions, "listKeysOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"keys"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listKeysOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListKeys")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listKeysOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listKeysOptions.ResourceGroupID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalKeyCollection(m)
		response.Result = result
	}

	return
}

// CreateKey : Create a key
// This request creates a new SSH key from an key prototype object. The prototype object is structured in the same way
// as a retrieved key, and contains the information necessary to create the new key. The public key value must be
// provided.
func (vpc *VpcV1) CreateKey(createKeyOptions *CreateKeyOptions) (result *Key, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createKeyOptions, "createKeyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createKeyOptions, "createKeyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"keys"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createKeyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateKey")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createKeyOptions.PublicKey != nil {
		body["public_key"] = createKeyOptions.PublicKey
	}
	if createKeyOptions.Name != nil {
		body["name"] = createKeyOptions.Name
	}
	if createKeyOptions.ResourceGroup != nil {
		body["resource_group"] = createKeyOptions.ResourceGroup
	}
	if createKeyOptions.Type != nil {
		body["type"] = createKeyOptions.Type
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalKey(m)
		response.Result = result
	}

	return
}

// DeleteKey : Delete specified key
// This request deletes a key. This operation cannot be reversed.
func (vpc *VpcV1) DeleteKey(deleteKeyOptions *DeleteKeyOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteKeyOptions, "deleteKeyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteKeyOptions, "deleteKeyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"keys"}
	pathParameters := []string{*deleteKeyOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteKeyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteKey")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetKey : Retrieve specified key
// This request retrieves a single key specified by the identifier in the URL.
func (vpc *VpcV1) GetKey(getKeyOptions *GetKeyOptions) (result *Key, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getKeyOptions, "getKeyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getKeyOptions, "getKeyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"keys"}
	pathParameters := []string{*getKeyOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getKeyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetKey")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalKey(m)
		response.Result = result
	}

	return
}

// UpdateKey : Update specified key
// This request updates a key's name.
func (vpc *VpcV1) UpdateKey(updateKeyOptions *UpdateKeyOptions) (result *Key, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateKeyOptions, "updateKeyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateKeyOptions, "updateKeyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"keys"}
	pathParameters := []string{*updateKeyOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateKeyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateKey")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateKeyOptions.Name != nil {
		body["name"] = updateKeyOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalKey(m)
		response.Result = result
	}

	return
}

// ListSecurityGroups : List all security groups
// This request lists all existing security groups. Security groups provide a convenient way to apply IP filtering rules
// to instances in the associated VPC. With security groups, all traffic is denied by default, and rules added to
// security groups define which traffic the security group permits. Security group rules are stateful such that reverse
// traffic in response to allowed traffic is automatically permitted.
func (vpc *VpcV1) ListSecurityGroups(listSecurityGroupsOptions *ListSecurityGroupsOptions) (result *SecurityGroupCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listSecurityGroupsOptions, "listSecurityGroupsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSecurityGroupsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListSecurityGroups")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listSecurityGroupsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listSecurityGroupsOptions.Start))
	}
	if listSecurityGroupsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSecurityGroupsOptions.Limit))
	}
	if listSecurityGroupsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listSecurityGroupsOptions.ResourceGroupID))
	}
	if listSecurityGroupsOptions.VpcID != nil {
		builder.AddQuery("vpc.id", fmt.Sprint(*listSecurityGroupsOptions.VpcID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalSecurityGroupCollection(m)
		response.Result = result
	}

	return
}

// CreateSecurityGroup : Create a security group
// This request creates a new security group from a security group prototype object. The prototype object is structured
// in the same way as a retrieved security group, and contains the information necessary to create the new security
// group. If security group rules are included in the protoype object, those rules will be added to the security group.
// Each security group is scoped to one VPC. Only network interfaces on instances in that VPC can be added to the
// security group.
func (vpc *VpcV1) CreateSecurityGroup(createSecurityGroupOptions *CreateSecurityGroupOptions) (result *SecurityGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSecurityGroupOptions, "createSecurityGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSecurityGroupOptions, "createSecurityGroupOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSecurityGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateSecurityGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createSecurityGroupOptions.Vpc != nil {
		body["vpc"] = createSecurityGroupOptions.Vpc
	}
	if createSecurityGroupOptions.Name != nil {
		body["name"] = createSecurityGroupOptions.Name
	}
	if createSecurityGroupOptions.ResourceGroup != nil {
		body["resource_group"] = createSecurityGroupOptions.ResourceGroup
	}
	if createSecurityGroupOptions.Rules != nil {
		body["rules"] = createSecurityGroupOptions.Rules
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalSecurityGroup(m)
		response.Result = result
	}

	return
}

// DeleteSecurityGroup : Delete a security group
// This request deletes a security group. A security group cannot be deleted if it is referenced by any network
// interfaces or other security group rules. Additionally, a VPC's default security group cannot be deleted. This
// operation cannot be reversed.
func (vpc *VpcV1) DeleteSecurityGroup(deleteSecurityGroupOptions *DeleteSecurityGroupOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSecurityGroupOptions, "deleteSecurityGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSecurityGroupOptions, "deleteSecurityGroupOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups"}
	pathParameters := []string{*deleteSecurityGroupOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSecurityGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteSecurityGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetSecurityGroup : Retrieve a security group
// This request retrieves a single security group specified by the identifier in the URL path.
func (vpc *VpcV1) GetSecurityGroup(getSecurityGroupOptions *GetSecurityGroupOptions) (result *SecurityGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSecurityGroupOptions, "getSecurityGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSecurityGroupOptions, "getSecurityGroupOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups"}
	pathParameters := []string{*getSecurityGroupOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSecurityGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSecurityGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalSecurityGroup(m)
		response.Result = result
	}

	return
}

// UpdateSecurityGroup : Update a security group
// This request updates a security group with the information provided in a security group patch object. The security
// group patch object is structured in the same way as a retrieved security group and contains only the information to
// be updated.
func (vpc *VpcV1) UpdateSecurityGroup(updateSecurityGroupOptions *UpdateSecurityGroupOptions) (result *SecurityGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSecurityGroupOptions, "updateSecurityGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSecurityGroupOptions, "updateSecurityGroupOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups"}
	pathParameters := []string{*updateSecurityGroupOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSecurityGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateSecurityGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateSecurityGroupOptions.Name != nil {
		body["name"] = updateSecurityGroupOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalSecurityGroup(m)
		response.Result = result
	}

	return
}

// ListSecurityGroupNetworkInterfaces : List a security group's network interfaces
// This request lists all network interfaces associated with the security group, to which the rules in the security
// group are applied.
func (vpc *VpcV1) ListSecurityGroupNetworkInterfaces(listSecurityGroupNetworkInterfacesOptions *ListSecurityGroupNetworkInterfacesOptions) (result *NetworkInterfaceCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSecurityGroupNetworkInterfacesOptions, "listSecurityGroupNetworkInterfacesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSecurityGroupNetworkInterfacesOptions, "listSecurityGroupNetworkInterfacesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups", "network_interfaces"}
	pathParameters := []string{*listSecurityGroupNetworkInterfacesOptions.SecurityGroupID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSecurityGroupNetworkInterfacesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListSecurityGroupNetworkInterfaces")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalNetworkInterfaceCollection(m)
		response.Result = result
	}

	return
}

// DeleteSecurityGroupNetworkInterfaceBinding : Remove a network interface from a security group
// This request removes a network interface from a security group. Security groups are stateful, so any changes to a
// network interface's security groups are applied to new connections. Existing connections are not affected. If the
// network interface being removed has no other security groups, it will be attached to the VPC's default security
// group.
func (vpc *VpcV1) DeleteSecurityGroupNetworkInterfaceBinding(deleteSecurityGroupNetworkInterfaceBindingOptions *DeleteSecurityGroupNetworkInterfaceBindingOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSecurityGroupNetworkInterfaceBindingOptions, "deleteSecurityGroupNetworkInterfaceBindingOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSecurityGroupNetworkInterfaceBindingOptions, "deleteSecurityGroupNetworkInterfaceBindingOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups", "network_interfaces"}
	pathParameters := []string{*deleteSecurityGroupNetworkInterfaceBindingOptions.SecurityGroupID, *deleteSecurityGroupNetworkInterfaceBindingOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSecurityGroupNetworkInterfaceBindingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteSecurityGroupNetworkInterfaceBinding")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetSecurityGroupNetworkInterface : Retrieve a network interface in a security group
// This request retrieves a single network interface specified by the identifier in the URL path. The network interface
// must be an existing member of the security group.
func (vpc *VpcV1) GetSecurityGroupNetworkInterface(getSecurityGroupNetworkInterfaceOptions *GetSecurityGroupNetworkInterfaceOptions) (result *NetworkInterface, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSecurityGroupNetworkInterfaceOptions, "getSecurityGroupNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSecurityGroupNetworkInterfaceOptions, "getSecurityGroupNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups", "network_interfaces"}
	pathParameters := []string{*getSecurityGroupNetworkInterfaceOptions.SecurityGroupID, *getSecurityGroupNetworkInterfaceOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSecurityGroupNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSecurityGroupNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalNetworkInterface(m)
		response.Result = result
	}

	return
}

// CreateSecurityGroupNetworkInterfaceBinding : Add a network interface to a security group
// This request adds an existing network interface to an existing security group. When a network interface is added to a
// security group, the security group rules are applied to the network interface. A request body is not required, and if
// supplied, is ignored.
func (vpc *VpcV1) CreateSecurityGroupNetworkInterfaceBinding(createSecurityGroupNetworkInterfaceBindingOptions *CreateSecurityGroupNetworkInterfaceBindingOptions) (result *NetworkInterface, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSecurityGroupNetworkInterfaceBindingOptions, "createSecurityGroupNetworkInterfaceBindingOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSecurityGroupNetworkInterfaceBindingOptions, "createSecurityGroupNetworkInterfaceBindingOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups", "network_interfaces"}
	pathParameters := []string{*createSecurityGroupNetworkInterfaceBindingOptions.SecurityGroupID, *createSecurityGroupNetworkInterfaceBindingOptions.ID}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSecurityGroupNetworkInterfaceBindingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateSecurityGroupNetworkInterfaceBinding")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalNetworkInterface(m)
		response.Result = result
	}

	return
}

// ListSecurityGroupRules : List all the rules of a security group
// This request lists all the security group rules for a particular security group. These rules define what traffic the
// security group permits. Security group rules are stateful, such that reverse traffic in response to allowed traffic
// is automatically permitted.
func (vpc *VpcV1) ListSecurityGroupRules(listSecurityGroupRulesOptions *ListSecurityGroupRulesOptions) (result *SecurityGroupRuleCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSecurityGroupRulesOptions, "listSecurityGroupRulesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSecurityGroupRulesOptions, "listSecurityGroupRulesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups", "rules"}
	pathParameters := []string{*listSecurityGroupRulesOptions.SecurityGroupID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSecurityGroupRulesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListSecurityGroupRules")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalSecurityGroupRuleCollection(m)
		response.Result = result
	}

	return
}

// CreateSecurityGroupRule : Create a security group rule
// This request creates a new security group rule from a security group rule prototype object. The prototype object is
// structured in the same way as a retrieved security group rule and contains the information necessary to create the
// rule. As part of creating a new rule in a security group, the rule is applied to all the networking interfaces in the
// security group. Rules specify which IP traffic a security group should allow. Security group rules are stateful, such
// that reverse traffic in response to allowed traffic is automatically permitted. A rule allowing inbound TCP traffic
// on port 80 also allows outbound TCP traffic on port 80 without the need for an additional rule.
func (vpc *VpcV1) CreateSecurityGroupRule(createSecurityGroupRuleOptions *CreateSecurityGroupRuleOptions) (result SecurityGroupRuleIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSecurityGroupRuleOptions, "createSecurityGroupRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSecurityGroupRuleOptions, "createSecurityGroupRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups", "rules"}
	pathParameters := []string{*createSecurityGroupRuleOptions.SecurityGroupID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSecurityGroupRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateSecurityGroupRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createSecurityGroupRuleOptions.SecurityGroupRulePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalSecurityGroupRule(m)
		response.Result = result
	}

	return
}

// DeleteSecurityGroupRule : Delete a security group rule
// This request deletes a security group rule. This operation cannot be reversed. Removing a security group rule will
// not end existing connections allowed by that rule.
func (vpc *VpcV1) DeleteSecurityGroupRule(deleteSecurityGroupRuleOptions *DeleteSecurityGroupRuleOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSecurityGroupRuleOptions, "deleteSecurityGroupRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSecurityGroupRuleOptions, "deleteSecurityGroupRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups", "rules"}
	pathParameters := []string{*deleteSecurityGroupRuleOptions.SecurityGroupID, *deleteSecurityGroupRuleOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSecurityGroupRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteSecurityGroupRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetSecurityGroupRule : Retrieve a security group rule
// This request retrieves a single security group rule specified by the identifier in the URL path.
func (vpc *VpcV1) GetSecurityGroupRule(getSecurityGroupRuleOptions *GetSecurityGroupRuleOptions) (result SecurityGroupRuleIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSecurityGroupRuleOptions, "getSecurityGroupRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSecurityGroupRuleOptions, "getSecurityGroupRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups", "rules"}
	pathParameters := []string{*getSecurityGroupRuleOptions.SecurityGroupID, *getSecurityGroupRuleOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSecurityGroupRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSecurityGroupRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalSecurityGroupRule(m)
		response.Result = result
	}

	return
}

// UpdateSecurityGroupRule : Update a security group rule
// This request updates a security group rule with the information in a provided rule patch object. The rule patch
// object contains only the information to be updated. The request will fail if the information is not applicable to the
// rule's protocol.
func (vpc *VpcV1) UpdateSecurityGroupRule(updateSecurityGroupRuleOptions *UpdateSecurityGroupRuleOptions) (result SecurityGroupRuleIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSecurityGroupRuleOptions, "updateSecurityGroupRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSecurityGroupRuleOptions, "updateSecurityGroupRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups", "rules"}
	pathParameters := []string{*updateSecurityGroupRuleOptions.SecurityGroupID, *updateSecurityGroupRuleOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSecurityGroupRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateSecurityGroupRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateSecurityGroupRuleOptions.Code != nil {
		body["code"] = updateSecurityGroupRuleOptions.Code
	}
	if updateSecurityGroupRuleOptions.Direction != nil {
		body["direction"] = updateSecurityGroupRuleOptions.Direction
	}
	if updateSecurityGroupRuleOptions.IpVersion != nil {
		body["ip_version"] = updateSecurityGroupRuleOptions.IpVersion
	}
	if updateSecurityGroupRuleOptions.PortMax != nil {
		body["port_max"] = updateSecurityGroupRuleOptions.PortMax
	}
	if updateSecurityGroupRuleOptions.PortMin != nil {
		body["port_min"] = updateSecurityGroupRuleOptions.PortMin
	}
	if updateSecurityGroupRuleOptions.Remote != nil {
		body["remote"] = updateSecurityGroupRuleOptions.Remote
	}
	if updateSecurityGroupRuleOptions.Type != nil {
		body["type"] = updateSecurityGroupRuleOptions.Type
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalSecurityGroupRule(m)
		response.Result = result
	}

	return
}

// ListSubnets : List all subnets
// This request lists all subnets in the region. Subnets are contiguous ranges of IP addresses specified in CIDR block
// notation. Each subnet is within a particular zone and cannot span multiple zones or regions.
func (vpc *VpcV1) ListSubnets(listSubnetsOptions *ListSubnetsOptions) (result *SubnetCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listSubnetsOptions, "listSubnetsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSubnetsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListSubnets")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listSubnetsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listSubnetsOptions.Start))
	}
	if listSubnetsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSubnetsOptions.Limit))
	}
	if listSubnetsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listSubnetsOptions.ResourceGroupID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalSubnetCollection(m)
		response.Result = result
	}

	return
}

// CreateSubnet : Create a subnet
// This request creates a new subnet from a subnet prototype object. The prototype object is structured in the same way
// as a retrieved subnet, and contains the information necessary to create the new subnet. For this request to succeed,
// the prototype's CIDR block must not overlap with an existing subnet in the VPC.
func (vpc *VpcV1) CreateSubnet(createSubnetOptions *CreateSubnetOptions) (result *Subnet, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSubnetOptions, "createSubnetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSubnetOptions, "createSubnetOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSubnetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateSubnet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createSubnetOptions.SubnetPrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalSubnet(m)
		response.Result = result
	}

	return
}

// DeleteSubnet : Delete specified subnet
// This request deletes a subnet. This operation cannot be reversed. For this request to succeed, the subnet must not be
// referenced by any network interfaces, VPN gateways, or load balancers. A delete operation automatically detaches the
// subnet from any network ACLs and public gateways.
func (vpc *VpcV1) DeleteSubnet(deleteSubnetOptions *DeleteSubnetOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSubnetOptions, "deleteSubnetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSubnetOptions, "deleteSubnetOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets"}
	pathParameters := []string{*deleteSubnetOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSubnetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteSubnet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetSubnet : Retrieve specified subnet
// This request retrieves a single subnet specified by the identifier in the URL.
func (vpc *VpcV1) GetSubnet(getSubnetOptions *GetSubnetOptions) (result *Subnet, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSubnetOptions, "getSubnetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSubnetOptions, "getSubnetOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets"}
	pathParameters := []string{*getSubnetOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSubnetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSubnet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalSubnet(m)
		response.Result = result
	}

	return
}

// UpdateSubnet : Update specified subnet
// This request updates a subnet with the information in a provided subnet patch. The subnet patch object is structured
// in the same way as a retrieved subnet and contains only the information to be updated.
func (vpc *VpcV1) UpdateSubnet(updateSubnetOptions *UpdateSubnetOptions) (result *Subnet, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSubnetOptions, "updateSubnetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSubnetOptions, "updateSubnetOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets"}
	pathParameters := []string{*updateSubnetOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSubnetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateSubnet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateSubnetOptions.Name != nil {
		body["name"] = updateSubnetOptions.Name
	}
	if updateSubnetOptions.NetworkAcl != nil {
		body["network_acl"] = updateSubnetOptions.NetworkAcl
	}
	if updateSubnetOptions.PublicGateway != nil {
		body["public_gateway"] = updateSubnetOptions.PublicGateway
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalSubnet(m)
		response.Result = result
	}

	return
}

// GetSubnetNetworkAcl : Retrieve a subnet's attached network ACL
// This request retrieves the network ACL attached to the subnet specified by the identifier in the URL.
func (vpc *VpcV1) GetSubnetNetworkAcl(getSubnetNetworkAclOptions *GetSubnetNetworkAclOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSubnetNetworkAclOptions, "getSubnetNetworkAclOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSubnetNetworkAclOptions, "getSubnetNetworkAclOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets", "network_acl"}
	pathParameters := []string{*getSubnetNetworkAclOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSubnetNetworkAclOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSubnetNetworkAcl")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalNetworkACL(m)
		response.Result = result
	}

	return
}

// SetSubnetNetworkAclBinding : Attach a network ACL to a subnet
// This request attaches the network ACL, specified in the request body, to the subnet specified by the subnet
// identifier in the URL. This replaces the existing network ACL on the subnet.
func (vpc *VpcV1) SetSubnetNetworkAclBinding(setSubnetNetworkAclBindingOptions *SetSubnetNetworkAclBindingOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(setSubnetNetworkAclBindingOptions, "setSubnetNetworkAclBindingOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(setSubnetNetworkAclBindingOptions, "setSubnetNetworkAclBindingOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets", "network_acl"}
	pathParameters := []string{*setSubnetNetworkAclBindingOptions.ID}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range setSubnetNetworkAclBindingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "SetSubnetNetworkAclBinding")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(setSubnetNetworkAclBindingOptions.NetworkACLIdentity)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalNetworkACL(m)
		response.Result = result
	}

	return
}

// DeleteSubnetPublicGatewayBinding : Detach a public gateway from a subnet
// This request detaches the public gateway from the subnet specified by the subnet identifier in the URL.
func (vpc *VpcV1) DeleteSubnetPublicGatewayBinding(deleteSubnetPublicGatewayBindingOptions *DeleteSubnetPublicGatewayBindingOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSubnetPublicGatewayBindingOptions, "deleteSubnetPublicGatewayBindingOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSubnetPublicGatewayBindingOptions, "deleteSubnetPublicGatewayBindingOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets", "public_gateway"}
	pathParameters := []string{*deleteSubnetPublicGatewayBindingOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSubnetPublicGatewayBindingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteSubnetPublicGatewayBinding")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetSubnetPublicGateway : Retrieve a subnet's attached public gateway
// This request retrieves the public gateway attached to the subnet specified by the identifier in the URL.
func (vpc *VpcV1) GetSubnetPublicGateway(getSubnetPublicGatewayOptions *GetSubnetPublicGatewayOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSubnetPublicGatewayOptions, "getSubnetPublicGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSubnetPublicGatewayOptions, "getSubnetPublicGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets", "public_gateway"}
	pathParameters := []string{*getSubnetPublicGatewayOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSubnetPublicGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSubnetPublicGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalPublicGateway(m)
		response.Result = result
	}

	return
}

// SetSubnetPublicGatewayBinding : Attach a public gateway to a subnet
// This request attaches the public gateway, specified in the request body, to the subnet specified by the subnet
// identifier in the URL. The public gateway must have the same VPC and zone as the subnet.
func (vpc *VpcV1) SetSubnetPublicGatewayBinding(setSubnetPublicGatewayBindingOptions *SetSubnetPublicGatewayBindingOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(setSubnetPublicGatewayBindingOptions, "setSubnetPublicGatewayBindingOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(setSubnetPublicGatewayBindingOptions, "setSubnetPublicGatewayBindingOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets", "public_gateway"}
	pathParameters := []string{*setSubnetPublicGatewayBindingOptions.ID}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range setSubnetPublicGatewayBindingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "SetSubnetPublicGatewayBinding")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(setSubnetPublicGatewayBindingOptions.PublicGatewayIdentity)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalPublicGateway(m)
		response.Result = result
	}

	return
}

// ListVpcs : List all VPCs
// This request lists all VPCs. A VPC is a virtual network that belongs to an account and provides logical isolation
// from other networks. A VPC is made up of resources in one or more zones. VPCs are regional, and each VPC can contain
// resources in multiple zones in a region.
func (vpc *VpcV1) ListVpcs(listVpcsOptions *ListVpcsOptions) (result *VPCCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listVpcsOptions, "listVpcsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVpcsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVpcs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVpcsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVpcsOptions.Start))
	}
	if listVpcsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVpcsOptions.Limit))
	}
	if listVpcsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listVpcsOptions.ResourceGroupID))
	}
	if listVpcsOptions.ClassicAccess != nil {
		builder.AddQuery("classic_access", fmt.Sprint(*listVpcsOptions.ClassicAccess))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVPCCollection(m)
		response.Result = result
	}

	return
}

// CreateVpc : Create a VPC
// This request creates a new VPC from a VPC prototype object. The prototype object is structured in the same way as a
// retrieved VPC, and contains the information necessary to create the new VPC.
func (vpc *VpcV1) CreateVpc(createVpcOptions *CreateVpcOptions) (result *VPC, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(createVpcOptions, "createVpcOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVpcOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVpc")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVpcOptions.AddressPrefixManagement != nil {
		body["address_prefix_management"] = createVpcOptions.AddressPrefixManagement
	}
	if createVpcOptions.ClassicAccess != nil {
		body["classic_access"] = createVpcOptions.ClassicAccess
	}
	if createVpcOptions.Name != nil {
		body["name"] = createVpcOptions.Name
	}
	if createVpcOptions.ResourceGroup != nil {
		body["resource_group"] = createVpcOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVPC(m)
		response.Result = result
	}

	return
}

// DeleteVpc : Delete specified VPC
// This request deletes a VPC. This operation cannot be reversed. For this request to succeed, the VPC must not contain
// any instances, subnets, or public gateways. All security groups and network ACLs associated with the VPC are
// automatically deleted.
func (vpc *VpcV1) DeleteVpc(deleteVpcOptions *DeleteVpcOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVpcOptions, "deleteVpcOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVpcOptions, "deleteVpcOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs"}
	pathParameters := []string{*deleteVpcOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVpcOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVpc")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVpc : Retrieve specified VPC
// This request retrieves a single VPC specified by the identifier in the URL.
func (vpc *VpcV1) GetVpc(getVpcOptions *GetVpcOptions) (result *VPC, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVpcOptions, "getVpcOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVpcOptions, "getVpcOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs"}
	pathParameters := []string{*getVpcOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVpcOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVpc")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVPC(m)
		response.Result = result
	}

	return
}

// UpdateVpc : Update specified VPC
// This request updates a VPC's name.
func (vpc *VpcV1) UpdateVpc(updateVpcOptions *UpdateVpcOptions) (result *VPC, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVpcOptions, "updateVpcOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVpcOptions, "updateVpcOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs"}
	pathParameters := []string{*updateVpcOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVpcOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVpc")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateVpcOptions.Name != nil {
		body["name"] = updateVpcOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVPC(m)
		response.Result = result
	}

	return
}

// GetVpcDefaultNetworkAcl : Retrieve a VPC's default network ACL
// This request retrieves the default network ACL for the VPC specified by the identifier in the URL. The default
// network ACL is applied to any new subnets in the VPC which do not specify a network ACL.
func (vpc *VpcV1) GetVpcDefaultNetworkAcl(getVpcDefaultNetworkAclOptions *GetVpcDefaultNetworkAclOptions) (result *DefaultNetworkACL, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVpcDefaultNetworkAclOptions, "getVpcDefaultNetworkAclOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVpcDefaultNetworkAclOptions, "getVpcDefaultNetworkAclOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "default_network_acl"}
	pathParameters := []string{*getVpcDefaultNetworkAclOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVpcDefaultNetworkAclOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVpcDefaultNetworkAcl")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalDefaultNetworkACL(m)
		response.Result = result
	}

	return
}

// GetVpcDefaultSecurityGroup : Retrieve a VPC's default security group
// This request retrieves the default security group for the VPC specified by the identifier in the URL. The default
// security group is applied to any new network interfaces in the VPC that do not specify a security group.
func (vpc *VpcV1) GetVpcDefaultSecurityGroup(getVpcDefaultSecurityGroupOptions *GetVpcDefaultSecurityGroupOptions) (result *DefaultSecurityGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVpcDefaultSecurityGroupOptions, "getVpcDefaultSecurityGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVpcDefaultSecurityGroupOptions, "getVpcDefaultSecurityGroupOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "default_security_group"}
	pathParameters := []string{*getVpcDefaultSecurityGroupOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVpcDefaultSecurityGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVpcDefaultSecurityGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalDefaultSecurityGroup(m)
		response.Result = result
	}

	return
}

// ListVpcAddressPrefixes : List all address pool prefixes for a VPC
// This request lists all address pool prefixes for a VPC.
func (vpc *VpcV1) ListVpcAddressPrefixes(listVpcAddressPrefixesOptions *ListVpcAddressPrefixesOptions) (result *AddressPrefixCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVpcAddressPrefixesOptions, "listVpcAddressPrefixesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVpcAddressPrefixesOptions, "listVpcAddressPrefixesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "address_prefixes"}
	pathParameters := []string{*listVpcAddressPrefixesOptions.VpcID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVpcAddressPrefixesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVpcAddressPrefixes")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalAddressPrefixCollection(m)
		response.Result = result
	}

	return
}

// CreateVpcAddressPrefix : Create an address pool prefix
// This request creates a new prefix from a prefix prototype object. The prototype object is structured in the same way
// as a retrieved prefix, and contains the information necessary to create the new prefix.
func (vpc *VpcV1) CreateVpcAddressPrefix(createVpcAddressPrefixOptions *CreateVpcAddressPrefixOptions) (result *AddressPrefix, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVpcAddressPrefixOptions, "createVpcAddressPrefixOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVpcAddressPrefixOptions, "createVpcAddressPrefixOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "address_prefixes"}
	pathParameters := []string{*createVpcAddressPrefixOptions.VpcID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVpcAddressPrefixOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVpcAddressPrefix")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVpcAddressPrefixOptions.Cidr != nil {
		body["cidr"] = createVpcAddressPrefixOptions.Cidr
	}
	if createVpcAddressPrefixOptions.Zone != nil {
		body["zone"] = createVpcAddressPrefixOptions.Zone
	}
	if createVpcAddressPrefixOptions.IsDefault != nil {
		body["is_default"] = createVpcAddressPrefixOptions.IsDefault
	}
	if createVpcAddressPrefixOptions.Name != nil {
		body["name"] = createVpcAddressPrefixOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalAddressPrefix(m)
		response.Result = result
	}

	return
}

// DeleteVpcAddressPrefix : Delete specified address pool prefix
// This request deletes a prefix. This operation cannot be reversed. The request will fail if any subnets use addresses
// from this prefix.
func (vpc *VpcV1) DeleteVpcAddressPrefix(deleteVpcAddressPrefixOptions *DeleteVpcAddressPrefixOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVpcAddressPrefixOptions, "deleteVpcAddressPrefixOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVpcAddressPrefixOptions, "deleteVpcAddressPrefixOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "address_prefixes"}
	pathParameters := []string{*deleteVpcAddressPrefixOptions.VpcID, *deleteVpcAddressPrefixOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVpcAddressPrefixOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVpcAddressPrefix")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVpcAddressPrefix : Retrieve specified address pool prefix
// This request retrieves a single prefix specified by the identifier in the URL.
func (vpc *VpcV1) GetVpcAddressPrefix(getVpcAddressPrefixOptions *GetVpcAddressPrefixOptions) (result *AddressPrefix, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVpcAddressPrefixOptions, "getVpcAddressPrefixOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVpcAddressPrefixOptions, "getVpcAddressPrefixOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "address_prefixes"}
	pathParameters := []string{*getVpcAddressPrefixOptions.VpcID, *getVpcAddressPrefixOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVpcAddressPrefixOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVpcAddressPrefix")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalAddressPrefix(m)
		response.Result = result
	}

	return
}

// UpdateVpcAddressPrefix : Update an address pool prefix
// This request updates a prefix with the information in a provided prefix patch. The prefix patch object is structured
// in the same way as a retrieved prefix and contains only the information to be updated.
func (vpc *VpcV1) UpdateVpcAddressPrefix(updateVpcAddressPrefixOptions *UpdateVpcAddressPrefixOptions) (result *AddressPrefix, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVpcAddressPrefixOptions, "updateVpcAddressPrefixOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVpcAddressPrefixOptions, "updateVpcAddressPrefixOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "address_prefixes"}
	pathParameters := []string{*updateVpcAddressPrefixOptions.VpcID, *updateVpcAddressPrefixOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVpcAddressPrefixOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVpcAddressPrefix")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateVpcAddressPrefixOptions.IsDefault != nil {
		body["is_default"] = updateVpcAddressPrefixOptions.IsDefault
	}
	if updateVpcAddressPrefixOptions.Name != nil {
		body["name"] = updateVpcAddressPrefixOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalAddressPrefix(m)
		response.Result = result
	}

	return
}

// ListVpcRoutes : List all routes in the VPC's default routing table
// This request retrieves routes in the VPC's default routing table. For compatibility, routes with `action` values
// other than `deliver` are omitted. Each route is zone-specific and directs any packets matching its destination CIDR
// block to a `next_hop` IP address. The most specific route matching a packet's destination will be used. If multiple
// equally-specific routes exist, traffic will be distributed across them.
func (vpc *VpcV1) ListVpcRoutes(listVpcRoutesOptions *ListVpcRoutesOptions) (result *RouteCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVpcRoutesOptions, "listVpcRoutesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVpcRoutesOptions, "listVpcRoutesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routes"}
	pathParameters := []string{*listVpcRoutesOptions.VpcID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVpcRoutesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVpcRoutes")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVpcRoutesOptions.ZoneName != nil {
		builder.AddQuery("zone.name", fmt.Sprint(*listVpcRoutesOptions.ZoneName))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalRouteCollection(m)
		response.Result = result
	}

	return
}

// CreateVpcRoute : Create a route in the VPC's default routing table
// This request creates a new route in the VPC's default routing table. The route prototype object is structured in the
// same way as a retrieved route, and contains the information necessary to create the new route. The request will fail
// if the new route will cause a loop.
func (vpc *VpcV1) CreateVpcRoute(createVpcRouteOptions *CreateVpcRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVpcRouteOptions, "createVpcRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVpcRouteOptions, "createVpcRouteOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routes"}
	pathParameters := []string{*createVpcRouteOptions.VpcID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVpcRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVpcRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVpcRouteOptions.Destination != nil {
		body["destination"] = createVpcRouteOptions.Destination
	}
	if createVpcRouteOptions.Zone != nil {
		body["zone"] = createVpcRouteOptions.Zone
	}
	if createVpcRouteOptions.Name != nil {
		body["name"] = createVpcRouteOptions.Name
	}
	if createVpcRouteOptions.NextHop != nil {
		body["next_hop"] = createVpcRouteOptions.NextHop
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalRoute(m)
		response.Result = result
	}

	return
}

// DeleteVpcRoute : Delete the specified route in the VPC's default routing table
// This request deletes a route. This operation cannot be reversed.
func (vpc *VpcV1) DeleteVpcRoute(deleteVpcRouteOptions *DeleteVpcRouteOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVpcRouteOptions, "deleteVpcRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVpcRouteOptions, "deleteVpcRouteOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routes"}
	pathParameters := []string{*deleteVpcRouteOptions.VpcID, *deleteVpcRouteOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVpcRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVpcRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVpcRoute : Retrieve the specified route in the VPC's default routing table
// This request retrieves a single route specified by the identifier in the URL.
func (vpc *VpcV1) GetVpcRoute(getVpcRouteOptions *GetVpcRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVpcRouteOptions, "getVpcRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVpcRouteOptions, "getVpcRouteOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routes"}
	pathParameters := []string{*getVpcRouteOptions.VpcID, *getVpcRouteOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVpcRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVpcRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalRoute(m)
		response.Result = result
	}

	return
}

// UpdateVpcRoute : Update the specified route in the VPC's default routing table
// This request updates a route with the information in a provided route patch. The route patch object is structured in
// the same way as a retrieved route and contains only the information to be updated.
func (vpc *VpcV1) UpdateVpcRoute(updateVpcRouteOptions *UpdateVpcRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVpcRouteOptions, "updateVpcRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVpcRouteOptions, "updateVpcRouteOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routes"}
	pathParameters := []string{*updateVpcRouteOptions.VpcID, *updateVpcRouteOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVpcRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVpcRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateVpcRouteOptions.Name != nil {
		body["name"] = updateVpcRouteOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalRoute(m)
		response.Result = result
	}

	return
}

// ListIkePolicies : List all IKE policies
// This request retrieves a paginated list of all IKE policies that belong to this account.
func (vpc *VpcV1) ListIkePolicies(listIkePoliciesOptions *ListIkePoliciesOptions) (result *IKEPolicyCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listIkePoliciesOptions, "listIkePoliciesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ike_policies"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listIkePoliciesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListIkePolicies")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listIkePoliciesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listIkePoliciesOptions.Start))
	}
	if listIkePoliciesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listIkePoliciesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalIKEPolicyCollection(m)
		response.Result = result
	}

	return
}

// CreateIkePolicy : Create an IKE policy
// This request creates a new IKE policy.
func (vpc *VpcV1) CreateIkePolicy(createIkePolicyOptions *CreateIkePolicyOptions) (result *IKEPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createIkePolicyOptions, "createIkePolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createIkePolicyOptions, "createIkePolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ike_policies"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createIkePolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateIkePolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createIkePolicyOptions.AuthenticationAlgorithm != nil {
		body["authentication_algorithm"] = createIkePolicyOptions.AuthenticationAlgorithm
	}
	if createIkePolicyOptions.DhGroup != nil {
		body["dh_group"] = createIkePolicyOptions.DhGroup
	}
	if createIkePolicyOptions.EncryptionAlgorithm != nil {
		body["encryption_algorithm"] = createIkePolicyOptions.EncryptionAlgorithm
	}
	if createIkePolicyOptions.IkeVersion != nil {
		body["ike_version"] = createIkePolicyOptions.IkeVersion
	}
	if createIkePolicyOptions.KeyLifetime != nil {
		body["key_lifetime"] = createIkePolicyOptions.KeyLifetime
	}
	if createIkePolicyOptions.Name != nil {
		body["name"] = createIkePolicyOptions.Name
	}
	if createIkePolicyOptions.ResourceGroup != nil {
		body["resource_group"] = createIkePolicyOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalIKEPolicy(m)
		response.Result = result
	}

	return
}

// DeleteIkePolicy : Delete an IKE policy
// This request deletes an IKE policy. This operation cannot be reversed.
func (vpc *VpcV1) DeleteIkePolicy(deleteIkePolicyOptions *DeleteIkePolicyOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteIkePolicyOptions, "deleteIkePolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteIkePolicyOptions, "deleteIkePolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ike_policies"}
	pathParameters := []string{*deleteIkePolicyOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteIkePolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteIkePolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetIkePolicy : Retrieve the specified IKE policy
// This request retrieves a single IKE policy specified by the identifier in the URL.
func (vpc *VpcV1) GetIkePolicy(getIkePolicyOptions *GetIkePolicyOptions) (result *IKEPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getIkePolicyOptions, "getIkePolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getIkePolicyOptions, "getIkePolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ike_policies"}
	pathParameters := []string{*getIkePolicyOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getIkePolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetIkePolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalIKEPolicy(m)
		response.Result = result
	}

	return
}

// UpdateIkePolicy : Update an IKE policy
// This request updates the properties of an existing IKE policy.
func (vpc *VpcV1) UpdateIkePolicy(updateIkePolicyOptions *UpdateIkePolicyOptions) (result *IKEPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateIkePolicyOptions, "updateIkePolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateIkePolicyOptions, "updateIkePolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ike_policies"}
	pathParameters := []string{*updateIkePolicyOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateIkePolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateIkePolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateIkePolicyOptions.AuthenticationAlgorithm != nil {
		body["authentication_algorithm"] = updateIkePolicyOptions.AuthenticationAlgorithm
	}
	if updateIkePolicyOptions.DhGroup != nil {
		body["dh_group"] = updateIkePolicyOptions.DhGroup
	}
	if updateIkePolicyOptions.EncryptionAlgorithm != nil {
		body["encryption_algorithm"] = updateIkePolicyOptions.EncryptionAlgorithm
	}
	if updateIkePolicyOptions.IkeVersion != nil {
		body["ike_version"] = updateIkePolicyOptions.IkeVersion
	}
	if updateIkePolicyOptions.KeyLifetime != nil {
		body["key_lifetime"] = updateIkePolicyOptions.KeyLifetime
	}
	if updateIkePolicyOptions.Name != nil {
		body["name"] = updateIkePolicyOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalIKEPolicy(m)
		response.Result = result
	}

	return
}

// ListVpnGatewayIkePolicyConnections : Lists all the connections that use the specified policy
// This request lists all the connections that use the specified policy.
func (vpc *VpcV1) ListVpnGatewayIkePolicyConnections(listVpnGatewayIkePolicyConnectionsOptions *ListVpnGatewayIkePolicyConnectionsOptions) (result *VPNGatewayConnectionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVpnGatewayIkePolicyConnectionsOptions, "listVpnGatewayIkePolicyConnectionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVpnGatewayIkePolicyConnectionsOptions, "listVpnGatewayIkePolicyConnectionsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ike_policies", "connections"}
	pathParameters := []string{*listVpnGatewayIkePolicyConnectionsOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVpnGatewayIkePolicyConnectionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVpnGatewayIkePolicyConnections")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVPNGatewayConnectionCollection(m)
		response.Result = result
	}

	return
}

// ListIpsecPolicies : List all IPsec policies
// This request retrieves a paginated list of all IPsec policies that belong to this account.
func (vpc *VpcV1) ListIpsecPolicies(listIpsecPoliciesOptions *ListIpsecPoliciesOptions) (result *IPsecPolicyCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listIpsecPoliciesOptions, "listIpsecPoliciesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ipsec_policies"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listIpsecPoliciesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListIpsecPolicies")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listIpsecPoliciesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listIpsecPoliciesOptions.Start))
	}
	if listIpsecPoliciesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listIpsecPoliciesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalIPsecPolicyCollection(m)
		response.Result = result
	}

	return
}

// CreateIpsecPolicy : Create an IPsec policy
// This request creates a new IPsec policy.
func (vpc *VpcV1) CreateIpsecPolicy(createIpsecPolicyOptions *CreateIpsecPolicyOptions) (result *IPsecPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createIpsecPolicyOptions, "createIpsecPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createIpsecPolicyOptions, "createIpsecPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ipsec_policies"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createIpsecPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateIpsecPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createIpsecPolicyOptions.AuthenticationAlgorithm != nil {
		body["authentication_algorithm"] = createIpsecPolicyOptions.AuthenticationAlgorithm
	}
	if createIpsecPolicyOptions.EncryptionAlgorithm != nil {
		body["encryption_algorithm"] = createIpsecPolicyOptions.EncryptionAlgorithm
	}
	if createIpsecPolicyOptions.Pfs != nil {
		body["pfs"] = createIpsecPolicyOptions.Pfs
	}
	if createIpsecPolicyOptions.KeyLifetime != nil {
		body["key_lifetime"] = createIpsecPolicyOptions.KeyLifetime
	}
	if createIpsecPolicyOptions.Name != nil {
		body["name"] = createIpsecPolicyOptions.Name
	}
	if createIpsecPolicyOptions.ResourceGroup != nil {
		body["resource_group"] = createIpsecPolicyOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalIPsecPolicy(m)
		response.Result = result
	}

	return
}

// DeleteIpsecPolicy : Delete an IPsec policy
// This request deletes an IPsec policy. This operation cannot be reversed.
func (vpc *VpcV1) DeleteIpsecPolicy(deleteIpsecPolicyOptions *DeleteIpsecPolicyOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteIpsecPolicyOptions, "deleteIpsecPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteIpsecPolicyOptions, "deleteIpsecPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ipsec_policies"}
	pathParameters := []string{*deleteIpsecPolicyOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteIpsecPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteIpsecPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetIpsecPolicy : Retrieve the specified IPsec policy
// This request retrieves a single IPsec policy specified by the identifier in the URL.
func (vpc *VpcV1) GetIpsecPolicy(getIpsecPolicyOptions *GetIpsecPolicyOptions) (result *IPsecPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getIpsecPolicyOptions, "getIpsecPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getIpsecPolicyOptions, "getIpsecPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ipsec_policies"}
	pathParameters := []string{*getIpsecPolicyOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getIpsecPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetIpsecPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalIPsecPolicy(m)
		response.Result = result
	}

	return
}

// UpdateIpsecPolicy : Update an IPsec policy
// This request updates the properties of an existing IPsec policy.
func (vpc *VpcV1) UpdateIpsecPolicy(updateIpsecPolicyOptions *UpdateIpsecPolicyOptions) (result *IPsecPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateIpsecPolicyOptions, "updateIpsecPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateIpsecPolicyOptions, "updateIpsecPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ipsec_policies"}
	pathParameters := []string{*updateIpsecPolicyOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateIpsecPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateIpsecPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateIpsecPolicyOptions.AuthenticationAlgorithm != nil {
		body["authentication_algorithm"] = updateIpsecPolicyOptions.AuthenticationAlgorithm
	}
	if updateIpsecPolicyOptions.EncryptionAlgorithm != nil {
		body["encryption_algorithm"] = updateIpsecPolicyOptions.EncryptionAlgorithm
	}
	if updateIpsecPolicyOptions.KeyLifetime != nil {
		body["key_lifetime"] = updateIpsecPolicyOptions.KeyLifetime
	}
	if updateIpsecPolicyOptions.Name != nil {
		body["name"] = updateIpsecPolicyOptions.Name
	}
	if updateIpsecPolicyOptions.Pfs != nil {
		body["pfs"] = updateIpsecPolicyOptions.Pfs
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalIPsecPolicy(m)
		response.Result = result
	}

	return
}

// ListVpnGatewayIpsecPolicyConnections : Lists all the connections that use the specified policy
// This request lists all the connections that use the specified policy.
func (vpc *VpcV1) ListVpnGatewayIpsecPolicyConnections(listVpnGatewayIpsecPolicyConnectionsOptions *ListVpnGatewayIpsecPolicyConnectionsOptions) (result *VPNGatewayConnectionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVpnGatewayIpsecPolicyConnectionsOptions, "listVpnGatewayIpsecPolicyConnectionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVpnGatewayIpsecPolicyConnectionsOptions, "listVpnGatewayIpsecPolicyConnectionsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ipsec_policies", "connections"}
	pathParameters := []string{*listVpnGatewayIpsecPolicyConnectionsOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVpnGatewayIpsecPolicyConnectionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVpnGatewayIpsecPolicyConnections")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVPNGatewayConnectionCollection(m)
		response.Result = result
	}

	return
}

// ListVpnGateways : List all VPN gateways
// This request retrieves a paginated list of all VPN gateways that belong to this account.
func (vpc *VpcV1) ListVpnGateways(listVpnGatewaysOptions *ListVpnGatewaysOptions) (result *VPNGatewayCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listVpnGatewaysOptions, "listVpnGatewaysOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVpnGatewaysOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVpnGateways")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVpnGatewaysOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVpnGatewaysOptions.Start))
	}
	if listVpnGatewaysOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVpnGatewaysOptions.Limit))
	}
	if listVpnGatewaysOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listVpnGatewaysOptions.ResourceGroupID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVPNGatewayCollection(m)
		response.Result = result
	}

	return
}

// CreateVpnGateway : Create a VPN gateway
// This request creates a new VPN gateway.
func (vpc *VpcV1) CreateVpnGateway(createVpnGatewayOptions *CreateVpnGatewayOptions) (result *VPNGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVpnGatewayOptions, "createVpnGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVpnGatewayOptions, "createVpnGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVpnGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVpnGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVpnGatewayOptions.Subnet != nil {
		body["subnet"] = createVpnGatewayOptions.Subnet
	}
	if createVpnGatewayOptions.Name != nil {
		body["name"] = createVpnGatewayOptions.Name
	}
	if createVpnGatewayOptions.ResourceGroup != nil {
		body["resource_group"] = createVpnGatewayOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVPNGateway(m)
		response.Result = result
	}

	return
}

// DeleteVpnGateway : Delete a VPN gateway
// This request deletes a VPN gateway. A VPN gateway with a `status` of `pending` cannot be deleted. This operation
// deletes all VPN connections associated with this VPN gateway.  This operation cannot be reversed.
func (vpc *VpcV1) DeleteVpnGateway(deleteVpnGatewayOptions *DeleteVpnGatewayOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVpnGatewayOptions, "deleteVpnGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVpnGatewayOptions, "deleteVpnGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways"}
	pathParameters := []string{*deleteVpnGatewayOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVpnGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVpnGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVpnGateway : Retrieve the specified VPN gateway
// This request retrieves a single VPN gateway specified by the identifier in the URL.
func (vpc *VpcV1) GetVpnGateway(getVpnGatewayOptions *GetVpnGatewayOptions) (result *VPNGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVpnGatewayOptions, "getVpnGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVpnGatewayOptions, "getVpnGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways"}
	pathParameters := []string{*getVpnGatewayOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVpnGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVpnGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVPNGateway(m)
		response.Result = result
	}

	return
}

// UpdateVpnGateway : Update a VPN gateway
// This request updates the properties of an existing VPN gateway.
func (vpc *VpcV1) UpdateVpnGateway(updateVpnGatewayOptions *UpdateVpnGatewayOptions) (result *VPNGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVpnGatewayOptions, "updateVpnGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVpnGatewayOptions, "updateVpnGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways"}
	pathParameters := []string{*updateVpnGatewayOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVpnGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVpnGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateVpnGatewayOptions.Name != nil {
		body["name"] = updateVpnGatewayOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVPNGateway(m)
		response.Result = result
	}

	return
}

// ListVpnGatewayConnections : List all the connections of a VPN gateway
// This request lists all the connections of a particular VPN gateway.
func (vpc *VpcV1) ListVpnGatewayConnections(listVpnGatewayConnectionsOptions *ListVpnGatewayConnectionsOptions) (result *VPNGatewayConnectionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVpnGatewayConnectionsOptions, "listVpnGatewayConnectionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVpnGatewayConnectionsOptions, "listVpnGatewayConnectionsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections"}
	pathParameters := []string{*listVpnGatewayConnectionsOptions.VpnGatewayID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVpnGatewayConnectionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVpnGatewayConnections")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVpnGatewayConnectionsOptions.Status != nil {
		builder.AddQuery("status", fmt.Sprint(*listVpnGatewayConnectionsOptions.Status))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVPNGatewayConnectionCollection(m)
		response.Result = result
	}

	return
}

// CreateVpnGatewayConnection : Create a VPN connection
// This request creates a new VPN connection.
func (vpc *VpcV1) CreateVpnGatewayConnection(createVpnGatewayConnectionOptions *CreateVpnGatewayConnectionOptions) (result *VPNGatewayConnection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVpnGatewayConnectionOptions, "createVpnGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVpnGatewayConnectionOptions, "createVpnGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections"}
	pathParameters := []string{*createVpnGatewayConnectionOptions.VpnGatewayID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVpnGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVpnGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVpnGatewayConnectionOptions.PeerAddress != nil {
		body["peer_address"] = createVpnGatewayConnectionOptions.PeerAddress
	}
	if createVpnGatewayConnectionOptions.Psk != nil {
		body["psk"] = createVpnGatewayConnectionOptions.Psk
	}
	if createVpnGatewayConnectionOptions.AdminStateUp != nil {
		body["admin_state_up"] = createVpnGatewayConnectionOptions.AdminStateUp
	}
	if createVpnGatewayConnectionOptions.DeadPeerDetection != nil {
		body["dead_peer_detection"] = createVpnGatewayConnectionOptions.DeadPeerDetection
	}
	if createVpnGatewayConnectionOptions.IkePolicy != nil {
		body["ike_policy"] = createVpnGatewayConnectionOptions.IkePolicy
	}
	if createVpnGatewayConnectionOptions.IpsecPolicy != nil {
		body["ipsec_policy"] = createVpnGatewayConnectionOptions.IpsecPolicy
	}
	if createVpnGatewayConnectionOptions.LocalCidrs != nil {
		body["local_cidrs"] = createVpnGatewayConnectionOptions.LocalCidrs
	}
	if createVpnGatewayConnectionOptions.Name != nil {
		body["name"] = createVpnGatewayConnectionOptions.Name
	}
	if createVpnGatewayConnectionOptions.PeerCidrs != nil {
		body["peer_cidrs"] = createVpnGatewayConnectionOptions.PeerCidrs
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVPNGatewayConnection(m)
		response.Result = result
	}

	return
}

// DeleteVpnGatewayConnection : Delete a VPN connection
// This request deletes a VPN connection. This operation cannot be reversed.
func (vpc *VpcV1) DeleteVpnGatewayConnection(deleteVpnGatewayConnectionOptions *DeleteVpnGatewayConnectionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVpnGatewayConnectionOptions, "deleteVpnGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVpnGatewayConnectionOptions, "deleteVpnGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections"}
	pathParameters := []string{*deleteVpnGatewayConnectionOptions.VpnGatewayID, *deleteVpnGatewayConnectionOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVpnGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVpnGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVpnGatewayConnection : Retrieve the specified VPN connection
// This request retrieves a single VPN connection specified by the identifier in the URL.
func (vpc *VpcV1) GetVpnGatewayConnection(getVpnGatewayConnectionOptions *GetVpnGatewayConnectionOptions) (result *VPNGatewayConnection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVpnGatewayConnectionOptions, "getVpnGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVpnGatewayConnectionOptions, "getVpnGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections"}
	pathParameters := []string{*getVpnGatewayConnectionOptions.VpnGatewayID, *getVpnGatewayConnectionOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVpnGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVpnGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVPNGatewayConnection(m)
		response.Result = result
	}

	return
}

// UpdateVpnGatewayConnection : Update a VPN connection
// This request updates the properties of an existing VPN connection.
func (vpc *VpcV1) UpdateVpnGatewayConnection(updateVpnGatewayConnectionOptions *UpdateVpnGatewayConnectionOptions) (result *VPNGatewayConnection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVpnGatewayConnectionOptions, "updateVpnGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVpnGatewayConnectionOptions, "updateVpnGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections"}
	pathParameters := []string{*updateVpnGatewayConnectionOptions.VpnGatewayID, *updateVpnGatewayConnectionOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVpnGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVpnGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateVpnGatewayConnectionOptions.AdminStateUp != nil {
		body["admin_state_up"] = updateVpnGatewayConnectionOptions.AdminStateUp
	}
	if updateVpnGatewayConnectionOptions.DeadPeerDetection != nil {
		body["dead_peer_detection"] = updateVpnGatewayConnectionOptions.DeadPeerDetection
	}
	if updateVpnGatewayConnectionOptions.IkePolicy != nil {
		body["ike_policy"] = updateVpnGatewayConnectionOptions.IkePolicy
	}
	if updateVpnGatewayConnectionOptions.IpsecPolicy != nil {
		body["ipsec_policy"] = updateVpnGatewayConnectionOptions.IpsecPolicy
	}
	if updateVpnGatewayConnectionOptions.Name != nil {
		body["name"] = updateVpnGatewayConnectionOptions.Name
	}
	if updateVpnGatewayConnectionOptions.PeerAddress != nil {
		body["peer_address"] = updateVpnGatewayConnectionOptions.PeerAddress
	}
	if updateVpnGatewayConnectionOptions.Psk != nil {
		body["psk"] = updateVpnGatewayConnectionOptions.Psk
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVPNGatewayConnection(m)
		response.Result = result
	}

	return
}

// ListVpnGatewayConnectionLocalCidrs : List all local CIDRs for a resource
// This request lists all local CIDRs for the resource specified by the identifier in the URL.
func (vpc *VpcV1) ListVpnGatewayConnectionLocalCidrs(listVpnGatewayConnectionLocalCidrsOptions *ListVpnGatewayConnectionLocalCidrsOptions) (result *VPNGatewayConnectionLocalCIDRs, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVpnGatewayConnectionLocalCidrsOptions, "listVpnGatewayConnectionLocalCidrsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVpnGatewayConnectionLocalCidrsOptions, "listVpnGatewayConnectionLocalCidrsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections", "local_cidrs"}
	pathParameters := []string{*listVpnGatewayConnectionLocalCidrsOptions.VpnGatewayID, *listVpnGatewayConnectionLocalCidrsOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVpnGatewayConnectionLocalCidrsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVpnGatewayConnectionLocalCidrs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVPNGatewayConnectionLocalCIDRs(m)
		response.Result = result
	}

	return
}

// DeleteVpnGatewayConnectionLocalCidr : Remove a CIDR from a resource
// This request removes a CIDR from a resource.
func (vpc *VpcV1) DeleteVpnGatewayConnectionLocalCidr(deleteVpnGatewayConnectionLocalCidrOptions *DeleteVpnGatewayConnectionLocalCidrOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVpnGatewayConnectionLocalCidrOptions, "deleteVpnGatewayConnectionLocalCidrOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVpnGatewayConnectionLocalCidrOptions, "deleteVpnGatewayConnectionLocalCidrOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections", "local_cidrs", ""}
	pathParameters := []string{*deleteVpnGatewayConnectionLocalCidrOptions.VpnGatewayID, *deleteVpnGatewayConnectionLocalCidrOptions.ID, *deleteVpnGatewayConnectionLocalCidrOptions.PrefixAddress, *deleteVpnGatewayConnectionLocalCidrOptions.PrefixLength}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVpnGatewayConnectionLocalCidrOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVpnGatewayConnectionLocalCidr")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVpnGatewayConnectionLocalCidr : Check if a specific CIDR exists on a specific resource
// This request succeeds if a CIDR exists on the resource and fails otherwise.
func (vpc *VpcV1) GetVpnGatewayConnectionLocalCidr(getVpnGatewayConnectionLocalCidrOptions *GetVpnGatewayConnectionLocalCidrOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVpnGatewayConnectionLocalCidrOptions, "getVpnGatewayConnectionLocalCidrOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVpnGatewayConnectionLocalCidrOptions, "getVpnGatewayConnectionLocalCidrOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections", "local_cidrs", ""}
	pathParameters := []string{*getVpnGatewayConnectionLocalCidrOptions.VpnGatewayID, *getVpnGatewayConnectionLocalCidrOptions.ID, *getVpnGatewayConnectionLocalCidrOptions.PrefixAddress, *getVpnGatewayConnectionLocalCidrOptions.PrefixLength}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVpnGatewayConnectionLocalCidrOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVpnGatewayConnectionLocalCidr")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// SetVpnGatewayConnectionLocalCidr : Set a CIDR on a resource
// This request adds the specified CIDR to the specified resource. A request body is not required, and if supplied, is
// ignored. This request succeeds if the CIDR already exists on the resource.
func (vpc *VpcV1) SetVpnGatewayConnectionLocalCidr(setVpnGatewayConnectionLocalCidrOptions *SetVpnGatewayConnectionLocalCidrOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(setVpnGatewayConnectionLocalCidrOptions, "setVpnGatewayConnectionLocalCidrOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(setVpnGatewayConnectionLocalCidrOptions, "setVpnGatewayConnectionLocalCidrOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections", "local_cidrs", ""}
	pathParameters := []string{*setVpnGatewayConnectionLocalCidrOptions.VpnGatewayID, *setVpnGatewayConnectionLocalCidrOptions.ID, *setVpnGatewayConnectionLocalCidrOptions.PrefixAddress, *setVpnGatewayConnectionLocalCidrOptions.PrefixLength}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range setVpnGatewayConnectionLocalCidrOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "SetVpnGatewayConnectionLocalCidr")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// ListVpnGatewayConnectionPeerCidrs : List all peer CIDRs for a resource
// This request lists all peer CIDRs for the resource specified by the identifier in the URL.
func (vpc *VpcV1) ListVpnGatewayConnectionPeerCidrs(listVpnGatewayConnectionPeerCidrsOptions *ListVpnGatewayConnectionPeerCidrsOptions) (result *VPNGatewayConnectionPeerCIDRs, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVpnGatewayConnectionPeerCidrsOptions, "listVpnGatewayConnectionPeerCidrsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVpnGatewayConnectionPeerCidrsOptions, "listVpnGatewayConnectionPeerCidrsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections", "peer_cidrs"}
	pathParameters := []string{*listVpnGatewayConnectionPeerCidrsOptions.VpnGatewayID, *listVpnGatewayConnectionPeerCidrsOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVpnGatewayConnectionPeerCidrsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVpnGatewayConnectionPeerCidrs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVPNGatewayConnectionPeerCIDRs(m)
		response.Result = result
	}

	return
}

// DeleteVpnGatewayConnectionPeerCidr : Remove a CIDR from a resource
// This request removes a CIDR from a resource.
func (vpc *VpcV1) DeleteVpnGatewayConnectionPeerCidr(deleteVpnGatewayConnectionPeerCidrOptions *DeleteVpnGatewayConnectionPeerCidrOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVpnGatewayConnectionPeerCidrOptions, "deleteVpnGatewayConnectionPeerCidrOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVpnGatewayConnectionPeerCidrOptions, "deleteVpnGatewayConnectionPeerCidrOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections", "peer_cidrs", ""}
	pathParameters := []string{*deleteVpnGatewayConnectionPeerCidrOptions.VpnGatewayID, *deleteVpnGatewayConnectionPeerCidrOptions.ID, *deleteVpnGatewayConnectionPeerCidrOptions.PrefixAddress, *deleteVpnGatewayConnectionPeerCidrOptions.PrefixLength}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVpnGatewayConnectionPeerCidrOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVpnGatewayConnectionPeerCidr")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVpnGatewayConnectionPeerCidr : Check if a specific CIDR exists on a specific resource
// This request succeeds if a CIDR exists on the resource and fails otherwise.
func (vpc *VpcV1) GetVpnGatewayConnectionPeerCidr(getVpnGatewayConnectionPeerCidrOptions *GetVpnGatewayConnectionPeerCidrOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVpnGatewayConnectionPeerCidrOptions, "getVpnGatewayConnectionPeerCidrOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVpnGatewayConnectionPeerCidrOptions, "getVpnGatewayConnectionPeerCidrOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections", "peer_cidrs", ""}
	pathParameters := []string{*getVpnGatewayConnectionPeerCidrOptions.VpnGatewayID, *getVpnGatewayConnectionPeerCidrOptions.ID, *getVpnGatewayConnectionPeerCidrOptions.PrefixAddress, *getVpnGatewayConnectionPeerCidrOptions.PrefixLength}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVpnGatewayConnectionPeerCidrOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVpnGatewayConnectionPeerCidr")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// SetVpnGatewayConnectionPeerCidr : Set a CIDR on a resource
// This request adds the specified CIDR to the specified resource. A request body is not required, and if supplied, is
// ignored. This request succeeds if the CIDR already exists on the resource.
func (vpc *VpcV1) SetVpnGatewayConnectionPeerCidr(setVpnGatewayConnectionPeerCidrOptions *SetVpnGatewayConnectionPeerCidrOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(setVpnGatewayConnectionPeerCidrOptions, "setVpnGatewayConnectionPeerCidrOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(setVpnGatewayConnectionPeerCidrOptions, "setVpnGatewayConnectionPeerCidrOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections", "peer_cidrs", ""}
	pathParameters := []string{*setVpnGatewayConnectionPeerCidrOptions.VpnGatewayID, *setVpnGatewayConnectionPeerCidrOptions.ID, *setVpnGatewayConnectionPeerCidrOptions.PrefixAddress, *setVpnGatewayConnectionPeerCidrOptions.PrefixLength}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range setVpnGatewayConnectionPeerCidrOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "SetVpnGatewayConnectionPeerCidr")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// ListVolumeProfiles : List all volume profiles
// This request lists all volume profiles available in the region. A volume profile specifies the performance
// characteristics and pricing model for a volume.
func (vpc *VpcV1) ListVolumeProfiles(listVolumeProfilesOptions *ListVolumeProfilesOptions) (result *VolumeProfileCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listVolumeProfilesOptions, "listVolumeProfilesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"volume/profiles"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVolumeProfilesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVolumeProfiles")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVolumeProfilesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVolumeProfilesOptions.Start))
	}
	if listVolumeProfilesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVolumeProfilesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVolumeProfileCollection(m)
		response.Result = result
	}

	return
}

// GetVolumeProfile : Retrieve specified volume profile
// This request retrieves a single volume profile specified by the name in the URL.
func (vpc *VpcV1) GetVolumeProfile(getVolumeProfileOptions *GetVolumeProfileOptions) (result *VolumeProfile, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVolumeProfileOptions, "getVolumeProfileOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVolumeProfileOptions, "getVolumeProfileOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"volume/profiles"}
	pathParameters := []string{*getVolumeProfileOptions.Name}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVolumeProfileOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVolumeProfile")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVolumeProfile(m)
		response.Result = result
	}

	return
}

// ListVolumes : List all volumes
// This request lists all volumes in the region. Volumes are network-connected block storage devices that may be
// attached to one or more instances in the same region.
func (vpc *VpcV1) ListVolumes(listVolumesOptions *ListVolumesOptions) (result *VolumeCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listVolumesOptions, "listVolumesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"volumes"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVolumesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVolumes")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVolumesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVolumesOptions.Start))
	}
	if listVolumesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVolumesOptions.Limit))
	}
	if listVolumesOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listVolumesOptions.Name))
	}
	if listVolumesOptions.ZoneName != nil {
		builder.AddQuery("zone.name", fmt.Sprint(*listVolumesOptions.ZoneName))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVolumeCollection(m)
		response.Result = result
	}

	return
}

// CreateVolume : Create a volume
// This request creates a new volume from a volume prototype object. The prototype object is structured in the same way
// as a retrieved volume, and contains the information necessary to create the new volume.
func (vpc *VpcV1) CreateVolume(createVolumeOptions *CreateVolumeOptions) (result *Volume, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVolumeOptions, "createVolumeOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVolumeOptions, "createVolumeOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"volumes"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVolumeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVolume")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createVolumeOptions.VolumePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVolume(m)
		response.Result = result
	}

	return
}

// DeleteVolume : Delete specified volume
// This request deletes a volume. This operation cannot be reversed. For this request to succeed, the volume must not be
// attached to any instances.
func (vpc *VpcV1) DeleteVolume(deleteVolumeOptions *DeleteVolumeOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVolumeOptions, "deleteVolumeOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVolumeOptions, "deleteVolumeOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"volumes"}
	pathParameters := []string{*deleteVolumeOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVolumeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVolume")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVolume : Retrieve specified volume
// This request retrieves a single volume specified by the identifier in the URL.
func (vpc *VpcV1) GetVolume(getVolumeOptions *GetVolumeOptions) (result *Volume, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVolumeOptions, "getVolumeOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVolumeOptions, "getVolumeOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"volumes"}
	pathParameters := []string{*getVolumeOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVolumeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVolume")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVolume(m)
		response.Result = result
	}

	return
}

// UpdateVolume : Update specified volume
// This request updates a volume with the information in a provided volume patch. The volume patch object is structured
// in the same way as a retrieved volume and contains only the information to be updated.
func (vpc *VpcV1) UpdateVolume(updateVolumeOptions *UpdateVolumeOptions) (result *Volume, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVolumeOptions, "updateVolumeOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVolumeOptions, "updateVolumeOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"volumes"}
	pathParameters := []string{*updateVolumeOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVolumeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVolume")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateVolumeOptions.Name != nil {
		body["name"] = updateVolumeOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, make(map[string]interface{}))
	if err == nil {
		m, ok := response.Result.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("an error occurred while processing the operation response")
			return
		}
		result, err = UnmarshalVolume(m)
		response.Result = result
	}

	return
}

// AddressPrefix : AddressPrefix struct
type AddressPrefix struct {
	// The CIDR block for this prefix.
	Cidr *string `json:"cidr" validate:"required"`

	// The date and time that the prefix was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Indicates whether subnets exist with addresses from this prefix.
	HasSubnets *bool `json:"has_subnets" validate:"required"`

	// The URL for this address prefix.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this address prefix.
	ID *string `json:"id" validate:"required"`

	// Indicates whether this is the default prefix for this zone in this VPC. If a default prefix was automatically
	// created when the VPC was created, the prefix is automatically named using a hyphenated list of randomly-selected
	// words, but may be updated with a user-specified name.
	IsDefault *bool `json:"is_default" validate:"required"`

	// The user-defined name for this address prefix. Names must be unique within the VPC the address prefix resides in.
	Name *string `json:"name" validate:"required"`

	// The zone this address prefix resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// UnmarshalAddressPrefix constructs an instance of AddressPrefix from the specified map.
func UnmarshalAddressPrefix(m map[string]interface{}) (result *AddressPrefix, err error) {
	obj := new(AddressPrefix)
	obj.Cidr, err = core.UnmarshalString(m, "cidr")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.HasSubnets, err = core.UnmarshalBool(m, "has_subnets")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IsDefault, err = core.UnmarshalBool(m, "is_default")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Zone, err = UnmarshalZoneReferenceAsProperty(m, "zone")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalAddressPrefixSlice unmarshals a slice of AddressPrefix instances from the specified list of maps.
func UnmarshalAddressPrefixSlice(s []interface{}) (slice []AddressPrefix, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'AddressPrefix'")
			return
		}
		obj, e := UnmarshalAddressPrefix(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalAddressPrefixAsProperty unmarshals an instance of AddressPrefix that is stored as a property
// within the specified map.
func UnmarshalAddressPrefixAsProperty(m map[string]interface{}, propertyName string) (result *AddressPrefix, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'AddressPrefix'", propertyName)
			return
		}
		result, err = UnmarshalAddressPrefix(objMap)
	}
	return
}

// UnmarshalAddressPrefixSliceAsProperty unmarshals a slice of AddressPrefix instances that are stored as a property
// within the specified map.
func UnmarshalAddressPrefixSliceAsProperty(m map[string]interface{}, propertyName string) (slice []AddressPrefix, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'AddressPrefix'", propertyName)
			return
		}
		slice, err = UnmarshalAddressPrefixSlice(vSlice)
	}
	return
}

// AddressPrefixCollection : AddressPrefixCollection struct
type AddressPrefixCollection struct {
	// Collection of address prefixes.
	AddressPrefixes []AddressPrefix `json:"address_prefixes" validate:"required"`
}

// UnmarshalAddressPrefixCollection constructs an instance of AddressPrefixCollection from the specified map.
func UnmarshalAddressPrefixCollection(m map[string]interface{}) (result *AddressPrefixCollection, err error) {
	obj := new(AddressPrefixCollection)
	obj.AddressPrefixes, err = UnmarshalAddressPrefixSliceAsProperty(m, "address_prefixes")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalAddressPrefixCollectionSlice unmarshals a slice of AddressPrefixCollection instances from the specified list of maps.
func UnmarshalAddressPrefixCollectionSlice(s []interface{}) (slice []AddressPrefixCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'AddressPrefixCollection'")
			return
		}
		obj, e := UnmarshalAddressPrefixCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalAddressPrefixCollectionAsProperty unmarshals an instance of AddressPrefixCollection that is stored as a property
// within the specified map.
func UnmarshalAddressPrefixCollectionAsProperty(m map[string]interface{}, propertyName string) (result *AddressPrefixCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'AddressPrefixCollection'", propertyName)
			return
		}
		result, err = UnmarshalAddressPrefixCollection(objMap)
	}
	return
}

// UnmarshalAddressPrefixCollectionSliceAsProperty unmarshals a slice of AddressPrefixCollection instances that are stored as a property
// within the specified map.
func UnmarshalAddressPrefixCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []AddressPrefixCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'AddressPrefixCollection'", propertyName)
			return
		}
		slice, err = UnmarshalAddressPrefixCollectionSlice(vSlice)
	}
	return
}

// CertificateInstanceIdentity : Identifies a certificate instance by a unique property.
// Models which "extend" this model:
// - CertificateInstanceIdentityByCRN
type CertificateInstanceIdentity struct {
	// The CRN for this certificate instance.
	Crn *string `json:"crn,omitempty"`
}

func (*CertificateInstanceIdentity) isaCertificateInstanceIdentity() bool {
	return true
}

type CertificateInstanceIdentityIntf interface {
	isaCertificateInstanceIdentity() bool
}

// UnmarshalCertificateInstanceIdentity constructs an instance of CertificateInstanceIdentity from the specified map.
func UnmarshalCertificateInstanceIdentity(m map[string]interface{}) (result CertificateInstanceIdentityIntf, err error) {
	obj := new(CertificateInstanceIdentity)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalCertificateInstanceIdentitySlice unmarshals a slice of CertificateInstanceIdentity instances from the specified list of maps.
func UnmarshalCertificateInstanceIdentitySlice(s []interface{}) (slice []CertificateInstanceIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'CertificateInstanceIdentity'")
			return
		}
		obj, e := UnmarshalCertificateInstanceIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalCertificateInstanceIdentityAsProperty unmarshals an instance of CertificateInstanceIdentity that is stored as a property
// within the specified map.
func UnmarshalCertificateInstanceIdentityAsProperty(m map[string]interface{}, propertyName string) (result CertificateInstanceIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'CertificateInstanceIdentity'", propertyName)
			return
		}
		result, err = UnmarshalCertificateInstanceIdentity(objMap)
	}
	return
}

// UnmarshalCertificateInstanceIdentitySliceAsProperty unmarshals a slice of CertificateInstanceIdentity instances that are stored as a property
// within the specified map.
func UnmarshalCertificateInstanceIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []CertificateInstanceIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'CertificateInstanceIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalCertificateInstanceIdentitySlice(vSlice)
	}
	return
}

// CertificateInstanceReference : CertificateInstanceReference struct
type CertificateInstanceReference struct {
	// The CRN for this certificate instance.
	Crn *string `json:"crn" validate:"required"`
}

// UnmarshalCertificateInstanceReference constructs an instance of CertificateInstanceReference from the specified map.
func UnmarshalCertificateInstanceReference(m map[string]interface{}) (result *CertificateInstanceReference, err error) {
	obj := new(CertificateInstanceReference)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalCertificateInstanceReferenceSlice unmarshals a slice of CertificateInstanceReference instances from the specified list of maps.
func UnmarshalCertificateInstanceReferenceSlice(s []interface{}) (slice []CertificateInstanceReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'CertificateInstanceReference'")
			return
		}
		obj, e := UnmarshalCertificateInstanceReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalCertificateInstanceReferenceAsProperty unmarshals an instance of CertificateInstanceReference that is stored as a property
// within the specified map.
func UnmarshalCertificateInstanceReferenceAsProperty(m map[string]interface{}, propertyName string) (result *CertificateInstanceReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'CertificateInstanceReference'", propertyName)
			return
		}
		result, err = UnmarshalCertificateInstanceReference(objMap)
	}
	return
}

// UnmarshalCertificateInstanceReferenceSliceAsProperty unmarshals a slice of CertificateInstanceReference instances that are stored as a property
// within the specified map.
func UnmarshalCertificateInstanceReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []CertificateInstanceReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'CertificateInstanceReference'", propertyName)
			return
		}
		slice, err = UnmarshalCertificateInstanceReferenceSlice(vSlice)
	}
	return
}

// CreateIkePolicyOptions : The CreateIkePolicy options.
type CreateIkePolicyOptions struct {
	// The authentication algorithm.
	AuthenticationAlgorithm *string `json:"authentication_algorithm" validate:"required"`

	// The Diffie-Hellman group.
	DhGroup *int64 `json:"dh_group" validate:"required"`

	// The encryption algorithm.
	EncryptionAlgorithm *string `json:"encryption_algorithm" validate:"required"`

	// The IKE protocol version.
	IkeVersion *int64 `json:"ike_version" validate:"required"`

	// The key lifetime in seconds.
	KeyLifetime *int64 `json:"key_lifetime,omitempty"`

	// The user-defined name for this IKE policy.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateIkePolicyOptions.AuthenticationAlgorithm property.
// The authentication algorithm.
const (
	CreateIkePolicyOptions_AuthenticationAlgorithm_Md5    = "md5"
	CreateIkePolicyOptions_AuthenticationAlgorithm_Sha1   = "sha1"
	CreateIkePolicyOptions_AuthenticationAlgorithm_Sha256 = "sha256"
)

// Constants associated with the CreateIkePolicyOptions.EncryptionAlgorithm property.
// The encryption algorithm.
const (
	CreateIkePolicyOptions_EncryptionAlgorithm_Aes128    = "aes128"
	CreateIkePolicyOptions_EncryptionAlgorithm_Aes256    = "aes256"
	CreateIkePolicyOptions_EncryptionAlgorithm_TripleDes = "triple_des"
)

// NewCreateIkePolicyOptions : Instantiate CreateIkePolicyOptions
func (*VpcV1) NewCreateIkePolicyOptions(authenticationAlgorithm string, dhGroup int64, encryptionAlgorithm string, ikeVersion int64) *CreateIkePolicyOptions {
	return &CreateIkePolicyOptions{
		AuthenticationAlgorithm: core.StringPtr(authenticationAlgorithm),
		DhGroup:                 core.Int64Ptr(dhGroup),
		EncryptionAlgorithm:     core.StringPtr(encryptionAlgorithm),
		IkeVersion:              core.Int64Ptr(ikeVersion),
	}
}

// SetAuthenticationAlgorithm : Allow user to set AuthenticationAlgorithm
func (options *CreateIkePolicyOptions) SetAuthenticationAlgorithm(authenticationAlgorithm string) *CreateIkePolicyOptions {
	options.AuthenticationAlgorithm = core.StringPtr(authenticationAlgorithm)
	return options
}

// SetDhGroup : Allow user to set DhGroup
func (options *CreateIkePolicyOptions) SetDhGroup(dhGroup int64) *CreateIkePolicyOptions {
	options.DhGroup = core.Int64Ptr(dhGroup)
	return options
}

// SetEncryptionAlgorithm : Allow user to set EncryptionAlgorithm
func (options *CreateIkePolicyOptions) SetEncryptionAlgorithm(encryptionAlgorithm string) *CreateIkePolicyOptions {
	options.EncryptionAlgorithm = core.StringPtr(encryptionAlgorithm)
	return options
}

// SetIkeVersion : Allow user to set IkeVersion
func (options *CreateIkePolicyOptions) SetIkeVersion(ikeVersion int64) *CreateIkePolicyOptions {
	options.IkeVersion = core.Int64Ptr(ikeVersion)
	return options
}

// SetKeyLifetime : Allow user to set KeyLifetime
func (options *CreateIkePolicyOptions) SetKeyLifetime(keyLifetime int64) *CreateIkePolicyOptions {
	options.KeyLifetime = core.Int64Ptr(keyLifetime)
	return options
}

// SetName : Allow user to set Name
func (options *CreateIkePolicyOptions) SetName(name string) *CreateIkePolicyOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreateIkePolicyOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateIkePolicyOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateIkePolicyOptions) SetHeaders(param map[string]string) *CreateIkePolicyOptions {
	options.Headers = param
	return options
}

// CreateImageOptions : The CreateImage options.
type CreateImageOptions struct {
	// The image prototype object.
	ImagePrototype ImagePrototypeIntf `json:"ImagePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateImageOptions : Instantiate CreateImageOptions
func (*VpcV1) NewCreateImageOptions(imagePrototype ImagePrototypeIntf) *CreateImageOptions {
	return &CreateImageOptions{
		ImagePrototype: imagePrototype,
	}
}

// SetImagePrototype : Allow user to set ImagePrototype
func (options *CreateImageOptions) SetImagePrototype(imagePrototype ImagePrototypeIntf) *CreateImageOptions {
	options.ImagePrototype = imagePrototype
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateImageOptions) SetHeaders(param map[string]string) *CreateImageOptions {
	options.Headers = param
	return options
}

// CreateInstanceActionOptions : The CreateInstanceAction options.
type CreateInstanceActionOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The type of action.
	Type *string `json:"type" validate:"required"`

	// If set to true, the action will be forced immediately, and all queued actions deleted. Ignored for the start action.
	Force *bool `json:"force,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateInstanceActionOptions.Type property.
// The type of action.
const (
	CreateInstanceActionOptions_Type_Reboot = "reboot"
	CreateInstanceActionOptions_Type_Start  = "start"
	CreateInstanceActionOptions_Type_Stop   = "stop"
)

// NewCreateInstanceActionOptions : Instantiate CreateInstanceActionOptions
func (*VpcV1) NewCreateInstanceActionOptions(instanceID string, typeVar string) *CreateInstanceActionOptions {
	return &CreateInstanceActionOptions{
		InstanceID: core.StringPtr(instanceID),
		Type:       core.StringPtr(typeVar),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *CreateInstanceActionOptions) SetInstanceID(instanceID string) *CreateInstanceActionOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetType : Allow user to set Type
func (options *CreateInstanceActionOptions) SetType(typeVar string) *CreateInstanceActionOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetForce : Allow user to set Force
func (options *CreateInstanceActionOptions) SetForce(force bool) *CreateInstanceActionOptions {
	options.Force = core.BoolPtr(force)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceActionOptions) SetHeaders(param map[string]string) *CreateInstanceActionOptions {
	options.Headers = param
	return options
}

// CreateInstanceOptions : The CreateInstance options.
type CreateInstanceOptions struct {
	// The instance prototype object.
	InstancePrototype InstancePrototypeIntf `json:"InstancePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateInstanceOptions : Instantiate CreateInstanceOptions
func (*VpcV1) NewCreateInstanceOptions(instancePrototype InstancePrototypeIntf) *CreateInstanceOptions {
	return &CreateInstanceOptions{
		InstancePrototype: instancePrototype,
	}
}

// SetInstancePrototype : Allow user to set InstancePrototype
func (options *CreateInstanceOptions) SetInstancePrototype(instancePrototype InstancePrototypeIntf) *CreateInstanceOptions {
	options.InstancePrototype = instancePrototype
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceOptions) SetHeaders(param map[string]string) *CreateInstanceOptions {
	options.Headers = param
	return options
}

// CreateIpsecPolicyOptions : The CreateIpsecPolicy options.
type CreateIpsecPolicyOptions struct {
	// The authentication algorithm.
	AuthenticationAlgorithm *string `json:"authentication_algorithm" validate:"required"`

	// The encryption algorithm.
	EncryptionAlgorithm *string `json:"encryption_algorithm" validate:"required"`

	// Perfect Forward Secrecy.
	Pfs *string `json:"pfs" validate:"required"`

	// The key lifetime in seconds.
	KeyLifetime *int64 `json:"key_lifetime,omitempty"`

	// The user-defined name for this IPsec policy.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateIpsecPolicyOptions.AuthenticationAlgorithm property.
// The authentication algorithm.
const (
	CreateIpsecPolicyOptions_AuthenticationAlgorithm_Md5    = "md5"
	CreateIpsecPolicyOptions_AuthenticationAlgorithm_Sha1   = "sha1"
	CreateIpsecPolicyOptions_AuthenticationAlgorithm_Sha256 = "sha256"
)

// Constants associated with the CreateIpsecPolicyOptions.EncryptionAlgorithm property.
// The encryption algorithm.
const (
	CreateIpsecPolicyOptions_EncryptionAlgorithm_Aes128    = "aes128"
	CreateIpsecPolicyOptions_EncryptionAlgorithm_Aes256    = "aes256"
	CreateIpsecPolicyOptions_EncryptionAlgorithm_TripleDes = "triple_des"
)

// Constants associated with the CreateIpsecPolicyOptions.Pfs property.
// Perfect Forward Secrecy.
const (
	CreateIpsecPolicyOptions_Pfs_Disabled = "disabled"
	CreateIpsecPolicyOptions_Pfs_Group14  = "group_14"
	CreateIpsecPolicyOptions_Pfs_Group2   = "group_2"
	CreateIpsecPolicyOptions_Pfs_Group5   = "group_5"
)

// NewCreateIpsecPolicyOptions : Instantiate CreateIpsecPolicyOptions
func (*VpcV1) NewCreateIpsecPolicyOptions(authenticationAlgorithm string, encryptionAlgorithm string, pfs string) *CreateIpsecPolicyOptions {
	return &CreateIpsecPolicyOptions{
		AuthenticationAlgorithm: core.StringPtr(authenticationAlgorithm),
		EncryptionAlgorithm:     core.StringPtr(encryptionAlgorithm),
		Pfs:                     core.StringPtr(pfs),
	}
}

// SetAuthenticationAlgorithm : Allow user to set AuthenticationAlgorithm
func (options *CreateIpsecPolicyOptions) SetAuthenticationAlgorithm(authenticationAlgorithm string) *CreateIpsecPolicyOptions {
	options.AuthenticationAlgorithm = core.StringPtr(authenticationAlgorithm)
	return options
}

// SetEncryptionAlgorithm : Allow user to set EncryptionAlgorithm
func (options *CreateIpsecPolicyOptions) SetEncryptionAlgorithm(encryptionAlgorithm string) *CreateIpsecPolicyOptions {
	options.EncryptionAlgorithm = core.StringPtr(encryptionAlgorithm)
	return options
}

// SetPfs : Allow user to set Pfs
func (options *CreateIpsecPolicyOptions) SetPfs(pfs string) *CreateIpsecPolicyOptions {
	options.Pfs = core.StringPtr(pfs)
	return options
}

// SetKeyLifetime : Allow user to set KeyLifetime
func (options *CreateIpsecPolicyOptions) SetKeyLifetime(keyLifetime int64) *CreateIpsecPolicyOptions {
	options.KeyLifetime = core.Int64Ptr(keyLifetime)
	return options
}

// SetName : Allow user to set Name
func (options *CreateIpsecPolicyOptions) SetName(name string) *CreateIpsecPolicyOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreateIpsecPolicyOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateIpsecPolicyOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateIpsecPolicyOptions) SetHeaders(param map[string]string) *CreateIpsecPolicyOptions {
	options.Headers = param
	return options
}

// CreateKeyOptions : The CreateKey options.
type CreateKeyOptions struct {
	// A unique public SSH key to import, encoded in PEM format. The key (prior to encoding) must be either 2048 or 4096
	// bits long.
	PublicKey *string `json:"public_key" validate:"required"`

	// The unique user-defined name for this key. If unspecified, the name will be a hyphenated list of randomly-selected
	// words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The cryptosystem used by this key.
	Type *string `json:"type,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateKeyOptions.Type property.
// The cryptosystem used by this key.
const (
	CreateKeyOptions_Type_Rsa = "rsa"
)

// NewCreateKeyOptions : Instantiate CreateKeyOptions
func (*VpcV1) NewCreateKeyOptions(publicKey string) *CreateKeyOptions {
	return &CreateKeyOptions{
		PublicKey: core.StringPtr(publicKey),
	}
}

// SetPublicKey : Allow user to set PublicKey
func (options *CreateKeyOptions) SetPublicKey(publicKey string) *CreateKeyOptions {
	options.PublicKey = core.StringPtr(publicKey)
	return options
}

// SetName : Allow user to set Name
func (options *CreateKeyOptions) SetName(name string) *CreateKeyOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreateKeyOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateKeyOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetType : Allow user to set Type
func (options *CreateKeyOptions) SetType(typeVar string) *CreateKeyOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateKeyOptions) SetHeaders(param map[string]string) *CreateKeyOptions {
	options.Headers = param
	return options
}

// CreateLoadBalancerListenerOptions : The CreateLoadBalancerListener options.
type CreateLoadBalancerListenerOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener port number.
	Port *int64 `json:"port" validate:"required"`

	// The listener protocol.
	Protocol *string `json:"protocol" validate:"required"`

	// The certificate instance used for SSL termination. It is applicable only to `https`
	// protocol.
	CertificateInstance CertificateInstanceIdentityIntf `json:"certificate_instance,omitempty"`

	// The connection limit of the listener.
	ConnectionLimit *int64 `json:"connection_limit,omitempty"`

	// The default pool associated with the listener.
	DefaultPool LoadBalancerPoolIdentityIntf `json:"default_pool,omitempty"`

	// The list of policies of this listener.
	Policies []LoadBalancerListenerPolicyPrototype `json:"policies,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateLoadBalancerListenerOptions.Protocol property.
// The listener protocol.
const (
	CreateLoadBalancerListenerOptions_Protocol_Http  = "http"
	CreateLoadBalancerListenerOptions_Protocol_Https = "https"
	CreateLoadBalancerListenerOptions_Protocol_Tcp   = "tcp"
)

// NewCreateLoadBalancerListenerOptions : Instantiate CreateLoadBalancerListenerOptions
func (*VpcV1) NewCreateLoadBalancerListenerOptions(loadBalancerID string, port int64, protocol string) *CreateLoadBalancerListenerOptions {
	return &CreateLoadBalancerListenerOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		Port:           core.Int64Ptr(port),
		Protocol:       core.StringPtr(protocol),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *CreateLoadBalancerListenerOptions) SetLoadBalancerID(loadBalancerID string) *CreateLoadBalancerListenerOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetPort : Allow user to set Port
func (options *CreateLoadBalancerListenerOptions) SetPort(port int64) *CreateLoadBalancerListenerOptions {
	options.Port = core.Int64Ptr(port)
	return options
}

// SetProtocol : Allow user to set Protocol
func (options *CreateLoadBalancerListenerOptions) SetProtocol(protocol string) *CreateLoadBalancerListenerOptions {
	options.Protocol = core.StringPtr(protocol)
	return options
}

// SetCertificateInstance : Allow user to set CertificateInstance
func (options *CreateLoadBalancerListenerOptions) SetCertificateInstance(certificateInstance CertificateInstanceIdentityIntf) *CreateLoadBalancerListenerOptions {
	options.CertificateInstance = certificateInstance
	return options
}

// SetConnectionLimit : Allow user to set ConnectionLimit
func (options *CreateLoadBalancerListenerOptions) SetConnectionLimit(connectionLimit int64) *CreateLoadBalancerListenerOptions {
	options.ConnectionLimit = core.Int64Ptr(connectionLimit)
	return options
}

// SetDefaultPool : Allow user to set DefaultPool
func (options *CreateLoadBalancerListenerOptions) SetDefaultPool(defaultPool LoadBalancerPoolIdentityIntf) *CreateLoadBalancerListenerOptions {
	options.DefaultPool = defaultPool
	return options
}

// SetPolicies : Allow user to set Policies
func (options *CreateLoadBalancerListenerOptions) SetPolicies(policies []LoadBalancerListenerPolicyPrototype) *CreateLoadBalancerListenerOptions {
	options.Policies = policies
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoadBalancerListenerOptions) SetHeaders(param map[string]string) *CreateLoadBalancerListenerOptions {
	options.Headers = param
	return options
}

// CreateLoadBalancerListenerPolicyOptions : The CreateLoadBalancerListenerPolicy options.
type CreateLoadBalancerListenerPolicyOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// The policy action.
	Action *string `json:"action" validate:"required"`

	// Priority of the policy. Lower value indicates higher priority.
	Priority *int64 `json:"priority" validate:"required"`

	// The user-defined name for this policy. Names must be unique within the load balancer listener the policy resides in.
	Name *string `json:"name,omitempty"`

	// The list of rules of this policy.
	Rules []LoadBalancerListenerPolicyRulePrototype `json:"rules,omitempty"`

	// When `action` is `forward`, `LoadBalancerPoolIdentity` is required to specify which
	// pool the load balancer forwards the traffic to. When `action` is `redirect`,
	// `LoadBalancerListenerPolicyRedirectURLPrototype` is required to specify the url and
	// http status code used in the redirect response.
	Target LoadBalancerListenerPolicyPrototypeTargetIntf `json:"target,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateLoadBalancerListenerPolicyOptions.Action property.
// The policy action.
const (
	CreateLoadBalancerListenerPolicyOptions_Action_Forward  = "forward"
	CreateLoadBalancerListenerPolicyOptions_Action_Redirect = "redirect"
	CreateLoadBalancerListenerPolicyOptions_Action_Reject   = "reject"
)

// NewCreateLoadBalancerListenerPolicyOptions : Instantiate CreateLoadBalancerListenerPolicyOptions
func (*VpcV1) NewCreateLoadBalancerListenerPolicyOptions(loadBalancerID string, listenerID string, action string, priority int64) *CreateLoadBalancerListenerPolicyOptions {
	return &CreateLoadBalancerListenerPolicyOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		Action:         core.StringPtr(action),
		Priority:       core.Int64Ptr(priority),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *CreateLoadBalancerListenerPolicyOptions) SetLoadBalancerID(loadBalancerID string) *CreateLoadBalancerListenerPolicyOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *CreateLoadBalancerListenerPolicyOptions) SetListenerID(listenerID string) *CreateLoadBalancerListenerPolicyOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetAction : Allow user to set Action
func (options *CreateLoadBalancerListenerPolicyOptions) SetAction(action string) *CreateLoadBalancerListenerPolicyOptions {
	options.Action = core.StringPtr(action)
	return options
}

// SetPriority : Allow user to set Priority
func (options *CreateLoadBalancerListenerPolicyOptions) SetPriority(priority int64) *CreateLoadBalancerListenerPolicyOptions {
	options.Priority = core.Int64Ptr(priority)
	return options
}

// SetName : Allow user to set Name
func (options *CreateLoadBalancerListenerPolicyOptions) SetName(name string) *CreateLoadBalancerListenerPolicyOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetRules : Allow user to set Rules
func (options *CreateLoadBalancerListenerPolicyOptions) SetRules(rules []LoadBalancerListenerPolicyRulePrototype) *CreateLoadBalancerListenerPolicyOptions {
	options.Rules = rules
	return options
}

// SetTarget : Allow user to set Target
func (options *CreateLoadBalancerListenerPolicyOptions) SetTarget(target LoadBalancerListenerPolicyPrototypeTargetIntf) *CreateLoadBalancerListenerPolicyOptions {
	options.Target = target
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoadBalancerListenerPolicyOptions) SetHeaders(param map[string]string) *CreateLoadBalancerListenerPolicyOptions {
	options.Headers = param
	return options
}

// CreateLoadBalancerListenerPolicyRuleOptions : The CreateLoadBalancerListenerPolicyRule options.
type CreateLoadBalancerListenerPolicyRuleOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// The policy identifier.
	PolicyID *string `json:"policy_id" validate:"required"`

	// The condition of the rule.
	Condition *string `json:"condition" validate:"required"`

	// The type of the rule.
	Type *string `json:"type" validate:"required"`

	// Value to be matched for rule condition.
	Value *string `json:"value" validate:"required"`

	// HTTP header field. This is only applicable to "header" rule type.
	Field *string `json:"field,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateLoadBalancerListenerPolicyRuleOptions.Condition property.
// The condition of the rule.
const (
	CreateLoadBalancerListenerPolicyRuleOptions_Condition_Contains     = "contains"
	CreateLoadBalancerListenerPolicyRuleOptions_Condition_Equals       = "equals"
	CreateLoadBalancerListenerPolicyRuleOptions_Condition_MatchesRegex = "matches_regex"
)

// Constants associated with the CreateLoadBalancerListenerPolicyRuleOptions.Type property.
// The type of the rule.
const (
	CreateLoadBalancerListenerPolicyRuleOptions_Type_Header   = "header"
	CreateLoadBalancerListenerPolicyRuleOptions_Type_Hostname = "hostname"
	CreateLoadBalancerListenerPolicyRuleOptions_Type_Path     = "path"
)

// NewCreateLoadBalancerListenerPolicyRuleOptions : Instantiate CreateLoadBalancerListenerPolicyRuleOptions
func (*VpcV1) NewCreateLoadBalancerListenerPolicyRuleOptions(loadBalancerID string, listenerID string, policyID string, condition string, typeVar string, value string) *CreateLoadBalancerListenerPolicyRuleOptions {
	return &CreateLoadBalancerListenerPolicyRuleOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		PolicyID:       core.StringPtr(policyID),
		Condition:      core.StringPtr(condition),
		Type:           core.StringPtr(typeVar),
		Value:          core.StringPtr(value),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *CreateLoadBalancerListenerPolicyRuleOptions) SetLoadBalancerID(loadBalancerID string) *CreateLoadBalancerListenerPolicyRuleOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *CreateLoadBalancerListenerPolicyRuleOptions) SetListenerID(listenerID string) *CreateLoadBalancerListenerPolicyRuleOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetPolicyID : Allow user to set PolicyID
func (options *CreateLoadBalancerListenerPolicyRuleOptions) SetPolicyID(policyID string) *CreateLoadBalancerListenerPolicyRuleOptions {
	options.PolicyID = core.StringPtr(policyID)
	return options
}

// SetCondition : Allow user to set Condition
func (options *CreateLoadBalancerListenerPolicyRuleOptions) SetCondition(condition string) *CreateLoadBalancerListenerPolicyRuleOptions {
	options.Condition = core.StringPtr(condition)
	return options
}

// SetType : Allow user to set Type
func (options *CreateLoadBalancerListenerPolicyRuleOptions) SetType(typeVar string) *CreateLoadBalancerListenerPolicyRuleOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetValue : Allow user to set Value
func (options *CreateLoadBalancerListenerPolicyRuleOptions) SetValue(value string) *CreateLoadBalancerListenerPolicyRuleOptions {
	options.Value = core.StringPtr(value)
	return options
}

// SetField : Allow user to set Field
func (options *CreateLoadBalancerListenerPolicyRuleOptions) SetField(field string) *CreateLoadBalancerListenerPolicyRuleOptions {
	options.Field = core.StringPtr(field)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoadBalancerListenerPolicyRuleOptions) SetHeaders(param map[string]string) *CreateLoadBalancerListenerPolicyRuleOptions {
	options.Headers = param
	return options
}

// CreateLoadBalancerOptions : The CreateLoadBalancer options.
type CreateLoadBalancerOptions struct {
	// The type of this load balancer, public or private.
	IsPublic *bool `json:"is_public" validate:"required"`

	// The subnets to provision this load balancer.
	Subnets []SubnetIdentityIntf `json:"subnets" validate:"required"`

	// The listeners of this load balancer.
	Listeners []LoadBalancerListenerPrototypeLoadBalancerContext `json:"listeners,omitempty"`

	// The user-defined name for this load balancer. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The pools of this load balancer.
	Pools []LoadBalancerPoolPrototype `json:"pools,omitempty"`

	// The resource group for this load balancer.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateLoadBalancerOptions : Instantiate CreateLoadBalancerOptions
func (*VpcV1) NewCreateLoadBalancerOptions(isPublic bool, subnets []SubnetIdentityIntf) *CreateLoadBalancerOptions {
	return &CreateLoadBalancerOptions{
		IsPublic: core.BoolPtr(isPublic),
		Subnets:  subnets,
	}
}

// SetIsPublic : Allow user to set IsPublic
func (options *CreateLoadBalancerOptions) SetIsPublic(isPublic bool) *CreateLoadBalancerOptions {
	options.IsPublic = core.BoolPtr(isPublic)
	return options
}

// SetSubnets : Allow user to set Subnets
func (options *CreateLoadBalancerOptions) SetSubnets(subnets []SubnetIdentityIntf) *CreateLoadBalancerOptions {
	options.Subnets = subnets
	return options
}

// SetListeners : Allow user to set Listeners
func (options *CreateLoadBalancerOptions) SetListeners(listeners []LoadBalancerListenerPrototypeLoadBalancerContext) *CreateLoadBalancerOptions {
	options.Listeners = listeners
	return options
}

// SetName : Allow user to set Name
func (options *CreateLoadBalancerOptions) SetName(name string) *CreateLoadBalancerOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetPools : Allow user to set Pools
func (options *CreateLoadBalancerOptions) SetPools(pools []LoadBalancerPoolPrototype) *CreateLoadBalancerOptions {
	options.Pools = pools
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreateLoadBalancerOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateLoadBalancerOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoadBalancerOptions) SetHeaders(param map[string]string) *CreateLoadBalancerOptions {
	options.Headers = param
	return options
}

// CreateLoadBalancerPoolMemberOptions : The CreateLoadBalancerPoolMember options.
type CreateLoadBalancerPoolMemberOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The pool identifier.
	PoolID *string `json:"pool_id" validate:"required"`

	// The port number of the application running in the server member.
	Port *int64 `json:"port" validate:"required"`

	// The pool member target.
	Target LoadBalancerPoolMemberTargetPrototypeIntf `json:"target" validate:"required"`

	// Weight of the server member. This takes effect only when the load balancing algorithm of its belonging pool is
	// `weighted_round_robin`.
	Weight *int64 `json:"weight,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateLoadBalancerPoolMemberOptions : Instantiate CreateLoadBalancerPoolMemberOptions
func (*VpcV1) NewCreateLoadBalancerPoolMemberOptions(loadBalancerID string, poolID string, port int64, target LoadBalancerPoolMemberTargetPrototypeIntf) *CreateLoadBalancerPoolMemberOptions {
	return &CreateLoadBalancerPoolMemberOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		PoolID:         core.StringPtr(poolID),
		Port:           core.Int64Ptr(port),
		Target:         target,
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *CreateLoadBalancerPoolMemberOptions) SetLoadBalancerID(loadBalancerID string) *CreateLoadBalancerPoolMemberOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetPoolID : Allow user to set PoolID
func (options *CreateLoadBalancerPoolMemberOptions) SetPoolID(poolID string) *CreateLoadBalancerPoolMemberOptions {
	options.PoolID = core.StringPtr(poolID)
	return options
}

// SetPort : Allow user to set Port
func (options *CreateLoadBalancerPoolMemberOptions) SetPort(port int64) *CreateLoadBalancerPoolMemberOptions {
	options.Port = core.Int64Ptr(port)
	return options
}

// SetTarget : Allow user to set Target
func (options *CreateLoadBalancerPoolMemberOptions) SetTarget(target LoadBalancerPoolMemberTargetPrototypeIntf) *CreateLoadBalancerPoolMemberOptions {
	options.Target = target
	return options
}

// SetWeight : Allow user to set Weight
func (options *CreateLoadBalancerPoolMemberOptions) SetWeight(weight int64) *CreateLoadBalancerPoolMemberOptions {
	options.Weight = core.Int64Ptr(weight)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoadBalancerPoolMemberOptions) SetHeaders(param map[string]string) *CreateLoadBalancerPoolMemberOptions {
	options.Headers = param
	return options
}

// CreateLoadBalancerPoolOptions : The CreateLoadBalancerPool options.
type CreateLoadBalancerPoolOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The load balancing algorithm.
	Algorithm *string `json:"algorithm" validate:"required"`

	// The health monitor of this pool.
	HealthMonitor *LoadBalancerPoolHealthMonitorPrototype `json:"health_monitor" validate:"required"`

	// The pool protocol.
	Protocol *string `json:"protocol" validate:"required"`

	// The members for this load balancer pool. For load balancers in the `network` family, the same `port` and `target`
	// tuple cannot be shared by a member of any other load balancer.
	Members []LoadBalancerPoolMemberPrototype `json:"members,omitempty"`

	// The user-defined name for this load balancer pool. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The session persistence of this pool.
	SessionPersistence *LoadBalancerPoolSessionPersistencePrototype `json:"session_persistence,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateLoadBalancerPoolOptions.Algorithm property.
// The load balancing algorithm.
const (
	CreateLoadBalancerPoolOptions_Algorithm_LeastConnections   = "least_connections"
	CreateLoadBalancerPoolOptions_Algorithm_RoundRobin         = "round_robin"
	CreateLoadBalancerPoolOptions_Algorithm_WeightedRoundRobin = "weighted_round_robin"
)

// Constants associated with the CreateLoadBalancerPoolOptions.Protocol property.
// The pool protocol.
const (
	CreateLoadBalancerPoolOptions_Protocol_Http = "http"
	CreateLoadBalancerPoolOptions_Protocol_Tcp  = "tcp"
)

// NewCreateLoadBalancerPoolOptions : Instantiate CreateLoadBalancerPoolOptions
func (*VpcV1) NewCreateLoadBalancerPoolOptions(loadBalancerID string, algorithm string, healthMonitor *LoadBalancerPoolHealthMonitorPrototype, protocol string) *CreateLoadBalancerPoolOptions {
	return &CreateLoadBalancerPoolOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		Algorithm:      core.StringPtr(algorithm),
		HealthMonitor:  healthMonitor,
		Protocol:       core.StringPtr(protocol),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *CreateLoadBalancerPoolOptions) SetLoadBalancerID(loadBalancerID string) *CreateLoadBalancerPoolOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetAlgorithm : Allow user to set Algorithm
func (options *CreateLoadBalancerPoolOptions) SetAlgorithm(algorithm string) *CreateLoadBalancerPoolOptions {
	options.Algorithm = core.StringPtr(algorithm)
	return options
}

// SetHealthMonitor : Allow user to set HealthMonitor
func (options *CreateLoadBalancerPoolOptions) SetHealthMonitor(healthMonitor *LoadBalancerPoolHealthMonitorPrototype) *CreateLoadBalancerPoolOptions {
	options.HealthMonitor = healthMonitor
	return options
}

// SetProtocol : Allow user to set Protocol
func (options *CreateLoadBalancerPoolOptions) SetProtocol(protocol string) *CreateLoadBalancerPoolOptions {
	options.Protocol = core.StringPtr(protocol)
	return options
}

// SetMembers : Allow user to set Members
func (options *CreateLoadBalancerPoolOptions) SetMembers(members []LoadBalancerPoolMemberPrototype) *CreateLoadBalancerPoolOptions {
	options.Members = members
	return options
}

// SetName : Allow user to set Name
func (options *CreateLoadBalancerPoolOptions) SetName(name string) *CreateLoadBalancerPoolOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetSessionPersistence : Allow user to set SessionPersistence
func (options *CreateLoadBalancerPoolOptions) SetSessionPersistence(sessionPersistence *LoadBalancerPoolSessionPersistencePrototype) *CreateLoadBalancerPoolOptions {
	options.SessionPersistence = sessionPersistence
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoadBalancerPoolOptions) SetHeaders(param map[string]string) *CreateLoadBalancerPoolOptions {
	options.Headers = param
	return options
}

// CreateNetworkAclOptions : The CreateNetworkAcl options.
type CreateNetworkAclOptions struct {
	// The network ACL prototype object.
	NetworkACLPrototype NetworkACLPrototypeIntf `json:"NetworkACLPrototype,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateNetworkAclOptions : Instantiate CreateNetworkAclOptions
func (*VpcV1) NewCreateNetworkAclOptions() *CreateNetworkAclOptions {
	return &CreateNetworkAclOptions{}
}

// SetNetworkACLPrototype : Allow user to set NetworkACLPrototype
func (options *CreateNetworkAclOptions) SetNetworkACLPrototype(networkACLPrototype NetworkACLPrototypeIntf) *CreateNetworkAclOptions {
	options.NetworkACLPrototype = networkACLPrototype
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateNetworkAclOptions) SetHeaders(param map[string]string) *CreateNetworkAclOptions {
	options.Headers = param
	return options
}

// CreateNetworkAclRuleOptions : The CreateNetworkAclRule options.
type CreateNetworkAclRuleOptions struct {
	// The network ACL identifier.
	NetworkAclID *string `json:"network_acl_id" validate:"required"`

	// The network ACL rule prototype object.
	NetworkACLRulePrototype NetworkACLRulePrototypeIntf `json:"NetworkACLRulePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateNetworkAclRuleOptions : Instantiate CreateNetworkAclRuleOptions
func (*VpcV1) NewCreateNetworkAclRuleOptions(networkAclID string, networkACLRulePrototype NetworkACLRulePrototypeIntf) *CreateNetworkAclRuleOptions {
	return &CreateNetworkAclRuleOptions{
		NetworkAclID:            core.StringPtr(networkAclID),
		NetworkACLRulePrototype: networkACLRulePrototype,
	}
}

// SetNetworkAclID : Allow user to set NetworkAclID
func (options *CreateNetworkAclRuleOptions) SetNetworkAclID(networkAclID string) *CreateNetworkAclRuleOptions {
	options.NetworkAclID = core.StringPtr(networkAclID)
	return options
}

// SetNetworkACLRulePrototype : Allow user to set NetworkACLRulePrototype
func (options *CreateNetworkAclRuleOptions) SetNetworkACLRulePrototype(networkACLRulePrototype NetworkACLRulePrototypeIntf) *CreateNetworkAclRuleOptions {
	options.NetworkACLRulePrototype = networkACLRulePrototype
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateNetworkAclRuleOptions) SetHeaders(param map[string]string) *CreateNetworkAclRuleOptions {
	options.Headers = param
	return options
}

// CreateNetworkInterfaceFloatingIpBindingOptions : The CreateNetworkInterfaceFloatingIpBinding options.
type CreateNetworkInterfaceFloatingIpBindingOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required"`

	// The floating IP identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateNetworkInterfaceFloatingIpBindingOptions : Instantiate CreateNetworkInterfaceFloatingIpBindingOptions
func (*VpcV1) NewCreateNetworkInterfaceFloatingIpBindingOptions(instanceID string, networkInterfaceID string, id string) *CreateNetworkInterfaceFloatingIpBindingOptions {
	return &CreateNetworkInterfaceFloatingIpBindingOptions{
		InstanceID:         core.StringPtr(instanceID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
		ID:                 core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *CreateNetworkInterfaceFloatingIpBindingOptions) SetInstanceID(instanceID string) *CreateNetworkInterfaceFloatingIpBindingOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (options *CreateNetworkInterfaceFloatingIpBindingOptions) SetNetworkInterfaceID(networkInterfaceID string) *CreateNetworkInterfaceFloatingIpBindingOptions {
	options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return options
}

// SetID : Allow user to set ID
func (options *CreateNetworkInterfaceFloatingIpBindingOptions) SetID(id string) *CreateNetworkInterfaceFloatingIpBindingOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateNetworkInterfaceFloatingIpBindingOptions) SetHeaders(param map[string]string) *CreateNetworkInterfaceFloatingIpBindingOptions {
	options.Headers = param
	return options
}

// CreateNetworkInterfaceOptions : The CreateNetworkInterface options.
type CreateNetworkInterfaceOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The associated subnet.
	Subnet SubnetIdentityIntf `json:"subnet" validate:"required"`

	// The user-defined name for this network interface. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The primary IPv4 address.
	PrimaryIpv4Address *string `json:"primary_ipv4_address,omitempty"`

	// Collection of security groups.
	SecurityGroups []SecurityGroupIdentityIntf `json:"security_groups,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateNetworkInterfaceOptions : Instantiate CreateNetworkInterfaceOptions
func (*VpcV1) NewCreateNetworkInterfaceOptions(instanceID string, subnet SubnetIdentityIntf) *CreateNetworkInterfaceOptions {
	return &CreateNetworkInterfaceOptions{
		InstanceID: core.StringPtr(instanceID),
		Subnet:     subnet,
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *CreateNetworkInterfaceOptions) SetInstanceID(instanceID string) *CreateNetworkInterfaceOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetSubnet : Allow user to set Subnet
func (options *CreateNetworkInterfaceOptions) SetSubnet(subnet SubnetIdentityIntf) *CreateNetworkInterfaceOptions {
	options.Subnet = subnet
	return options
}

// SetName : Allow user to set Name
func (options *CreateNetworkInterfaceOptions) SetName(name string) *CreateNetworkInterfaceOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetPrimaryIpv4Address : Allow user to set PrimaryIpv4Address
func (options *CreateNetworkInterfaceOptions) SetPrimaryIpv4Address(primaryIpv4Address string) *CreateNetworkInterfaceOptions {
	options.PrimaryIpv4Address = core.StringPtr(primaryIpv4Address)
	return options
}

// SetSecurityGroups : Allow user to set SecurityGroups
func (options *CreateNetworkInterfaceOptions) SetSecurityGroups(securityGroups []SecurityGroupIdentityIntf) *CreateNetworkInterfaceOptions {
	options.SecurityGroups = securityGroups
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateNetworkInterfaceOptions) SetHeaders(param map[string]string) *CreateNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// CreatePublicGatewayOptions : The CreatePublicGateway options.
type CreatePublicGatewayOptions struct {
	// The VPC this public gateway will serve.
	Vpc VPCIdentityIntf `json:"vpc" validate:"required"`

	// The zone where this public gateway will be created.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	FloatingIp PublicGatewayPrototypeFloatingIpIntf `json:"floating_ip,omitempty"`

	// The user-defined name for this public gateway. Names must be unique within the VPC the public gateway resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreatePublicGatewayOptions : Instantiate CreatePublicGatewayOptions
func (*VpcV1) NewCreatePublicGatewayOptions(vpc VPCIdentityIntf, zone ZoneIdentityIntf) *CreatePublicGatewayOptions {
	return &CreatePublicGatewayOptions{
		Vpc:  vpc,
		Zone: zone,
	}
}

// SetVpc : Allow user to set Vpc
func (options *CreatePublicGatewayOptions) SetVpc(vpc VPCIdentityIntf) *CreatePublicGatewayOptions {
	options.Vpc = vpc
	return options
}

// SetZone : Allow user to set Zone
func (options *CreatePublicGatewayOptions) SetZone(zone ZoneIdentityIntf) *CreatePublicGatewayOptions {
	options.Zone = zone
	return options
}

// SetFloatingIp : Allow user to set FloatingIp
func (options *CreatePublicGatewayOptions) SetFloatingIp(floatingIp PublicGatewayPrototypeFloatingIpIntf) *CreatePublicGatewayOptions {
	options.FloatingIp = floatingIp
	return options
}

// SetName : Allow user to set Name
func (options *CreatePublicGatewayOptions) SetName(name string) *CreatePublicGatewayOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreatePublicGatewayOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreatePublicGatewayOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreatePublicGatewayOptions) SetHeaders(param map[string]string) *CreatePublicGatewayOptions {
	options.Headers = param
	return options
}

// CreateSecurityGroupNetworkInterfaceBindingOptions : The CreateSecurityGroupNetworkInterfaceBinding options.
type CreateSecurityGroupNetworkInterfaceBindingOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required"`

	// The network interface identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSecurityGroupNetworkInterfaceBindingOptions : Instantiate CreateSecurityGroupNetworkInterfaceBindingOptions
func (*VpcV1) NewCreateSecurityGroupNetworkInterfaceBindingOptions(securityGroupID string, id string) *CreateSecurityGroupNetworkInterfaceBindingOptions {
	return &CreateSecurityGroupNetworkInterfaceBindingOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (options *CreateSecurityGroupNetworkInterfaceBindingOptions) SetSecurityGroupID(securityGroupID string) *CreateSecurityGroupNetworkInterfaceBindingOptions {
	options.SecurityGroupID = core.StringPtr(securityGroupID)
	return options
}

// SetID : Allow user to set ID
func (options *CreateSecurityGroupNetworkInterfaceBindingOptions) SetID(id string) *CreateSecurityGroupNetworkInterfaceBindingOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSecurityGroupNetworkInterfaceBindingOptions) SetHeaders(param map[string]string) *CreateSecurityGroupNetworkInterfaceBindingOptions {
	options.Headers = param
	return options
}

// CreateSecurityGroupOptions : The CreateSecurityGroup options.
type CreateSecurityGroupOptions struct {
	// The VPC this security group is to be a part of.
	Vpc VPCIdentityIntf `json:"vpc" validate:"required"`

	// The user-defined name for this security group. If unspecified, the name will be a hyphenated list of
	// randomly-selected words. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Array of rule prototype objects for rules to be created for this security group. If unspecified, no rules will be
	// created, resulting in all traffic being denied.
	Rules []SecurityGroupRulePrototypeIntf `json:"rules,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSecurityGroupOptions : Instantiate CreateSecurityGroupOptions
func (*VpcV1) NewCreateSecurityGroupOptions(vpc VPCIdentityIntf) *CreateSecurityGroupOptions {
	return &CreateSecurityGroupOptions{
		Vpc: vpc,
	}
}

// SetVpc : Allow user to set Vpc
func (options *CreateSecurityGroupOptions) SetVpc(vpc VPCIdentityIntf) *CreateSecurityGroupOptions {
	options.Vpc = vpc
	return options
}

// SetName : Allow user to set Name
func (options *CreateSecurityGroupOptions) SetName(name string) *CreateSecurityGroupOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreateSecurityGroupOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateSecurityGroupOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetRules : Allow user to set Rules
func (options *CreateSecurityGroupOptions) SetRules(rules []SecurityGroupRulePrototypeIntf) *CreateSecurityGroupOptions {
	options.Rules = rules
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSecurityGroupOptions) SetHeaders(param map[string]string) *CreateSecurityGroupOptions {
	options.Headers = param
	return options
}

// CreateSecurityGroupRuleOptions : The CreateSecurityGroupRule options.
type CreateSecurityGroupRuleOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required"`

	// The properties of the security group rule to be created.
	SecurityGroupRulePrototype SecurityGroupRulePrototypeIntf `json:"SecurityGroupRulePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSecurityGroupRuleOptions : Instantiate CreateSecurityGroupRuleOptions
func (*VpcV1) NewCreateSecurityGroupRuleOptions(securityGroupID string, securityGroupRulePrototype SecurityGroupRulePrototypeIntf) *CreateSecurityGroupRuleOptions {
	return &CreateSecurityGroupRuleOptions{
		SecurityGroupID:            core.StringPtr(securityGroupID),
		SecurityGroupRulePrototype: securityGroupRulePrototype,
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (options *CreateSecurityGroupRuleOptions) SetSecurityGroupID(securityGroupID string) *CreateSecurityGroupRuleOptions {
	options.SecurityGroupID = core.StringPtr(securityGroupID)
	return options
}

// SetSecurityGroupRulePrototype : Allow user to set SecurityGroupRulePrototype
func (options *CreateSecurityGroupRuleOptions) SetSecurityGroupRulePrototype(securityGroupRulePrototype SecurityGroupRulePrototypeIntf) *CreateSecurityGroupRuleOptions {
	options.SecurityGroupRulePrototype = securityGroupRulePrototype
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSecurityGroupRuleOptions) SetHeaders(param map[string]string) *CreateSecurityGroupRuleOptions {
	options.Headers = param
	return options
}

// CreateSubnetOptions : The CreateSubnet options.
type CreateSubnetOptions struct {
	// The subnet prototype object.
	SubnetPrototype SubnetPrototypeIntf `json:"SubnetPrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSubnetOptions : Instantiate CreateSubnetOptions
func (*VpcV1) NewCreateSubnetOptions(subnetPrototype SubnetPrototypeIntf) *CreateSubnetOptions {
	return &CreateSubnetOptions{
		SubnetPrototype: subnetPrototype,
	}
}

// SetSubnetPrototype : Allow user to set SubnetPrototype
func (options *CreateSubnetOptions) SetSubnetPrototype(subnetPrototype SubnetPrototypeIntf) *CreateSubnetOptions {
	options.SubnetPrototype = subnetPrototype
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSubnetOptions) SetHeaders(param map[string]string) *CreateSubnetOptions {
	options.Headers = param
	return options
}

// CreateVolumeAttachmentOptions : The CreateVolumeAttachment options.
type CreateVolumeAttachmentOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The identity of the volume to attach to the instance.
	Volume VolumeIdentityIntf `json:"volume" validate:"required"`

	// If set to true, when deleting the instance the volume will also be deleted.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete,omitempty"`

	// The user-defined name for this volume attachment. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateVolumeAttachmentOptions : Instantiate CreateVolumeAttachmentOptions
func (*VpcV1) NewCreateVolumeAttachmentOptions(instanceID string, volume VolumeIdentityIntf) *CreateVolumeAttachmentOptions {
	return &CreateVolumeAttachmentOptions{
		InstanceID: core.StringPtr(instanceID),
		Volume:     volume,
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *CreateVolumeAttachmentOptions) SetInstanceID(instanceID string) *CreateVolumeAttachmentOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetVolume : Allow user to set Volume
func (options *CreateVolumeAttachmentOptions) SetVolume(volume VolumeIdentityIntf) *CreateVolumeAttachmentOptions {
	options.Volume = volume
	return options
}

// SetDeleteVolumeOnInstanceDelete : Allow user to set DeleteVolumeOnInstanceDelete
func (options *CreateVolumeAttachmentOptions) SetDeleteVolumeOnInstanceDelete(deleteVolumeOnInstanceDelete bool) *CreateVolumeAttachmentOptions {
	options.DeleteVolumeOnInstanceDelete = core.BoolPtr(deleteVolumeOnInstanceDelete)
	return options
}

// SetName : Allow user to set Name
func (options *CreateVolumeAttachmentOptions) SetName(name string) *CreateVolumeAttachmentOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVolumeAttachmentOptions) SetHeaders(param map[string]string) *CreateVolumeAttachmentOptions {
	options.Headers = param
	return options
}

// CreateVolumeOptions : The CreateVolume options.
type CreateVolumeOptions struct {
	// The volume prototype object.
	VolumePrototype VolumePrototypeIntf `json:"VolumePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateVolumeOptions : Instantiate CreateVolumeOptions
func (*VpcV1) NewCreateVolumeOptions(volumePrototype VolumePrototypeIntf) *CreateVolumeOptions {
	return &CreateVolumeOptions{
		VolumePrototype: volumePrototype,
	}
}

// SetVolumePrototype : Allow user to set VolumePrototype
func (options *CreateVolumeOptions) SetVolumePrototype(volumePrototype VolumePrototypeIntf) *CreateVolumeOptions {
	options.VolumePrototype = volumePrototype
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVolumeOptions) SetHeaders(param map[string]string) *CreateVolumeOptions {
	options.Headers = param
	return options
}

// CreateVpcAddressPrefixOptions : The CreateVpcAddressPrefix options.
type CreateVpcAddressPrefixOptions struct {
	// The VPC identifier.
	VpcID *string `json:"vpc_id" validate:"required"`

	// The CIDR block for this address prefix. The request must not overlap with any existing address prefixes in the VPC,
	// and must fall within the
	// [RFC 1918](https://tools.ietf.org/html/rfc1918) address ranges.
	Cidr *string `json:"cidr" validate:"required"`

	// The zone this address prefix is to belong to.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// Indicates whether this is the default prefix for this zone in this VPC. If true, this prefix will become the default
	// prefix for this zone in this VPC. This fails if the VPC currently has a default address prefix for this zone.
	IsDefault *bool `json:"is_default,omitempty"`

	// The user-defined name for this address prefix. Names must be unique within the VPC the address prefix resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateVpcAddressPrefixOptions : Instantiate CreateVpcAddressPrefixOptions
func (*VpcV1) NewCreateVpcAddressPrefixOptions(vpcID string, cidr string, zone ZoneIdentityIntf) *CreateVpcAddressPrefixOptions {
	return &CreateVpcAddressPrefixOptions{
		VpcID: core.StringPtr(vpcID),
		Cidr:  core.StringPtr(cidr),
		Zone:  zone,
	}
}

// SetVpcID : Allow user to set VpcID
func (options *CreateVpcAddressPrefixOptions) SetVpcID(vpcID string) *CreateVpcAddressPrefixOptions {
	options.VpcID = core.StringPtr(vpcID)
	return options
}

// SetCidr : Allow user to set Cidr
func (options *CreateVpcAddressPrefixOptions) SetCidr(cidr string) *CreateVpcAddressPrefixOptions {
	options.Cidr = core.StringPtr(cidr)
	return options
}

// SetZone : Allow user to set Zone
func (options *CreateVpcAddressPrefixOptions) SetZone(zone ZoneIdentityIntf) *CreateVpcAddressPrefixOptions {
	options.Zone = zone
	return options
}

// SetIsDefault : Allow user to set IsDefault
func (options *CreateVpcAddressPrefixOptions) SetIsDefault(isDefault bool) *CreateVpcAddressPrefixOptions {
	options.IsDefault = core.BoolPtr(isDefault)
	return options
}

// SetName : Allow user to set Name
func (options *CreateVpcAddressPrefixOptions) SetName(name string) *CreateVpcAddressPrefixOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVpcAddressPrefixOptions) SetHeaders(param map[string]string) *CreateVpcAddressPrefixOptions {
	options.Headers = param
	return options
}

// CreateVpcOptions : The CreateVpc options.
type CreateVpcOptions struct {
	// Indicates whether a default address prefix should be automatically created for each zone in this VPC. If `manual`,
	// this VPC will be created with no default address prefixes.
	AddressPrefixManagement *string `json:"address_prefix_management,omitempty"`

	// Indicates whether this VPC should be connected to Classic Infrastructure. If true, this VPC's resources will have
	// private network connectivity to the account's Classic Infrastructure resources. Only one VPC, per region, may be
	// connected in this way. This value is set at creation and subsequently immutable.
	ClassicAccess *bool `json:"classic_access,omitempty"`

	// The unique user-defined name for this VPC. If unspecified, the name will be a hyphenated list of randomly-selected
	// words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateVpcOptions.AddressPrefixManagement property.
// Indicates whether a default address prefix should be automatically created for each zone in this VPC. If `manual`,
// this VPC will be created with no default address prefixes.
const (
	CreateVpcOptions_AddressPrefixManagement_Auto   = "auto"
	CreateVpcOptions_AddressPrefixManagement_Manual = "manual"
)

// NewCreateVpcOptions : Instantiate CreateVpcOptions
func (*VpcV1) NewCreateVpcOptions() *CreateVpcOptions {
	return &CreateVpcOptions{}
}

// SetAddressPrefixManagement : Allow user to set AddressPrefixManagement
func (options *CreateVpcOptions) SetAddressPrefixManagement(addressPrefixManagement string) *CreateVpcOptions {
	options.AddressPrefixManagement = core.StringPtr(addressPrefixManagement)
	return options
}

// SetClassicAccess : Allow user to set ClassicAccess
func (options *CreateVpcOptions) SetClassicAccess(classicAccess bool) *CreateVpcOptions {
	options.ClassicAccess = core.BoolPtr(classicAccess)
	return options
}

// SetName : Allow user to set Name
func (options *CreateVpcOptions) SetName(name string) *CreateVpcOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreateVpcOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateVpcOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVpcOptions) SetHeaders(param map[string]string) *CreateVpcOptions {
	options.Headers = param
	return options
}

// CreateVpcRouteOptions : The CreateVpcRoute options.
type CreateVpcRouteOptions struct {
	// The VPC identifier.
	VpcID *string `json:"vpc_id" validate:"required"`

	// The destination of the route. Must not overlap with destinations for existing user-defined routes within the VPC.
	Destination *string `json:"destination" validate:"required"`

	// The zone to apply the route to. (Traffic from subnets in this zone will be
	// subject to this route.).
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// The user-defined name for this route. If unspecified, the name will be a hyphenated list of randomly-selected words.
	// Names must be unique within the VPC routing table the route resides in.
	Name *string `json:"name,omitempty"`

	// The next hop that packets will be delivered to.
	NextHop RouteNextHopPrototypeIntf `json:"next_hop,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateVpcRouteOptions : Instantiate CreateVpcRouteOptions
func (*VpcV1) NewCreateVpcRouteOptions(vpcID string, destination string, zone ZoneIdentityIntf) *CreateVpcRouteOptions {
	return &CreateVpcRouteOptions{
		VpcID:       core.StringPtr(vpcID),
		Destination: core.StringPtr(destination),
		Zone:        zone,
	}
}

// SetVpcID : Allow user to set VpcID
func (options *CreateVpcRouteOptions) SetVpcID(vpcID string) *CreateVpcRouteOptions {
	options.VpcID = core.StringPtr(vpcID)
	return options
}

// SetDestination : Allow user to set Destination
func (options *CreateVpcRouteOptions) SetDestination(destination string) *CreateVpcRouteOptions {
	options.Destination = core.StringPtr(destination)
	return options
}

// SetZone : Allow user to set Zone
func (options *CreateVpcRouteOptions) SetZone(zone ZoneIdentityIntf) *CreateVpcRouteOptions {
	options.Zone = zone
	return options
}

// SetName : Allow user to set Name
func (options *CreateVpcRouteOptions) SetName(name string) *CreateVpcRouteOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetNextHop : Allow user to set NextHop
func (options *CreateVpcRouteOptions) SetNextHop(nextHop RouteNextHopPrototypeIntf) *CreateVpcRouteOptions {
	options.NextHop = nextHop
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVpcRouteOptions) SetHeaders(param map[string]string) *CreateVpcRouteOptions {
	options.Headers = param
	return options
}

// CreateVpnGatewayConnectionOptions : The CreateVpnGatewayConnection options.
type CreateVpnGatewayConnectionOptions struct {
	// The VPN gateway identifier.
	VpnGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The IP address of the peer VPN gateway.
	PeerAddress *string `json:"peer_address" validate:"required"`

	// The preshared key.
	Psk *string `json:"psk" validate:"required"`

	// If set to false, the VPN connection is shut down.
	AdminStateUp *bool `json:"admin_state_up,omitempty"`

	// The Dead Peer Detection settings.
	DeadPeerDetection *VPNGatewayConnectionDPDPrototype `json:"dead_peer_detection,omitempty"`

	// Optional IKE policy configuration. The absence of a policy indicates autonegotiation.
	IkePolicy IKEPolicyIdentityIntf `json:"ike_policy,omitempty"`

	// Optional IPsec policy configuration. The absence of a policy indicates
	// autonegotiation.
	IpsecPolicy IPsecPolicyIdentityIntf `json:"ipsec_policy,omitempty"`

	// A collection of local CIDRs for this resource.
	LocalCidrs []string `json:"local_cidrs,omitempty"`

	// The user-defined name for this VPN connection.
	Name *string `json:"name,omitempty"`

	// A collection of peer CIDRs for this resource.
	PeerCidrs []string `json:"peer_cidrs,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateVpnGatewayConnectionOptions : Instantiate CreateVpnGatewayConnectionOptions
func (*VpcV1) NewCreateVpnGatewayConnectionOptions(vpnGatewayID string, peerAddress string, psk string) *CreateVpnGatewayConnectionOptions {
	return &CreateVpnGatewayConnectionOptions{
		VpnGatewayID: core.StringPtr(vpnGatewayID),
		PeerAddress:  core.StringPtr(peerAddress),
		Psk:          core.StringPtr(psk),
	}
}

// SetVpnGatewayID : Allow user to set VpnGatewayID
func (options *CreateVpnGatewayConnectionOptions) SetVpnGatewayID(vpnGatewayID string) *CreateVpnGatewayConnectionOptions {
	options.VpnGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetPeerAddress : Allow user to set PeerAddress
func (options *CreateVpnGatewayConnectionOptions) SetPeerAddress(peerAddress string) *CreateVpnGatewayConnectionOptions {
	options.PeerAddress = core.StringPtr(peerAddress)
	return options
}

// SetPsk : Allow user to set Psk
func (options *CreateVpnGatewayConnectionOptions) SetPsk(psk string) *CreateVpnGatewayConnectionOptions {
	options.Psk = core.StringPtr(psk)
	return options
}

// SetAdminStateUp : Allow user to set AdminStateUp
func (options *CreateVpnGatewayConnectionOptions) SetAdminStateUp(adminStateUp bool) *CreateVpnGatewayConnectionOptions {
	options.AdminStateUp = core.BoolPtr(adminStateUp)
	return options
}

// SetDeadPeerDetection : Allow user to set DeadPeerDetection
func (options *CreateVpnGatewayConnectionOptions) SetDeadPeerDetection(deadPeerDetection *VPNGatewayConnectionDPDPrototype) *CreateVpnGatewayConnectionOptions {
	options.DeadPeerDetection = deadPeerDetection
	return options
}

// SetIkePolicy : Allow user to set IkePolicy
func (options *CreateVpnGatewayConnectionOptions) SetIkePolicy(ikePolicy IKEPolicyIdentityIntf) *CreateVpnGatewayConnectionOptions {
	options.IkePolicy = ikePolicy
	return options
}

// SetIpsecPolicy : Allow user to set IpsecPolicy
func (options *CreateVpnGatewayConnectionOptions) SetIpsecPolicy(ipsecPolicy IPsecPolicyIdentityIntf) *CreateVpnGatewayConnectionOptions {
	options.IpsecPolicy = ipsecPolicy
	return options
}

// SetLocalCidrs : Allow user to set LocalCidrs
func (options *CreateVpnGatewayConnectionOptions) SetLocalCidrs(localCidrs []string) *CreateVpnGatewayConnectionOptions {
	options.LocalCidrs = localCidrs
	return options
}

// SetName : Allow user to set Name
func (options *CreateVpnGatewayConnectionOptions) SetName(name string) *CreateVpnGatewayConnectionOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetPeerCidrs : Allow user to set PeerCidrs
func (options *CreateVpnGatewayConnectionOptions) SetPeerCidrs(peerCidrs []string) *CreateVpnGatewayConnectionOptions {
	options.PeerCidrs = peerCidrs
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVpnGatewayConnectionOptions) SetHeaders(param map[string]string) *CreateVpnGatewayConnectionOptions {
	options.Headers = param
	return options
}

// CreateVpnGatewayOptions : The CreateVpnGateway options.
type CreateVpnGatewayOptions struct {
	// Identifies a subnet by a unique property.
	Subnet SubnetIdentityIntf `json:"subnet" validate:"required"`

	// The user-defined name for this VPN gateway.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateVpnGatewayOptions : Instantiate CreateVpnGatewayOptions
func (*VpcV1) NewCreateVpnGatewayOptions(subnet SubnetIdentityIntf) *CreateVpnGatewayOptions {
	return &CreateVpnGatewayOptions{
		Subnet: subnet,
	}
}

// SetSubnet : Allow user to set Subnet
func (options *CreateVpnGatewayOptions) SetSubnet(subnet SubnetIdentityIntf) *CreateVpnGatewayOptions {
	options.Subnet = subnet
	return options
}

// SetName : Allow user to set Name
func (options *CreateVpnGatewayOptions) SetName(name string) *CreateVpnGatewayOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreateVpnGatewayOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateVpnGatewayOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVpnGatewayOptions) SetHeaders(param map[string]string) *CreateVpnGatewayOptions {
	options.Headers = param
	return options
}

// DefaultNetworkACL : DefaultNetworkACL struct
type DefaultNetworkACL struct {
	// The date and time that the network ACL was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this network ACL.
	Crn *string `json:"crn" validate:"required"`

	// The URL for this network ACL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network ACL.
	ID *string `json:"id" validate:"required"`

	// The name of the default network ACL created for a VPC. The name will be a hyphenated list of randomly-selected words
	// at creation, but may be user-specified with a subsequent request.
	Name *string `json:"name" validate:"required"`

	// The resource group for the default network ACL for a VPC. Set to the VPC's
	// resource group at creation.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The ordered rules for the default network ACL for a VPC.  Defaults to two rules which allow all inbound and outbound
	// traffic, respectively.  Rules for the default network ACL may be changed, added, or removed.
	Rules []NetworkACLRuleItemIntf `json:"rules" validate:"required"`

	// The subnets to which this network ACL is attached.
	Subnets []SubnetReference `json:"subnets" validate:"required"`

	// The VPC this network ACL is a part of.
	Vpc *VPCReference `json:"vpc" validate:"required"`
}

// UnmarshalDefaultNetworkACL constructs an instance of DefaultNetworkACL from the specified map.
func UnmarshalDefaultNetworkACL(m map[string]interface{}) (result *DefaultNetworkACL, err error) {
	obj := new(DefaultNetworkACL)
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupReferenceAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Rules, err = UnmarshalNetworkACLRuleItemSliceAsProperty(m, "rules")
	if err != nil {
		return
	}
	obj.Subnets, err = UnmarshalSubnetReferenceSliceAsProperty(m, "subnets")
	if err != nil {
		return
	}
	obj.Vpc, err = UnmarshalVPCReferenceAsProperty(m, "vpc")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalDefaultNetworkACLSlice unmarshals a slice of DefaultNetworkACL instances from the specified list of maps.
func UnmarshalDefaultNetworkACLSlice(s []interface{}) (slice []DefaultNetworkACL, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'DefaultNetworkACL'")
			return
		}
		obj, e := UnmarshalDefaultNetworkACL(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalDefaultNetworkACLAsProperty unmarshals an instance of DefaultNetworkACL that is stored as a property
// within the specified map.
func UnmarshalDefaultNetworkACLAsProperty(m map[string]interface{}, propertyName string) (result *DefaultNetworkACL, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'DefaultNetworkACL'", propertyName)
			return
		}
		result, err = UnmarshalDefaultNetworkACL(objMap)
	}
	return
}

// UnmarshalDefaultNetworkACLSliceAsProperty unmarshals a slice of DefaultNetworkACL instances that are stored as a property
// within the specified map.
func UnmarshalDefaultNetworkACLSliceAsProperty(m map[string]interface{}, propertyName string) (slice []DefaultNetworkACL, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'DefaultNetworkACL'", propertyName)
			return
		}
		slice, err = UnmarshalDefaultNetworkACLSlice(vSlice)
	}
	return
}

// DefaultSecurityGroup : Collection of rules in a default security group.
type DefaultSecurityGroup struct {
	// The date and time that this security group was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The security group's CRN.
	Crn *string `json:"crn" validate:"required"`

	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`

	// The name of the default security group created for a VPC. The name will be a hyphenated list of randomly-selected
	// words at creation, but may be user-specified with a subsequent request.
	Name *string `json:"name" validate:"required"`

	// The resource group for this security group.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// Array of rules for the default security group for a VPC. Defaults to allowing all outbound traffic, and allowing all
	// inbound traffic from other interfaces in the VPCâ€s default security group. Rules in the default security group may
	// be changed, added or removed.
	Rules []SecurityGroupRuleIntf `json:"rules" validate:"required"`

	// The VPC this security group is a part of.
	Vpc *VPCReference `json:"vpc" validate:"required"`
}

// UnmarshalDefaultSecurityGroup constructs an instance of DefaultSecurityGroup from the specified map.
func UnmarshalDefaultSecurityGroup(m map[string]interface{}) (result *DefaultSecurityGroup, err error) {
	obj := new(DefaultSecurityGroup)
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupReferenceAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Rules, err = UnmarshalSecurityGroupRuleSliceAsProperty(m, "rules")
	if err != nil {
		return
	}
	obj.Vpc, err = UnmarshalVPCReferenceAsProperty(m, "vpc")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalDefaultSecurityGroupSlice unmarshals a slice of DefaultSecurityGroup instances from the specified list of maps.
func UnmarshalDefaultSecurityGroupSlice(s []interface{}) (slice []DefaultSecurityGroup, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'DefaultSecurityGroup'")
			return
		}
		obj, e := UnmarshalDefaultSecurityGroup(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalDefaultSecurityGroupAsProperty unmarshals an instance of DefaultSecurityGroup that is stored as a property
// within the specified map.
func UnmarshalDefaultSecurityGroupAsProperty(m map[string]interface{}, propertyName string) (result *DefaultSecurityGroup, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'DefaultSecurityGroup'", propertyName)
			return
		}
		result, err = UnmarshalDefaultSecurityGroup(objMap)
	}
	return
}

// UnmarshalDefaultSecurityGroupSliceAsProperty unmarshals a slice of DefaultSecurityGroup instances that are stored as a property
// within the specified map.
func UnmarshalDefaultSecurityGroupSliceAsProperty(m map[string]interface{}, propertyName string) (slice []DefaultSecurityGroup, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'DefaultSecurityGroup'", propertyName)
			return
		}
		slice, err = UnmarshalDefaultSecurityGroupSlice(vSlice)
	}
	return
}

// DeleteIkePolicyOptions : The DeleteIkePolicy options.
type DeleteIkePolicyOptions struct {
	// The IKE policy identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteIkePolicyOptions : Instantiate DeleteIkePolicyOptions
func (*VpcV1) NewDeleteIkePolicyOptions(id string) *DeleteIkePolicyOptions {
	return &DeleteIkePolicyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteIkePolicyOptions) SetID(id string) *DeleteIkePolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteIkePolicyOptions) SetHeaders(param map[string]string) *DeleteIkePolicyOptions {
	options.Headers = param
	return options
}

// DeleteImageOptions : The DeleteImage options.
type DeleteImageOptions struct {
	// The image identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteImageOptions : Instantiate DeleteImageOptions
func (*VpcV1) NewDeleteImageOptions(id string) *DeleteImageOptions {
	return &DeleteImageOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteImageOptions) SetID(id string) *DeleteImageOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteImageOptions) SetHeaders(param map[string]string) *DeleteImageOptions {
	options.Headers = param
	return options
}

// DeleteInstanceOptions : The DeleteInstance options.
type DeleteInstanceOptions struct {
	// The instance identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceOptions : Instantiate DeleteInstanceOptions
func (*VpcV1) NewDeleteInstanceOptions(id string) *DeleteInstanceOptions {
	return &DeleteInstanceOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteInstanceOptions) SetID(id string) *DeleteInstanceOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceOptions) SetHeaders(param map[string]string) *DeleteInstanceOptions {
	options.Headers = param
	return options
}

// DeleteIpsecPolicyOptions : The DeleteIpsecPolicy options.
type DeleteIpsecPolicyOptions struct {
	// The IPsec policy identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteIpsecPolicyOptions : Instantiate DeleteIpsecPolicyOptions
func (*VpcV1) NewDeleteIpsecPolicyOptions(id string) *DeleteIpsecPolicyOptions {
	return &DeleteIpsecPolicyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteIpsecPolicyOptions) SetID(id string) *DeleteIpsecPolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteIpsecPolicyOptions) SetHeaders(param map[string]string) *DeleteIpsecPolicyOptions {
	options.Headers = param
	return options
}

// DeleteKeyOptions : The DeleteKey options.
type DeleteKeyOptions struct {
	// The key identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteKeyOptions : Instantiate DeleteKeyOptions
func (*VpcV1) NewDeleteKeyOptions(id string) *DeleteKeyOptions {
	return &DeleteKeyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteKeyOptions) SetID(id string) *DeleteKeyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteKeyOptions) SetHeaders(param map[string]string) *DeleteKeyOptions {
	options.Headers = param
	return options
}

// DeleteLoadBalancerListenerOptions : The DeleteLoadBalancerListener options.
type DeleteLoadBalancerListenerOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoadBalancerListenerOptions : Instantiate DeleteLoadBalancerListenerOptions
func (*VpcV1) NewDeleteLoadBalancerListenerOptions(loadBalancerID string, id string) *DeleteLoadBalancerListenerOptions {
	return &DeleteLoadBalancerListenerOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *DeleteLoadBalancerListenerOptions) SetLoadBalancerID(loadBalancerID string) *DeleteLoadBalancerListenerOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteLoadBalancerListenerOptions) SetID(id string) *DeleteLoadBalancerListenerOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoadBalancerListenerOptions) SetHeaders(param map[string]string) *DeleteLoadBalancerListenerOptions {
	options.Headers = param
	return options
}

// DeleteLoadBalancerListenerPolicyOptions : The DeleteLoadBalancerListenerPolicy options.
type DeleteLoadBalancerListenerPolicyOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// The policy identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoadBalancerListenerPolicyOptions : Instantiate DeleteLoadBalancerListenerPolicyOptions
func (*VpcV1) NewDeleteLoadBalancerListenerPolicyOptions(loadBalancerID string, listenerID string, id string) *DeleteLoadBalancerListenerPolicyOptions {
	return &DeleteLoadBalancerListenerPolicyOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *DeleteLoadBalancerListenerPolicyOptions) SetLoadBalancerID(loadBalancerID string) *DeleteLoadBalancerListenerPolicyOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *DeleteLoadBalancerListenerPolicyOptions) SetListenerID(listenerID string) *DeleteLoadBalancerListenerPolicyOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteLoadBalancerListenerPolicyOptions) SetID(id string) *DeleteLoadBalancerListenerPolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoadBalancerListenerPolicyOptions) SetHeaders(param map[string]string) *DeleteLoadBalancerListenerPolicyOptions {
	options.Headers = param
	return options
}

// DeleteLoadBalancerListenerPolicyRuleOptions : The DeleteLoadBalancerListenerPolicyRule options.
type DeleteLoadBalancerListenerPolicyRuleOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// The policy identifier.
	PolicyID *string `json:"policy_id" validate:"required"`

	// The rule identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoadBalancerListenerPolicyRuleOptions : Instantiate DeleteLoadBalancerListenerPolicyRuleOptions
func (*VpcV1) NewDeleteLoadBalancerListenerPolicyRuleOptions(loadBalancerID string, listenerID string, policyID string, id string) *DeleteLoadBalancerListenerPolicyRuleOptions {
	return &DeleteLoadBalancerListenerPolicyRuleOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		PolicyID:       core.StringPtr(policyID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *DeleteLoadBalancerListenerPolicyRuleOptions) SetLoadBalancerID(loadBalancerID string) *DeleteLoadBalancerListenerPolicyRuleOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *DeleteLoadBalancerListenerPolicyRuleOptions) SetListenerID(listenerID string) *DeleteLoadBalancerListenerPolicyRuleOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetPolicyID : Allow user to set PolicyID
func (options *DeleteLoadBalancerListenerPolicyRuleOptions) SetPolicyID(policyID string) *DeleteLoadBalancerListenerPolicyRuleOptions {
	options.PolicyID = core.StringPtr(policyID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteLoadBalancerListenerPolicyRuleOptions) SetID(id string) *DeleteLoadBalancerListenerPolicyRuleOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoadBalancerListenerPolicyRuleOptions) SetHeaders(param map[string]string) *DeleteLoadBalancerListenerPolicyRuleOptions {
	options.Headers = param
	return options
}

// DeleteLoadBalancerOptions : The DeleteLoadBalancer options.
type DeleteLoadBalancerOptions struct {
	// The load balancer identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoadBalancerOptions : Instantiate DeleteLoadBalancerOptions
func (*VpcV1) NewDeleteLoadBalancerOptions(id string) *DeleteLoadBalancerOptions {
	return &DeleteLoadBalancerOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteLoadBalancerOptions) SetID(id string) *DeleteLoadBalancerOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoadBalancerOptions) SetHeaders(param map[string]string) *DeleteLoadBalancerOptions {
	options.Headers = param
	return options
}

// DeleteLoadBalancerPoolMemberOptions : The DeleteLoadBalancerPoolMember options.
type DeleteLoadBalancerPoolMemberOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The pool identifier.
	PoolID *string `json:"pool_id" validate:"required"`

	// The member identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoadBalancerPoolMemberOptions : Instantiate DeleteLoadBalancerPoolMemberOptions
func (*VpcV1) NewDeleteLoadBalancerPoolMemberOptions(loadBalancerID string, poolID string, id string) *DeleteLoadBalancerPoolMemberOptions {
	return &DeleteLoadBalancerPoolMemberOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		PoolID:         core.StringPtr(poolID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *DeleteLoadBalancerPoolMemberOptions) SetLoadBalancerID(loadBalancerID string) *DeleteLoadBalancerPoolMemberOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetPoolID : Allow user to set PoolID
func (options *DeleteLoadBalancerPoolMemberOptions) SetPoolID(poolID string) *DeleteLoadBalancerPoolMemberOptions {
	options.PoolID = core.StringPtr(poolID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteLoadBalancerPoolMemberOptions) SetID(id string) *DeleteLoadBalancerPoolMemberOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoadBalancerPoolMemberOptions) SetHeaders(param map[string]string) *DeleteLoadBalancerPoolMemberOptions {
	options.Headers = param
	return options
}

// DeleteLoadBalancerPoolOptions : The DeleteLoadBalancerPool options.
type DeleteLoadBalancerPoolOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The pool identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoadBalancerPoolOptions : Instantiate DeleteLoadBalancerPoolOptions
func (*VpcV1) NewDeleteLoadBalancerPoolOptions(loadBalancerID string, id string) *DeleteLoadBalancerPoolOptions {
	return &DeleteLoadBalancerPoolOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *DeleteLoadBalancerPoolOptions) SetLoadBalancerID(loadBalancerID string) *DeleteLoadBalancerPoolOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteLoadBalancerPoolOptions) SetID(id string) *DeleteLoadBalancerPoolOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoadBalancerPoolOptions) SetHeaders(param map[string]string) *DeleteLoadBalancerPoolOptions {
	options.Headers = param
	return options
}

// DeleteNetworkAclOptions : The DeleteNetworkAcl options.
type DeleteNetworkAclOptions struct {
	// The network ACL identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteNetworkAclOptions : Instantiate DeleteNetworkAclOptions
func (*VpcV1) NewDeleteNetworkAclOptions(id string) *DeleteNetworkAclOptions {
	return &DeleteNetworkAclOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteNetworkAclOptions) SetID(id string) *DeleteNetworkAclOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteNetworkAclOptions) SetHeaders(param map[string]string) *DeleteNetworkAclOptions {
	options.Headers = param
	return options
}

// DeleteNetworkAclRuleOptions : The DeleteNetworkAclRule options.
type DeleteNetworkAclRuleOptions struct {
	// The network ACL identifier.
	NetworkAclID *string `json:"network_acl_id" validate:"required"`

	// The rule identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteNetworkAclRuleOptions : Instantiate DeleteNetworkAclRuleOptions
func (*VpcV1) NewDeleteNetworkAclRuleOptions(networkAclID string, id string) *DeleteNetworkAclRuleOptions {
	return &DeleteNetworkAclRuleOptions{
		NetworkAclID: core.StringPtr(networkAclID),
		ID:           core.StringPtr(id),
	}
}

// SetNetworkAclID : Allow user to set NetworkAclID
func (options *DeleteNetworkAclRuleOptions) SetNetworkAclID(networkAclID string) *DeleteNetworkAclRuleOptions {
	options.NetworkAclID = core.StringPtr(networkAclID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteNetworkAclRuleOptions) SetID(id string) *DeleteNetworkAclRuleOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteNetworkAclRuleOptions) SetHeaders(param map[string]string) *DeleteNetworkAclRuleOptions {
	options.Headers = param
	return options
}

// DeleteNetworkInterfaceFloatingIpBindingOptions : The DeleteNetworkInterfaceFloatingIpBinding options.
type DeleteNetworkInterfaceFloatingIpBindingOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required"`

	// The floating IP identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteNetworkInterfaceFloatingIpBindingOptions : Instantiate DeleteNetworkInterfaceFloatingIpBindingOptions
func (*VpcV1) NewDeleteNetworkInterfaceFloatingIpBindingOptions(instanceID string, networkInterfaceID string, id string) *DeleteNetworkInterfaceFloatingIpBindingOptions {
	return &DeleteNetworkInterfaceFloatingIpBindingOptions{
		InstanceID:         core.StringPtr(instanceID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
		ID:                 core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *DeleteNetworkInterfaceFloatingIpBindingOptions) SetInstanceID(instanceID string) *DeleteNetworkInterfaceFloatingIpBindingOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (options *DeleteNetworkInterfaceFloatingIpBindingOptions) SetNetworkInterfaceID(networkInterfaceID string) *DeleteNetworkInterfaceFloatingIpBindingOptions {
	options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteNetworkInterfaceFloatingIpBindingOptions) SetID(id string) *DeleteNetworkInterfaceFloatingIpBindingOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteNetworkInterfaceFloatingIpBindingOptions) SetHeaders(param map[string]string) *DeleteNetworkInterfaceFloatingIpBindingOptions {
	options.Headers = param
	return options
}

// DeleteNetworkInterfaceOptions : The DeleteNetworkInterface options.
type DeleteNetworkInterfaceOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The network interface identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteNetworkInterfaceOptions : Instantiate DeleteNetworkInterfaceOptions
func (*VpcV1) NewDeleteNetworkInterfaceOptions(instanceID string, id string) *DeleteNetworkInterfaceOptions {
	return &DeleteNetworkInterfaceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *DeleteNetworkInterfaceOptions) SetInstanceID(instanceID string) *DeleteNetworkInterfaceOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteNetworkInterfaceOptions) SetID(id string) *DeleteNetworkInterfaceOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteNetworkInterfaceOptions) SetHeaders(param map[string]string) *DeleteNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// DeletePublicGatewayOptions : The DeletePublicGateway options.
type DeletePublicGatewayOptions struct {
	// The public gateway identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeletePublicGatewayOptions : Instantiate DeletePublicGatewayOptions
func (*VpcV1) NewDeletePublicGatewayOptions(id string) *DeletePublicGatewayOptions {
	return &DeletePublicGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeletePublicGatewayOptions) SetID(id string) *DeletePublicGatewayOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeletePublicGatewayOptions) SetHeaders(param map[string]string) *DeletePublicGatewayOptions {
	options.Headers = param
	return options
}

// DeleteSecurityGroupNetworkInterfaceBindingOptions : The DeleteSecurityGroupNetworkInterfaceBinding options.
type DeleteSecurityGroupNetworkInterfaceBindingOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required"`

	// The network interface identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSecurityGroupNetworkInterfaceBindingOptions : Instantiate DeleteSecurityGroupNetworkInterfaceBindingOptions
func (*VpcV1) NewDeleteSecurityGroupNetworkInterfaceBindingOptions(securityGroupID string, id string) *DeleteSecurityGroupNetworkInterfaceBindingOptions {
	return &DeleteSecurityGroupNetworkInterfaceBindingOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (options *DeleteSecurityGroupNetworkInterfaceBindingOptions) SetSecurityGroupID(securityGroupID string) *DeleteSecurityGroupNetworkInterfaceBindingOptions {
	options.SecurityGroupID = core.StringPtr(securityGroupID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteSecurityGroupNetworkInterfaceBindingOptions) SetID(id string) *DeleteSecurityGroupNetworkInterfaceBindingOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSecurityGroupNetworkInterfaceBindingOptions) SetHeaders(param map[string]string) *DeleteSecurityGroupNetworkInterfaceBindingOptions {
	options.Headers = param
	return options
}

// DeleteSecurityGroupOptions : The DeleteSecurityGroup options.
type DeleteSecurityGroupOptions struct {
	// The security group identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSecurityGroupOptions : Instantiate DeleteSecurityGroupOptions
func (*VpcV1) NewDeleteSecurityGroupOptions(id string) *DeleteSecurityGroupOptions {
	return &DeleteSecurityGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteSecurityGroupOptions) SetID(id string) *DeleteSecurityGroupOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSecurityGroupOptions) SetHeaders(param map[string]string) *DeleteSecurityGroupOptions {
	options.Headers = param
	return options
}

// DeleteSecurityGroupRuleOptions : The DeleteSecurityGroupRule options.
type DeleteSecurityGroupRuleOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required"`

	// The rule identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSecurityGroupRuleOptions : Instantiate DeleteSecurityGroupRuleOptions
func (*VpcV1) NewDeleteSecurityGroupRuleOptions(securityGroupID string, id string) *DeleteSecurityGroupRuleOptions {
	return &DeleteSecurityGroupRuleOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (options *DeleteSecurityGroupRuleOptions) SetSecurityGroupID(securityGroupID string) *DeleteSecurityGroupRuleOptions {
	options.SecurityGroupID = core.StringPtr(securityGroupID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteSecurityGroupRuleOptions) SetID(id string) *DeleteSecurityGroupRuleOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSecurityGroupRuleOptions) SetHeaders(param map[string]string) *DeleteSecurityGroupRuleOptions {
	options.Headers = param
	return options
}

// DeleteSubnetOptions : The DeleteSubnet options.
type DeleteSubnetOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSubnetOptions : Instantiate DeleteSubnetOptions
func (*VpcV1) NewDeleteSubnetOptions(id string) *DeleteSubnetOptions {
	return &DeleteSubnetOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteSubnetOptions) SetID(id string) *DeleteSubnetOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSubnetOptions) SetHeaders(param map[string]string) *DeleteSubnetOptions {
	options.Headers = param
	return options
}

// DeleteSubnetPublicGatewayBindingOptions : The DeleteSubnetPublicGatewayBinding options.
type DeleteSubnetPublicGatewayBindingOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSubnetPublicGatewayBindingOptions : Instantiate DeleteSubnetPublicGatewayBindingOptions
func (*VpcV1) NewDeleteSubnetPublicGatewayBindingOptions(id string) *DeleteSubnetPublicGatewayBindingOptions {
	return &DeleteSubnetPublicGatewayBindingOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteSubnetPublicGatewayBindingOptions) SetID(id string) *DeleteSubnetPublicGatewayBindingOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSubnetPublicGatewayBindingOptions) SetHeaders(param map[string]string) *DeleteSubnetPublicGatewayBindingOptions {
	options.Headers = param
	return options
}

// DeleteVolumeAttachmentOptions : The DeleteVolumeAttachment options.
type DeleteVolumeAttachmentOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The volume attachment identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVolumeAttachmentOptions : Instantiate DeleteVolumeAttachmentOptions
func (*VpcV1) NewDeleteVolumeAttachmentOptions(instanceID string, id string) *DeleteVolumeAttachmentOptions {
	return &DeleteVolumeAttachmentOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *DeleteVolumeAttachmentOptions) SetInstanceID(instanceID string) *DeleteVolumeAttachmentOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteVolumeAttachmentOptions) SetID(id string) *DeleteVolumeAttachmentOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVolumeAttachmentOptions) SetHeaders(param map[string]string) *DeleteVolumeAttachmentOptions {
	options.Headers = param
	return options
}

// DeleteVolumeOptions : The DeleteVolume options.
type DeleteVolumeOptions struct {
	// The volume identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVolumeOptions : Instantiate DeleteVolumeOptions
func (*VpcV1) NewDeleteVolumeOptions(id string) *DeleteVolumeOptions {
	return &DeleteVolumeOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteVolumeOptions) SetID(id string) *DeleteVolumeOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVolumeOptions) SetHeaders(param map[string]string) *DeleteVolumeOptions {
	options.Headers = param
	return options
}

// DeleteVpcAddressPrefixOptions : The DeleteVpcAddressPrefix options.
type DeleteVpcAddressPrefixOptions struct {
	// The VPC identifier.
	VpcID *string `json:"vpc_id" validate:"required"`

	// The prefix identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVpcAddressPrefixOptions : Instantiate DeleteVpcAddressPrefixOptions
func (*VpcV1) NewDeleteVpcAddressPrefixOptions(vpcID string, id string) *DeleteVpcAddressPrefixOptions {
	return &DeleteVpcAddressPrefixOptions{
		VpcID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVpcID : Allow user to set VpcID
func (options *DeleteVpcAddressPrefixOptions) SetVpcID(vpcID string) *DeleteVpcAddressPrefixOptions {
	options.VpcID = core.StringPtr(vpcID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteVpcAddressPrefixOptions) SetID(id string) *DeleteVpcAddressPrefixOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVpcAddressPrefixOptions) SetHeaders(param map[string]string) *DeleteVpcAddressPrefixOptions {
	options.Headers = param
	return options
}

// DeleteVpcOptions : The DeleteVpc options.
type DeleteVpcOptions struct {
	// The VPC identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVpcOptions : Instantiate DeleteVpcOptions
func (*VpcV1) NewDeleteVpcOptions(id string) *DeleteVpcOptions {
	return &DeleteVpcOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteVpcOptions) SetID(id string) *DeleteVpcOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVpcOptions) SetHeaders(param map[string]string) *DeleteVpcOptions {
	options.Headers = param
	return options
}

// DeleteVpcRouteOptions : The DeleteVpcRoute options.
type DeleteVpcRouteOptions struct {
	// The VPC identifier.
	VpcID *string `json:"vpc_id" validate:"required"`

	// The route identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVpcRouteOptions : Instantiate DeleteVpcRouteOptions
func (*VpcV1) NewDeleteVpcRouteOptions(vpcID string, id string) *DeleteVpcRouteOptions {
	return &DeleteVpcRouteOptions{
		VpcID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVpcID : Allow user to set VpcID
func (options *DeleteVpcRouteOptions) SetVpcID(vpcID string) *DeleteVpcRouteOptions {
	options.VpcID = core.StringPtr(vpcID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteVpcRouteOptions) SetID(id string) *DeleteVpcRouteOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVpcRouteOptions) SetHeaders(param map[string]string) *DeleteVpcRouteOptions {
	options.Headers = param
	return options
}

// DeleteVpnGatewayConnectionLocalCidrOptions : The DeleteVpnGatewayConnectionLocalCidr options.
type DeleteVpnGatewayConnectionLocalCidrOptions struct {
	// The VPN gateway identifier.
	VpnGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// The prefix address part of the CIDR.
	PrefixAddress *string `json:"prefix_address" validate:"required"`

	// The prefix length part of the CIDR.
	PrefixLength *string `json:"prefix_length" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVpnGatewayConnectionLocalCidrOptions : Instantiate DeleteVpnGatewayConnectionLocalCidrOptions
func (*VpcV1) NewDeleteVpnGatewayConnectionLocalCidrOptions(vpnGatewayID string, id string, prefixAddress string, prefixLength string) *DeleteVpnGatewayConnectionLocalCidrOptions {
	return &DeleteVpnGatewayConnectionLocalCidrOptions{
		VpnGatewayID:  core.StringPtr(vpnGatewayID),
		ID:            core.StringPtr(id),
		PrefixAddress: core.StringPtr(prefixAddress),
		PrefixLength:  core.StringPtr(prefixLength),
	}
}

// SetVpnGatewayID : Allow user to set VpnGatewayID
func (options *DeleteVpnGatewayConnectionLocalCidrOptions) SetVpnGatewayID(vpnGatewayID string) *DeleteVpnGatewayConnectionLocalCidrOptions {
	options.VpnGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteVpnGatewayConnectionLocalCidrOptions) SetID(id string) *DeleteVpnGatewayConnectionLocalCidrOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetPrefixAddress : Allow user to set PrefixAddress
func (options *DeleteVpnGatewayConnectionLocalCidrOptions) SetPrefixAddress(prefixAddress string) *DeleteVpnGatewayConnectionLocalCidrOptions {
	options.PrefixAddress = core.StringPtr(prefixAddress)
	return options
}

// SetPrefixLength : Allow user to set PrefixLength
func (options *DeleteVpnGatewayConnectionLocalCidrOptions) SetPrefixLength(prefixLength string) *DeleteVpnGatewayConnectionLocalCidrOptions {
	options.PrefixLength = core.StringPtr(prefixLength)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVpnGatewayConnectionLocalCidrOptions) SetHeaders(param map[string]string) *DeleteVpnGatewayConnectionLocalCidrOptions {
	options.Headers = param
	return options
}

// DeleteVpnGatewayConnectionOptions : The DeleteVpnGatewayConnection options.
type DeleteVpnGatewayConnectionOptions struct {
	// The VPN gateway identifier.
	VpnGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVpnGatewayConnectionOptions : Instantiate DeleteVpnGatewayConnectionOptions
func (*VpcV1) NewDeleteVpnGatewayConnectionOptions(vpnGatewayID string, id string) *DeleteVpnGatewayConnectionOptions {
	return &DeleteVpnGatewayConnectionOptions{
		VpnGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
	}
}

// SetVpnGatewayID : Allow user to set VpnGatewayID
func (options *DeleteVpnGatewayConnectionOptions) SetVpnGatewayID(vpnGatewayID string) *DeleteVpnGatewayConnectionOptions {
	options.VpnGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteVpnGatewayConnectionOptions) SetID(id string) *DeleteVpnGatewayConnectionOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVpnGatewayConnectionOptions) SetHeaders(param map[string]string) *DeleteVpnGatewayConnectionOptions {
	options.Headers = param
	return options
}

// DeleteVpnGatewayConnectionPeerCidrOptions : The DeleteVpnGatewayConnectionPeerCidr options.
type DeleteVpnGatewayConnectionPeerCidrOptions struct {
	// The VPN gateway identifier.
	VpnGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// The prefix address part of the CIDR.
	PrefixAddress *string `json:"prefix_address" validate:"required"`

	// The prefix length part of the CIDR.
	PrefixLength *string `json:"prefix_length" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVpnGatewayConnectionPeerCidrOptions : Instantiate DeleteVpnGatewayConnectionPeerCidrOptions
func (*VpcV1) NewDeleteVpnGatewayConnectionPeerCidrOptions(vpnGatewayID string, id string, prefixAddress string, prefixLength string) *DeleteVpnGatewayConnectionPeerCidrOptions {
	return &DeleteVpnGatewayConnectionPeerCidrOptions{
		VpnGatewayID:  core.StringPtr(vpnGatewayID),
		ID:            core.StringPtr(id),
		PrefixAddress: core.StringPtr(prefixAddress),
		PrefixLength:  core.StringPtr(prefixLength),
	}
}

// SetVpnGatewayID : Allow user to set VpnGatewayID
func (options *DeleteVpnGatewayConnectionPeerCidrOptions) SetVpnGatewayID(vpnGatewayID string) *DeleteVpnGatewayConnectionPeerCidrOptions {
	options.VpnGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteVpnGatewayConnectionPeerCidrOptions) SetID(id string) *DeleteVpnGatewayConnectionPeerCidrOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetPrefixAddress : Allow user to set PrefixAddress
func (options *DeleteVpnGatewayConnectionPeerCidrOptions) SetPrefixAddress(prefixAddress string) *DeleteVpnGatewayConnectionPeerCidrOptions {
	options.PrefixAddress = core.StringPtr(prefixAddress)
	return options
}

// SetPrefixLength : Allow user to set PrefixLength
func (options *DeleteVpnGatewayConnectionPeerCidrOptions) SetPrefixLength(prefixLength string) *DeleteVpnGatewayConnectionPeerCidrOptions {
	options.PrefixLength = core.StringPtr(prefixLength)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVpnGatewayConnectionPeerCidrOptions) SetHeaders(param map[string]string) *DeleteVpnGatewayConnectionPeerCidrOptions {
	options.Headers = param
	return options
}

// DeleteVpnGatewayOptions : The DeleteVpnGateway options.
type DeleteVpnGatewayOptions struct {
	// The VPN gateway identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVpnGatewayOptions : Instantiate DeleteVpnGatewayOptions
func (*VpcV1) NewDeleteVpnGatewayOptions(id string) *DeleteVpnGatewayOptions {
	return &DeleteVpnGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteVpnGatewayOptions) SetID(id string) *DeleteVpnGatewayOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVpnGatewayOptions) SetHeaders(param map[string]string) *DeleteVpnGatewayOptions {
	options.Headers = param
	return options
}

// FloatingIP : FloatingIP struct
type FloatingIP struct {
	// The globally unique IP address.
	Address *string `json:"address" validate:"required"`

	// The date and time that the floating IP was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this floating IP.
	Crn *string `json:"crn" validate:"required"`

	// The URL for this floating IPs.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this floating IP.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this floating IP.
	Name *string `json:"name" validate:"required"`

	// The resource group for this floating IP.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The status of the floating IP.
	Status *string `json:"status" validate:"required"`

	// The target of this floating IP.
	Target FloatingIPTargetIntf `json:"target,omitempty"`

	// The zone the floating IP resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the FloatingIP.Status property.
// The status of the floating IP.
const (
	FloatingIP_Status_Available = "available"
	FloatingIP_Status_Deleting  = "deleting"
	FloatingIP_Status_Failed    = "failed"
	FloatingIP_Status_Pending   = "pending"
)

// UnmarshalFloatingIP constructs an instance of FloatingIP from the specified map.
func UnmarshalFloatingIP(m map[string]interface{}) (result *FloatingIP, err error) {
	obj := new(FloatingIP)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupReferenceAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Status, err = core.UnmarshalString(m, "status")
	if err != nil {
		return
	}
	obj.Target, err = UnmarshalFloatingIPTargetAsProperty(m, "target")
	if err != nil {
		return
	}
	obj.Zone, err = UnmarshalZoneReferenceAsProperty(m, "zone")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalFloatingIPSlice unmarshals a slice of FloatingIP instances from the specified list of maps.
func UnmarshalFloatingIPSlice(s []interface{}) (slice []FloatingIP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'FloatingIP'")
			return
		}
		obj, e := UnmarshalFloatingIP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalFloatingIPAsProperty unmarshals an instance of FloatingIP that is stored as a property
// within the specified map.
func UnmarshalFloatingIPAsProperty(m map[string]interface{}, propertyName string) (result *FloatingIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'FloatingIP'", propertyName)
			return
		}
		result, err = UnmarshalFloatingIP(objMap)
	}
	return
}

// UnmarshalFloatingIPSliceAsProperty unmarshals a slice of FloatingIP instances that are stored as a property
// within the specified map.
func UnmarshalFloatingIPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []FloatingIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'FloatingIP'", propertyName)
			return
		}
		slice, err = UnmarshalFloatingIPSlice(vSlice)
	}
	return
}

// FloatingIPCollection : FloatingIPCollection struct
type FloatingIPCollection struct {
	// A reference to the first page of resources.
	First *FloatingIPCollectionFirst `json:"first" validate:"required"`

	// Collection of floating IPs.
	FloatingIps []FloatingIP `json:"floating_ips" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *FloatingIPCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalFloatingIPCollection constructs an instance of FloatingIPCollection from the specified map.
func UnmarshalFloatingIPCollection(m map[string]interface{}) (result *FloatingIPCollection, err error) {
	obj := new(FloatingIPCollection)
	obj.First, err = UnmarshalFloatingIPCollectionFirstAsProperty(m, "first")
	if err != nil {
		return
	}
	obj.FloatingIps, err = UnmarshalFloatingIPSliceAsProperty(m, "floating_ips")
	if err != nil {
		return
	}
	obj.Limit, err = core.UnmarshalInt64(m, "limit")
	if err != nil {
		return
	}
	obj.Next, err = UnmarshalFloatingIPCollectionNextAsProperty(m, "next")
	if err != nil {
		return
	}
	obj.TotalCount, err = core.UnmarshalInt64(m, "total_count")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalFloatingIPCollectionSlice unmarshals a slice of FloatingIPCollection instances from the specified list of maps.
func UnmarshalFloatingIPCollectionSlice(s []interface{}) (slice []FloatingIPCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'FloatingIPCollection'")
			return
		}
		obj, e := UnmarshalFloatingIPCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalFloatingIPCollectionAsProperty unmarshals an instance of FloatingIPCollection that is stored as a property
// within the specified map.
func UnmarshalFloatingIPCollectionAsProperty(m map[string]interface{}, propertyName string) (result *FloatingIPCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'FloatingIPCollection'", propertyName)
			return
		}
		result, err = UnmarshalFloatingIPCollection(objMap)
	}
	return
}

// UnmarshalFloatingIPCollectionSliceAsProperty unmarshals a slice of FloatingIPCollection instances that are stored as a property
// within the specified map.
func UnmarshalFloatingIPCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []FloatingIPCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'FloatingIPCollection'", propertyName)
			return
		}
		slice, err = UnmarshalFloatingIPCollectionSlice(vSlice)
	}
	return
}

// FloatingIPCollectionFirst : A reference to the first page of resources.
type FloatingIPCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalFloatingIPCollectionFirst constructs an instance of FloatingIPCollectionFirst from the specified map.
func UnmarshalFloatingIPCollectionFirst(m map[string]interface{}) (result *FloatingIPCollectionFirst, err error) {
	obj := new(FloatingIPCollectionFirst)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalFloatingIPCollectionFirstSlice unmarshals a slice of FloatingIPCollectionFirst instances from the specified list of maps.
func UnmarshalFloatingIPCollectionFirstSlice(s []interface{}) (slice []FloatingIPCollectionFirst, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'FloatingIPCollectionFirst'")
			return
		}
		obj, e := UnmarshalFloatingIPCollectionFirst(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalFloatingIPCollectionFirstAsProperty unmarshals an instance of FloatingIPCollectionFirst that is stored as a property
// within the specified map.
func UnmarshalFloatingIPCollectionFirstAsProperty(m map[string]interface{}, propertyName string) (result *FloatingIPCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'FloatingIPCollectionFirst'", propertyName)
			return
		}
		result, err = UnmarshalFloatingIPCollectionFirst(objMap)
	}
	return
}

// UnmarshalFloatingIPCollectionFirstSliceAsProperty unmarshals a slice of FloatingIPCollectionFirst instances that are stored as a property
// within the specified map.
func UnmarshalFloatingIPCollectionFirstSliceAsProperty(m map[string]interface{}, propertyName string) (slice []FloatingIPCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'FloatingIPCollectionFirst'", propertyName)
			return
		}
		slice, err = UnmarshalFloatingIPCollectionFirstSlice(vSlice)
	}
	return
}

// FloatingIPCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type FloatingIPCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalFloatingIPCollectionNext constructs an instance of FloatingIPCollectionNext from the specified map.
func UnmarshalFloatingIPCollectionNext(m map[string]interface{}) (result *FloatingIPCollectionNext, err error) {
	obj := new(FloatingIPCollectionNext)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalFloatingIPCollectionNextSlice unmarshals a slice of FloatingIPCollectionNext instances from the specified list of maps.
func UnmarshalFloatingIPCollectionNextSlice(s []interface{}) (slice []FloatingIPCollectionNext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'FloatingIPCollectionNext'")
			return
		}
		obj, e := UnmarshalFloatingIPCollectionNext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalFloatingIPCollectionNextAsProperty unmarshals an instance of FloatingIPCollectionNext that is stored as a property
// within the specified map.
func UnmarshalFloatingIPCollectionNextAsProperty(m map[string]interface{}, propertyName string) (result *FloatingIPCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'FloatingIPCollectionNext'", propertyName)
			return
		}
		result, err = UnmarshalFloatingIPCollectionNext(objMap)
	}
	return
}

// UnmarshalFloatingIPCollectionNextSliceAsProperty unmarshals a slice of FloatingIPCollectionNext instances that are stored as a property
// within the specified map.
func UnmarshalFloatingIPCollectionNextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []FloatingIPCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'FloatingIPCollectionNext'", propertyName)
			return
		}
		slice, err = UnmarshalFloatingIPCollectionNextSlice(vSlice)
	}
	return
}

// FloatingIPPrototype : FloatingIPPrototype struct
// Models which "extend" this model:
// - FloatingIPPrototypeFloatingIPByZone
// - FloatingIPPrototypeFloatingIPByTarget
type FloatingIPPrototype struct {
	// The unique user-defined name for this floating IP. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The identity of the zone to provision a floating IP in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`

	// The target this address is to be bound to.
	Target NetworkInterfaceIdentityIntf `json:"target,omitempty"`
}

func (*FloatingIPPrototype) isaFloatingIPPrototype() bool {
	return true
}

type FloatingIPPrototypeIntf interface {
	isaFloatingIPPrototype() bool
}

// UnmarshalFloatingIPPrototype constructs an instance of FloatingIPPrototype from the specified map.
func UnmarshalFloatingIPPrototype(m map[string]interface{}) (result FloatingIPPrototypeIntf, err error) {
	obj := new(FloatingIPPrototype)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupIdentityAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Zone, err = UnmarshalZoneIdentityAsProperty(m, "zone")
	if err != nil {
		return
	}
	obj.Target, err = UnmarshalNetworkInterfaceIdentityAsProperty(m, "target")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalFloatingIPPrototypeSlice unmarshals a slice of FloatingIPPrototype instances from the specified list of maps.
func UnmarshalFloatingIPPrototypeSlice(s []interface{}) (slice []FloatingIPPrototypeIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'FloatingIPPrototype'")
			return
		}
		obj, e := UnmarshalFloatingIPPrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalFloatingIPPrototypeAsProperty unmarshals an instance of FloatingIPPrototype that is stored as a property
// within the specified map.
func UnmarshalFloatingIPPrototypeAsProperty(m map[string]interface{}, propertyName string) (result FloatingIPPrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'FloatingIPPrototype'", propertyName)
			return
		}
		result, err = UnmarshalFloatingIPPrototype(objMap)
	}
	return
}

// UnmarshalFloatingIPPrototypeSliceAsProperty unmarshals a slice of FloatingIPPrototype instances that are stored as a property
// within the specified map.
func UnmarshalFloatingIPPrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []FloatingIPPrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'FloatingIPPrototype'", propertyName)
			return
		}
		slice, err = UnmarshalFloatingIPPrototypeSlice(vSlice)
	}
	return
}

// FloatingIPReference : FloatingIPReference struct
type FloatingIPReference struct {
	// The globally unique IP address.
	Address *string `json:"address" validate:"required"`

	// The CRN for this floating IP.
	Crn *string `json:"crn" validate:"required"`

	// The URL for this floating IPs.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this floating IP.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this floating IP.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalFloatingIPReference constructs an instance of FloatingIPReference from the specified map.
func UnmarshalFloatingIPReference(m map[string]interface{}) (result *FloatingIPReference, err error) {
	obj := new(FloatingIPReference)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalFloatingIPReferenceSlice unmarshals a slice of FloatingIPReference instances from the specified list of maps.
func UnmarshalFloatingIPReferenceSlice(s []interface{}) (slice []FloatingIPReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'FloatingIPReference'")
			return
		}
		obj, e := UnmarshalFloatingIPReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalFloatingIPReferenceAsProperty unmarshals an instance of FloatingIPReference that is stored as a property
// within the specified map.
func UnmarshalFloatingIPReferenceAsProperty(m map[string]interface{}, propertyName string) (result *FloatingIPReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'FloatingIPReference'", propertyName)
			return
		}
		result, err = UnmarshalFloatingIPReference(objMap)
	}
	return
}

// UnmarshalFloatingIPReferenceSliceAsProperty unmarshals a slice of FloatingIPReference instances that are stored as a property
// within the specified map.
func UnmarshalFloatingIPReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []FloatingIPReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'FloatingIPReference'", propertyName)
			return
		}
		slice, err = UnmarshalFloatingIPReferenceSlice(vSlice)
	}
	return
}

// FloatingIPTarget : The target of this floating IP.
// Models which "extend" this model:
// - FloatingIPTargetNetworkInterfaceReference
// - FloatingIPTargetPublicGatewayReference
type FloatingIPTarget struct {
	// The URL for this network interface.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this network interface.
	ID *string `json:"id,omitempty"`

	// The user-defined name for this network interface.
	Name *string `json:"name,omitempty"`

	// The primary IPv4 address.
	PrimaryIpv4Address *string `json:"primary_ipv4_address,omitempty"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type,omitempty"`

	// The CRN for this public gateway.
	Crn *string `json:"crn,omitempty"`
}

// Constants associated with the FloatingIPTarget.ResourceType property.
// The type of resource referenced.
const (
	FloatingIPTarget_ResourceType_NetworkInterface = "network_interface"
)

func (*FloatingIPTarget) isaFloatingIPTarget() bool {
	return true
}

type FloatingIPTargetIntf interface {
	isaFloatingIPTarget() bool
}

// UnmarshalFloatingIPTarget constructs an instance of FloatingIPTarget from the specified map.
func UnmarshalFloatingIPTarget(m map[string]interface{}) (result FloatingIPTargetIntf, err error) {
	obj := new(FloatingIPTarget)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.PrimaryIpv4Address, err = core.UnmarshalString(m, "primary_ipv4_address")
	if err != nil {
		return
	}
	obj.ResourceType, err = core.UnmarshalString(m, "resource_type")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalFloatingIPTargetSlice unmarshals a slice of FloatingIPTarget instances from the specified list of maps.
func UnmarshalFloatingIPTargetSlice(s []interface{}) (slice []FloatingIPTargetIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'FloatingIPTarget'")
			return
		}
		obj, e := UnmarshalFloatingIPTarget(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalFloatingIPTargetAsProperty unmarshals an instance of FloatingIPTarget that is stored as a property
// within the specified map.
func UnmarshalFloatingIPTargetAsProperty(m map[string]interface{}, propertyName string) (result FloatingIPTargetIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'FloatingIPTarget'", propertyName)
			return
		}
		result, err = UnmarshalFloatingIPTarget(objMap)
	}
	return
}

// UnmarshalFloatingIPTargetSliceAsProperty unmarshals a slice of FloatingIPTarget instances that are stored as a property
// within the specified map.
func UnmarshalFloatingIPTargetSliceAsProperty(m map[string]interface{}, propertyName string) (slice []FloatingIPTargetIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'FloatingIPTarget'", propertyName)
			return
		}
		slice, err = UnmarshalFloatingIPTargetSlice(vSlice)
	}
	return
}

// FloatingIPUnpaginatedCollection : FloatingIPUnpaginatedCollection struct
type FloatingIPUnpaginatedCollection struct {
	// Collection of floating IPs.
	FloatingIps []FloatingIP `json:"floating_ips" validate:"required"`
}

// UnmarshalFloatingIPUnpaginatedCollection constructs an instance of FloatingIPUnpaginatedCollection from the specified map.
func UnmarshalFloatingIPUnpaginatedCollection(m map[string]interface{}) (result *FloatingIPUnpaginatedCollection, err error) {
	obj := new(FloatingIPUnpaginatedCollection)
	obj.FloatingIps, err = UnmarshalFloatingIPSliceAsProperty(m, "floating_ips")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalFloatingIPUnpaginatedCollectionSlice unmarshals a slice of FloatingIPUnpaginatedCollection instances from the specified list of maps.
func UnmarshalFloatingIPUnpaginatedCollectionSlice(s []interface{}) (slice []FloatingIPUnpaginatedCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'FloatingIPUnpaginatedCollection'")
			return
		}
		obj, e := UnmarshalFloatingIPUnpaginatedCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalFloatingIPUnpaginatedCollectionAsProperty unmarshals an instance of FloatingIPUnpaginatedCollection that is stored as a property
// within the specified map.
func UnmarshalFloatingIPUnpaginatedCollectionAsProperty(m map[string]interface{}, propertyName string) (result *FloatingIPUnpaginatedCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'FloatingIPUnpaginatedCollection'", propertyName)
			return
		}
		result, err = UnmarshalFloatingIPUnpaginatedCollection(objMap)
	}
	return
}

// UnmarshalFloatingIPUnpaginatedCollectionSliceAsProperty unmarshals a slice of FloatingIPUnpaginatedCollection instances that are stored as a property
// within the specified map.
func UnmarshalFloatingIPUnpaginatedCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []FloatingIPUnpaginatedCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'FloatingIPUnpaginatedCollection'", propertyName)
			return
		}
		slice, err = UnmarshalFloatingIPUnpaginatedCollectionSlice(vSlice)
	}
	return
}

// GetFloatingIpOptions : The GetFloatingIp options.
type GetFloatingIpOptions struct {
	// The floating IP identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetFloatingIpOptions : Instantiate GetFloatingIpOptions
func (*VpcV1) NewGetFloatingIpOptions(id string) *GetFloatingIpOptions {
	return &GetFloatingIpOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetFloatingIpOptions) SetID(id string) *GetFloatingIpOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetFloatingIpOptions) SetHeaders(param map[string]string) *GetFloatingIpOptions {
	options.Headers = param
	return options
}

// GetIkePolicyOptions : The GetIkePolicy options.
type GetIkePolicyOptions struct {
	// The IKE policy identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetIkePolicyOptions : Instantiate GetIkePolicyOptions
func (*VpcV1) NewGetIkePolicyOptions(id string) *GetIkePolicyOptions {
	return &GetIkePolicyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetIkePolicyOptions) SetID(id string) *GetIkePolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetIkePolicyOptions) SetHeaders(param map[string]string) *GetIkePolicyOptions {
	options.Headers = param
	return options
}

// GetImageOptions : The GetImage options.
type GetImageOptions struct {
	// The image identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetImageOptions : Instantiate GetImageOptions
func (*VpcV1) NewGetImageOptions(id string) *GetImageOptions {
	return &GetImageOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetImageOptions) SetID(id string) *GetImageOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetImageOptions) SetHeaders(param map[string]string) *GetImageOptions {
	options.Headers = param
	return options
}

// GetInstanceInitializationOptions : The GetInstanceInitialization options.
type GetInstanceInitializationOptions struct {
	// The instance identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceInitializationOptions : Instantiate GetInstanceInitializationOptions
func (*VpcV1) NewGetInstanceInitializationOptions(id string) *GetInstanceInitializationOptions {
	return &GetInstanceInitializationOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetInstanceInitializationOptions) SetID(id string) *GetInstanceInitializationOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceInitializationOptions) SetHeaders(param map[string]string) *GetInstanceInitializationOptions {
	options.Headers = param
	return options
}

// GetInstanceOptions : The GetInstance options.
type GetInstanceOptions struct {
	// The instance identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceOptions : Instantiate GetInstanceOptions
func (*VpcV1) NewGetInstanceOptions(id string) *GetInstanceOptions {
	return &GetInstanceOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetInstanceOptions) SetID(id string) *GetInstanceOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceOptions) SetHeaders(param map[string]string) *GetInstanceOptions {
	options.Headers = param
	return options
}

// GetInstanceProfileOptions : The GetInstanceProfile options.
type GetInstanceProfileOptions struct {
	// The instance profile name.
	Name *string `json:"name" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceProfileOptions : Instantiate GetInstanceProfileOptions
func (*VpcV1) NewGetInstanceProfileOptions(name string) *GetInstanceProfileOptions {
	return &GetInstanceProfileOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (options *GetInstanceProfileOptions) SetName(name string) *GetInstanceProfileOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceProfileOptions) SetHeaders(param map[string]string) *GetInstanceProfileOptions {
	options.Headers = param
	return options
}

// GetIpsecPolicyOptions : The GetIpsecPolicy options.
type GetIpsecPolicyOptions struct {
	// The IPsec policy identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetIpsecPolicyOptions : Instantiate GetIpsecPolicyOptions
func (*VpcV1) NewGetIpsecPolicyOptions(id string) *GetIpsecPolicyOptions {
	return &GetIpsecPolicyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetIpsecPolicyOptions) SetID(id string) *GetIpsecPolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetIpsecPolicyOptions) SetHeaders(param map[string]string) *GetIpsecPolicyOptions {
	options.Headers = param
	return options
}

// GetKeyOptions : The GetKey options.
type GetKeyOptions struct {
	// The key identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetKeyOptions : Instantiate GetKeyOptions
func (*VpcV1) NewGetKeyOptions(id string) *GetKeyOptions {
	return &GetKeyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetKeyOptions) SetID(id string) *GetKeyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetKeyOptions) SetHeaders(param map[string]string) *GetKeyOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerListenerOptions : The GetLoadBalancerListener options.
type GetLoadBalancerListenerOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerListenerOptions : Instantiate GetLoadBalancerListenerOptions
func (*VpcV1) NewGetLoadBalancerListenerOptions(loadBalancerID string, id string) *GetLoadBalancerListenerOptions {
	return &GetLoadBalancerListenerOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *GetLoadBalancerListenerOptions) SetLoadBalancerID(loadBalancerID string) *GetLoadBalancerListenerOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetID : Allow user to set ID
func (options *GetLoadBalancerListenerOptions) SetID(id string) *GetLoadBalancerListenerOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerListenerOptions) SetHeaders(param map[string]string) *GetLoadBalancerListenerOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerListenerPolicyOptions : The GetLoadBalancerListenerPolicy options.
type GetLoadBalancerListenerPolicyOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// The policy identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerListenerPolicyOptions : Instantiate GetLoadBalancerListenerPolicyOptions
func (*VpcV1) NewGetLoadBalancerListenerPolicyOptions(loadBalancerID string, listenerID string, id string) *GetLoadBalancerListenerPolicyOptions {
	return &GetLoadBalancerListenerPolicyOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *GetLoadBalancerListenerPolicyOptions) SetLoadBalancerID(loadBalancerID string) *GetLoadBalancerListenerPolicyOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *GetLoadBalancerListenerPolicyOptions) SetListenerID(listenerID string) *GetLoadBalancerListenerPolicyOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetID : Allow user to set ID
func (options *GetLoadBalancerListenerPolicyOptions) SetID(id string) *GetLoadBalancerListenerPolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerListenerPolicyOptions) SetHeaders(param map[string]string) *GetLoadBalancerListenerPolicyOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerListenerPolicyRuleOptions : The GetLoadBalancerListenerPolicyRule options.
type GetLoadBalancerListenerPolicyRuleOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// The policy identifier.
	PolicyID *string `json:"policy_id" validate:"required"`

	// The rule identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerListenerPolicyRuleOptions : Instantiate GetLoadBalancerListenerPolicyRuleOptions
func (*VpcV1) NewGetLoadBalancerListenerPolicyRuleOptions(loadBalancerID string, listenerID string, policyID string, id string) *GetLoadBalancerListenerPolicyRuleOptions {
	return &GetLoadBalancerListenerPolicyRuleOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		PolicyID:       core.StringPtr(policyID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *GetLoadBalancerListenerPolicyRuleOptions) SetLoadBalancerID(loadBalancerID string) *GetLoadBalancerListenerPolicyRuleOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *GetLoadBalancerListenerPolicyRuleOptions) SetListenerID(listenerID string) *GetLoadBalancerListenerPolicyRuleOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetPolicyID : Allow user to set PolicyID
func (options *GetLoadBalancerListenerPolicyRuleOptions) SetPolicyID(policyID string) *GetLoadBalancerListenerPolicyRuleOptions {
	options.PolicyID = core.StringPtr(policyID)
	return options
}

// SetID : Allow user to set ID
func (options *GetLoadBalancerListenerPolicyRuleOptions) SetID(id string) *GetLoadBalancerListenerPolicyRuleOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerListenerPolicyRuleOptions) SetHeaders(param map[string]string) *GetLoadBalancerListenerPolicyRuleOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerOptions : The GetLoadBalancer options.
type GetLoadBalancerOptions struct {
	// The load balancer identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerOptions : Instantiate GetLoadBalancerOptions
func (*VpcV1) NewGetLoadBalancerOptions(id string) *GetLoadBalancerOptions {
	return &GetLoadBalancerOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetLoadBalancerOptions) SetID(id string) *GetLoadBalancerOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerOptions) SetHeaders(param map[string]string) *GetLoadBalancerOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerPoolMemberOptions : The GetLoadBalancerPoolMember options.
type GetLoadBalancerPoolMemberOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The pool identifier.
	PoolID *string `json:"pool_id" validate:"required"`

	// The member identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerPoolMemberOptions : Instantiate GetLoadBalancerPoolMemberOptions
func (*VpcV1) NewGetLoadBalancerPoolMemberOptions(loadBalancerID string, poolID string, id string) *GetLoadBalancerPoolMemberOptions {
	return &GetLoadBalancerPoolMemberOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		PoolID:         core.StringPtr(poolID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *GetLoadBalancerPoolMemberOptions) SetLoadBalancerID(loadBalancerID string) *GetLoadBalancerPoolMemberOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetPoolID : Allow user to set PoolID
func (options *GetLoadBalancerPoolMemberOptions) SetPoolID(poolID string) *GetLoadBalancerPoolMemberOptions {
	options.PoolID = core.StringPtr(poolID)
	return options
}

// SetID : Allow user to set ID
func (options *GetLoadBalancerPoolMemberOptions) SetID(id string) *GetLoadBalancerPoolMemberOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerPoolMemberOptions) SetHeaders(param map[string]string) *GetLoadBalancerPoolMemberOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerPoolOptions : The GetLoadBalancerPool options.
type GetLoadBalancerPoolOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The pool identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerPoolOptions : Instantiate GetLoadBalancerPoolOptions
func (*VpcV1) NewGetLoadBalancerPoolOptions(loadBalancerID string, id string) *GetLoadBalancerPoolOptions {
	return &GetLoadBalancerPoolOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *GetLoadBalancerPoolOptions) SetLoadBalancerID(loadBalancerID string) *GetLoadBalancerPoolOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetID : Allow user to set ID
func (options *GetLoadBalancerPoolOptions) SetID(id string) *GetLoadBalancerPoolOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerPoolOptions) SetHeaders(param map[string]string) *GetLoadBalancerPoolOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerStatisticsOptions : The GetLoadBalancerStatistics options.
type GetLoadBalancerStatisticsOptions struct {
	// The load balancer identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerStatisticsOptions : Instantiate GetLoadBalancerStatisticsOptions
func (*VpcV1) NewGetLoadBalancerStatisticsOptions(id string) *GetLoadBalancerStatisticsOptions {
	return &GetLoadBalancerStatisticsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetLoadBalancerStatisticsOptions) SetID(id string) *GetLoadBalancerStatisticsOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerStatisticsOptions) SetHeaders(param map[string]string) *GetLoadBalancerStatisticsOptions {
	options.Headers = param
	return options
}

// GetNetworkAclOptions : The GetNetworkAcl options.
type GetNetworkAclOptions struct {
	// The network ACL identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetNetworkAclOptions : Instantiate GetNetworkAclOptions
func (*VpcV1) NewGetNetworkAclOptions(id string) *GetNetworkAclOptions {
	return &GetNetworkAclOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetNetworkAclOptions) SetID(id string) *GetNetworkAclOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetNetworkAclOptions) SetHeaders(param map[string]string) *GetNetworkAclOptions {
	options.Headers = param
	return options
}

// GetNetworkAclRuleOptions : The GetNetworkAclRule options.
type GetNetworkAclRuleOptions struct {
	// The network ACL identifier.
	NetworkAclID *string `json:"network_acl_id" validate:"required"`

	// The rule identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetNetworkAclRuleOptions : Instantiate GetNetworkAclRuleOptions
func (*VpcV1) NewGetNetworkAclRuleOptions(networkAclID string, id string) *GetNetworkAclRuleOptions {
	return &GetNetworkAclRuleOptions{
		NetworkAclID: core.StringPtr(networkAclID),
		ID:           core.StringPtr(id),
	}
}

// SetNetworkAclID : Allow user to set NetworkAclID
func (options *GetNetworkAclRuleOptions) SetNetworkAclID(networkAclID string) *GetNetworkAclRuleOptions {
	options.NetworkAclID = core.StringPtr(networkAclID)
	return options
}

// SetID : Allow user to set ID
func (options *GetNetworkAclRuleOptions) SetID(id string) *GetNetworkAclRuleOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetNetworkAclRuleOptions) SetHeaders(param map[string]string) *GetNetworkAclRuleOptions {
	options.Headers = param
	return options
}

// GetNetworkInterfaceFloatingIpOptions : The GetNetworkInterfaceFloatingIp options.
type GetNetworkInterfaceFloatingIpOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required"`

	// The floating IP identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetNetworkInterfaceFloatingIpOptions : Instantiate GetNetworkInterfaceFloatingIpOptions
func (*VpcV1) NewGetNetworkInterfaceFloatingIpOptions(instanceID string, networkInterfaceID string, id string) *GetNetworkInterfaceFloatingIpOptions {
	return &GetNetworkInterfaceFloatingIpOptions{
		InstanceID:         core.StringPtr(instanceID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
		ID:                 core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *GetNetworkInterfaceFloatingIpOptions) SetInstanceID(instanceID string) *GetNetworkInterfaceFloatingIpOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (options *GetNetworkInterfaceFloatingIpOptions) SetNetworkInterfaceID(networkInterfaceID string) *GetNetworkInterfaceFloatingIpOptions {
	options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return options
}

// SetID : Allow user to set ID
func (options *GetNetworkInterfaceFloatingIpOptions) SetID(id string) *GetNetworkInterfaceFloatingIpOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetNetworkInterfaceFloatingIpOptions) SetHeaders(param map[string]string) *GetNetworkInterfaceFloatingIpOptions {
	options.Headers = param
	return options
}

// GetNetworkInterfaceOptions : The GetNetworkInterface options.
type GetNetworkInterfaceOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The network interface identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetNetworkInterfaceOptions : Instantiate GetNetworkInterfaceOptions
func (*VpcV1) NewGetNetworkInterfaceOptions(instanceID string, id string) *GetNetworkInterfaceOptions {
	return &GetNetworkInterfaceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *GetNetworkInterfaceOptions) SetInstanceID(instanceID string) *GetNetworkInterfaceOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetID : Allow user to set ID
func (options *GetNetworkInterfaceOptions) SetID(id string) *GetNetworkInterfaceOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetNetworkInterfaceOptions) SetHeaders(param map[string]string) *GetNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// GetOperatingSystemOptions : The GetOperatingSystem options.
type GetOperatingSystemOptions struct {
	// The operating system name.
	Name *string `json:"name" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetOperatingSystemOptions : Instantiate GetOperatingSystemOptions
func (*VpcV1) NewGetOperatingSystemOptions(name string) *GetOperatingSystemOptions {
	return &GetOperatingSystemOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (options *GetOperatingSystemOptions) SetName(name string) *GetOperatingSystemOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetOperatingSystemOptions) SetHeaders(param map[string]string) *GetOperatingSystemOptions {
	options.Headers = param
	return options
}

// GetPublicGatewayOptions : The GetPublicGateway options.
type GetPublicGatewayOptions struct {
	// The public gateway identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetPublicGatewayOptions : Instantiate GetPublicGatewayOptions
func (*VpcV1) NewGetPublicGatewayOptions(id string) *GetPublicGatewayOptions {
	return &GetPublicGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetPublicGatewayOptions) SetID(id string) *GetPublicGatewayOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetPublicGatewayOptions) SetHeaders(param map[string]string) *GetPublicGatewayOptions {
	options.Headers = param
	return options
}

// GetRegionOptions : The GetRegion options.
type GetRegionOptions struct {
	// The region name.
	Name *string `json:"name" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetRegionOptions : Instantiate GetRegionOptions
func (*VpcV1) NewGetRegionOptions(name string) *GetRegionOptions {
	return &GetRegionOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (options *GetRegionOptions) SetName(name string) *GetRegionOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetRegionOptions) SetHeaders(param map[string]string) *GetRegionOptions {
	options.Headers = param
	return options
}

// GetSecurityGroupNetworkInterfaceOptions : The GetSecurityGroupNetworkInterface options.
type GetSecurityGroupNetworkInterfaceOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required"`

	// The network interface identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSecurityGroupNetworkInterfaceOptions : Instantiate GetSecurityGroupNetworkInterfaceOptions
func (*VpcV1) NewGetSecurityGroupNetworkInterfaceOptions(securityGroupID string, id string) *GetSecurityGroupNetworkInterfaceOptions {
	return &GetSecurityGroupNetworkInterfaceOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (options *GetSecurityGroupNetworkInterfaceOptions) SetSecurityGroupID(securityGroupID string) *GetSecurityGroupNetworkInterfaceOptions {
	options.SecurityGroupID = core.StringPtr(securityGroupID)
	return options
}

// SetID : Allow user to set ID
func (options *GetSecurityGroupNetworkInterfaceOptions) SetID(id string) *GetSecurityGroupNetworkInterfaceOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSecurityGroupNetworkInterfaceOptions) SetHeaders(param map[string]string) *GetSecurityGroupNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// GetSecurityGroupOptions : The GetSecurityGroup options.
type GetSecurityGroupOptions struct {
	// The security group identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSecurityGroupOptions : Instantiate GetSecurityGroupOptions
func (*VpcV1) NewGetSecurityGroupOptions(id string) *GetSecurityGroupOptions {
	return &GetSecurityGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetSecurityGroupOptions) SetID(id string) *GetSecurityGroupOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSecurityGroupOptions) SetHeaders(param map[string]string) *GetSecurityGroupOptions {
	options.Headers = param
	return options
}

// GetSecurityGroupRuleOptions : The GetSecurityGroupRule options.
type GetSecurityGroupRuleOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required"`

	// The rule identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSecurityGroupRuleOptions : Instantiate GetSecurityGroupRuleOptions
func (*VpcV1) NewGetSecurityGroupRuleOptions(securityGroupID string, id string) *GetSecurityGroupRuleOptions {
	return &GetSecurityGroupRuleOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (options *GetSecurityGroupRuleOptions) SetSecurityGroupID(securityGroupID string) *GetSecurityGroupRuleOptions {
	options.SecurityGroupID = core.StringPtr(securityGroupID)
	return options
}

// SetID : Allow user to set ID
func (options *GetSecurityGroupRuleOptions) SetID(id string) *GetSecurityGroupRuleOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSecurityGroupRuleOptions) SetHeaders(param map[string]string) *GetSecurityGroupRuleOptions {
	options.Headers = param
	return options
}

// GetSubnetNetworkAclOptions : The GetSubnetNetworkAcl options.
type GetSubnetNetworkAclOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSubnetNetworkAclOptions : Instantiate GetSubnetNetworkAclOptions
func (*VpcV1) NewGetSubnetNetworkAclOptions(id string) *GetSubnetNetworkAclOptions {
	return &GetSubnetNetworkAclOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetSubnetNetworkAclOptions) SetID(id string) *GetSubnetNetworkAclOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSubnetNetworkAclOptions) SetHeaders(param map[string]string) *GetSubnetNetworkAclOptions {
	options.Headers = param
	return options
}

// GetSubnetOptions : The GetSubnet options.
type GetSubnetOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSubnetOptions : Instantiate GetSubnetOptions
func (*VpcV1) NewGetSubnetOptions(id string) *GetSubnetOptions {
	return &GetSubnetOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetSubnetOptions) SetID(id string) *GetSubnetOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSubnetOptions) SetHeaders(param map[string]string) *GetSubnetOptions {
	options.Headers = param
	return options
}

// GetSubnetPublicGatewayOptions : The GetSubnetPublicGateway options.
type GetSubnetPublicGatewayOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSubnetPublicGatewayOptions : Instantiate GetSubnetPublicGatewayOptions
func (*VpcV1) NewGetSubnetPublicGatewayOptions(id string) *GetSubnetPublicGatewayOptions {
	return &GetSubnetPublicGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetSubnetPublicGatewayOptions) SetID(id string) *GetSubnetPublicGatewayOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSubnetPublicGatewayOptions) SetHeaders(param map[string]string) *GetSubnetPublicGatewayOptions {
	options.Headers = param
	return options
}

// GetVolumeAttachmentOptions : The GetVolumeAttachment options.
type GetVolumeAttachmentOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The volume attachment identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVolumeAttachmentOptions : Instantiate GetVolumeAttachmentOptions
func (*VpcV1) NewGetVolumeAttachmentOptions(instanceID string, id string) *GetVolumeAttachmentOptions {
	return &GetVolumeAttachmentOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *GetVolumeAttachmentOptions) SetInstanceID(instanceID string) *GetVolumeAttachmentOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetID : Allow user to set ID
func (options *GetVolumeAttachmentOptions) SetID(id string) *GetVolumeAttachmentOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVolumeAttachmentOptions) SetHeaders(param map[string]string) *GetVolumeAttachmentOptions {
	options.Headers = param
	return options
}

// GetVolumeOptions : The GetVolume options.
type GetVolumeOptions struct {
	// The volume identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVolumeOptions : Instantiate GetVolumeOptions
func (*VpcV1) NewGetVolumeOptions(id string) *GetVolumeOptions {
	return &GetVolumeOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetVolumeOptions) SetID(id string) *GetVolumeOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVolumeOptions) SetHeaders(param map[string]string) *GetVolumeOptions {
	options.Headers = param
	return options
}

// GetVolumeProfileOptions : The GetVolumeProfile options.
type GetVolumeProfileOptions struct {
	// The volume profile name.
	Name *string `json:"name" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVolumeProfileOptions : Instantiate GetVolumeProfileOptions
func (*VpcV1) NewGetVolumeProfileOptions(name string) *GetVolumeProfileOptions {
	return &GetVolumeProfileOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (options *GetVolumeProfileOptions) SetName(name string) *GetVolumeProfileOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVolumeProfileOptions) SetHeaders(param map[string]string) *GetVolumeProfileOptions {
	options.Headers = param
	return options
}

// GetVpcAddressPrefixOptions : The GetVpcAddressPrefix options.
type GetVpcAddressPrefixOptions struct {
	// The VPC identifier.
	VpcID *string `json:"vpc_id" validate:"required"`

	// The prefix identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVpcAddressPrefixOptions : Instantiate GetVpcAddressPrefixOptions
func (*VpcV1) NewGetVpcAddressPrefixOptions(vpcID string, id string) *GetVpcAddressPrefixOptions {
	return &GetVpcAddressPrefixOptions{
		VpcID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVpcID : Allow user to set VpcID
func (options *GetVpcAddressPrefixOptions) SetVpcID(vpcID string) *GetVpcAddressPrefixOptions {
	options.VpcID = core.StringPtr(vpcID)
	return options
}

// SetID : Allow user to set ID
func (options *GetVpcAddressPrefixOptions) SetID(id string) *GetVpcAddressPrefixOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVpcAddressPrefixOptions) SetHeaders(param map[string]string) *GetVpcAddressPrefixOptions {
	options.Headers = param
	return options
}

// GetVpcDefaultNetworkAclOptions : The GetVpcDefaultNetworkAcl options.
type GetVpcDefaultNetworkAclOptions struct {
	// The VPC identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVpcDefaultNetworkAclOptions : Instantiate GetVpcDefaultNetworkAclOptions
func (*VpcV1) NewGetVpcDefaultNetworkAclOptions(id string) *GetVpcDefaultNetworkAclOptions {
	return &GetVpcDefaultNetworkAclOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetVpcDefaultNetworkAclOptions) SetID(id string) *GetVpcDefaultNetworkAclOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVpcDefaultNetworkAclOptions) SetHeaders(param map[string]string) *GetVpcDefaultNetworkAclOptions {
	options.Headers = param
	return options
}

// GetVpcDefaultSecurityGroupOptions : The GetVpcDefaultSecurityGroup options.
type GetVpcDefaultSecurityGroupOptions struct {
	// The VPC identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVpcDefaultSecurityGroupOptions : Instantiate GetVpcDefaultSecurityGroupOptions
func (*VpcV1) NewGetVpcDefaultSecurityGroupOptions(id string) *GetVpcDefaultSecurityGroupOptions {
	return &GetVpcDefaultSecurityGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetVpcDefaultSecurityGroupOptions) SetID(id string) *GetVpcDefaultSecurityGroupOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVpcDefaultSecurityGroupOptions) SetHeaders(param map[string]string) *GetVpcDefaultSecurityGroupOptions {
	options.Headers = param
	return options
}

// GetVpcOptions : The GetVpc options.
type GetVpcOptions struct {
	// The VPC identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVpcOptions : Instantiate GetVpcOptions
func (*VpcV1) NewGetVpcOptions(id string) *GetVpcOptions {
	return &GetVpcOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetVpcOptions) SetID(id string) *GetVpcOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVpcOptions) SetHeaders(param map[string]string) *GetVpcOptions {
	options.Headers = param
	return options
}

// GetVpcRouteOptions : The GetVpcRoute options.
type GetVpcRouteOptions struct {
	// The VPC identifier.
	VpcID *string `json:"vpc_id" validate:"required"`

	// The route identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVpcRouteOptions : Instantiate GetVpcRouteOptions
func (*VpcV1) NewGetVpcRouteOptions(vpcID string, id string) *GetVpcRouteOptions {
	return &GetVpcRouteOptions{
		VpcID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVpcID : Allow user to set VpcID
func (options *GetVpcRouteOptions) SetVpcID(vpcID string) *GetVpcRouteOptions {
	options.VpcID = core.StringPtr(vpcID)
	return options
}

// SetID : Allow user to set ID
func (options *GetVpcRouteOptions) SetID(id string) *GetVpcRouteOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVpcRouteOptions) SetHeaders(param map[string]string) *GetVpcRouteOptions {
	options.Headers = param
	return options
}

// GetVpnGatewayConnectionLocalCidrOptions : The GetVpnGatewayConnectionLocalCidr options.
type GetVpnGatewayConnectionLocalCidrOptions struct {
	// The VPN gateway identifier.
	VpnGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// The prefix address part of the CIDR.
	PrefixAddress *string `json:"prefix_address" validate:"required"`

	// The prefix length part of the CIDR.
	PrefixLength *string `json:"prefix_length" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVpnGatewayConnectionLocalCidrOptions : Instantiate GetVpnGatewayConnectionLocalCidrOptions
func (*VpcV1) NewGetVpnGatewayConnectionLocalCidrOptions(vpnGatewayID string, id string, prefixAddress string, prefixLength string) *GetVpnGatewayConnectionLocalCidrOptions {
	return &GetVpnGatewayConnectionLocalCidrOptions{
		VpnGatewayID:  core.StringPtr(vpnGatewayID),
		ID:            core.StringPtr(id),
		PrefixAddress: core.StringPtr(prefixAddress),
		PrefixLength:  core.StringPtr(prefixLength),
	}
}

// SetVpnGatewayID : Allow user to set VpnGatewayID
func (options *GetVpnGatewayConnectionLocalCidrOptions) SetVpnGatewayID(vpnGatewayID string) *GetVpnGatewayConnectionLocalCidrOptions {
	options.VpnGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *GetVpnGatewayConnectionLocalCidrOptions) SetID(id string) *GetVpnGatewayConnectionLocalCidrOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetPrefixAddress : Allow user to set PrefixAddress
func (options *GetVpnGatewayConnectionLocalCidrOptions) SetPrefixAddress(prefixAddress string) *GetVpnGatewayConnectionLocalCidrOptions {
	options.PrefixAddress = core.StringPtr(prefixAddress)
	return options
}

// SetPrefixLength : Allow user to set PrefixLength
func (options *GetVpnGatewayConnectionLocalCidrOptions) SetPrefixLength(prefixLength string) *GetVpnGatewayConnectionLocalCidrOptions {
	options.PrefixLength = core.StringPtr(prefixLength)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVpnGatewayConnectionLocalCidrOptions) SetHeaders(param map[string]string) *GetVpnGatewayConnectionLocalCidrOptions {
	options.Headers = param
	return options
}

// GetVpnGatewayConnectionOptions : The GetVpnGatewayConnection options.
type GetVpnGatewayConnectionOptions struct {
	// The VPN gateway identifier.
	VpnGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVpnGatewayConnectionOptions : Instantiate GetVpnGatewayConnectionOptions
func (*VpcV1) NewGetVpnGatewayConnectionOptions(vpnGatewayID string, id string) *GetVpnGatewayConnectionOptions {
	return &GetVpnGatewayConnectionOptions{
		VpnGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
	}
}

// SetVpnGatewayID : Allow user to set VpnGatewayID
func (options *GetVpnGatewayConnectionOptions) SetVpnGatewayID(vpnGatewayID string) *GetVpnGatewayConnectionOptions {
	options.VpnGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *GetVpnGatewayConnectionOptions) SetID(id string) *GetVpnGatewayConnectionOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVpnGatewayConnectionOptions) SetHeaders(param map[string]string) *GetVpnGatewayConnectionOptions {
	options.Headers = param
	return options
}

// GetVpnGatewayConnectionPeerCidrOptions : The GetVpnGatewayConnectionPeerCidr options.
type GetVpnGatewayConnectionPeerCidrOptions struct {
	// The VPN gateway identifier.
	VpnGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// The prefix address part of the CIDR.
	PrefixAddress *string `json:"prefix_address" validate:"required"`

	// The prefix length part of the CIDR.
	PrefixLength *string `json:"prefix_length" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVpnGatewayConnectionPeerCidrOptions : Instantiate GetVpnGatewayConnectionPeerCidrOptions
func (*VpcV1) NewGetVpnGatewayConnectionPeerCidrOptions(vpnGatewayID string, id string, prefixAddress string, prefixLength string) *GetVpnGatewayConnectionPeerCidrOptions {
	return &GetVpnGatewayConnectionPeerCidrOptions{
		VpnGatewayID:  core.StringPtr(vpnGatewayID),
		ID:            core.StringPtr(id),
		PrefixAddress: core.StringPtr(prefixAddress),
		PrefixLength:  core.StringPtr(prefixLength),
	}
}

// SetVpnGatewayID : Allow user to set VpnGatewayID
func (options *GetVpnGatewayConnectionPeerCidrOptions) SetVpnGatewayID(vpnGatewayID string) *GetVpnGatewayConnectionPeerCidrOptions {
	options.VpnGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *GetVpnGatewayConnectionPeerCidrOptions) SetID(id string) *GetVpnGatewayConnectionPeerCidrOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetPrefixAddress : Allow user to set PrefixAddress
func (options *GetVpnGatewayConnectionPeerCidrOptions) SetPrefixAddress(prefixAddress string) *GetVpnGatewayConnectionPeerCidrOptions {
	options.PrefixAddress = core.StringPtr(prefixAddress)
	return options
}

// SetPrefixLength : Allow user to set PrefixLength
func (options *GetVpnGatewayConnectionPeerCidrOptions) SetPrefixLength(prefixLength string) *GetVpnGatewayConnectionPeerCidrOptions {
	options.PrefixLength = core.StringPtr(prefixLength)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVpnGatewayConnectionPeerCidrOptions) SetHeaders(param map[string]string) *GetVpnGatewayConnectionPeerCidrOptions {
	options.Headers = param
	return options
}

// GetVpnGatewayOptions : The GetVpnGateway options.
type GetVpnGatewayOptions struct {
	// The VPN gateway identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVpnGatewayOptions : Instantiate GetVpnGatewayOptions
func (*VpcV1) NewGetVpnGatewayOptions(id string) *GetVpnGatewayOptions {
	return &GetVpnGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetVpnGatewayOptions) SetID(id string) *GetVpnGatewayOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVpnGatewayOptions) SetHeaders(param map[string]string) *GetVpnGatewayOptions {
	options.Headers = param
	return options
}

// GetZoneOptions : The GetZone options.
type GetZoneOptions struct {
	// The region name.
	RegionName *string `json:"region_name" validate:"required"`

	// The zone name.
	ZoneName *string `json:"zone_name" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetZoneOptions : Instantiate GetZoneOptions
func (*VpcV1) NewGetZoneOptions(regionName string, zoneName string) *GetZoneOptions {
	return &GetZoneOptions{
		RegionName: core.StringPtr(regionName),
		ZoneName:   core.StringPtr(zoneName),
	}
}

// SetRegionName : Allow user to set RegionName
func (options *GetZoneOptions) SetRegionName(regionName string) *GetZoneOptions {
	options.RegionName = core.StringPtr(regionName)
	return options
}

// SetZoneName : Allow user to set ZoneName
func (options *GetZoneOptions) SetZoneName(zoneName string) *GetZoneOptions {
	options.ZoneName = core.StringPtr(zoneName)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetZoneOptions) SetHeaders(param map[string]string) *GetZoneOptions {
	options.Headers = param
	return options
}

// IKEPolicy : IKEPolicy struct
type IKEPolicy struct {
	// The authentication algorithm.
	AuthenticationAlgorithm *string `json:"authentication_algorithm" validate:"required"`

	// Collection of references to VPN connections that use this IKE policy.
	Connections []VPNGatewayConnectionReference `json:"connections" validate:"required"`

	// The date and time that this IKE policy was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The Diffie-Hellman group.
	DhGroup *int64 `json:"dh_group" validate:"required"`

	// The encryption algorithm.
	EncryptionAlgorithm *string `json:"encryption_algorithm" validate:"required"`

	// The IKE policy's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this IKE policy.
	ID *string `json:"id" validate:"required"`

	// The IKE protocol version.
	IkeVersion *int64 `json:"ike_version" validate:"required"`

	// The key lifetime in seconds.
	KeyLifetime *int64 `json:"key_lifetime" validate:"required"`

	// The user-defined name for this IKE policy.
	Name *string `json:"name" validate:"required"`

	// The IKE negotiation mode. Only `main` is supported.
	NegotiationMode *string `json:"negotiation_mode" validate:"required"`

	// The resource group for this IKE policy.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`
}

// Constants associated with the IKEPolicy.AuthenticationAlgorithm property.
// The authentication algorithm.
const (
	IKEPolicy_AuthenticationAlgorithm_Md5    = "md5"
	IKEPolicy_AuthenticationAlgorithm_Sha1   = "sha1"
	IKEPolicy_AuthenticationAlgorithm_Sha256 = "sha256"
)

// Constants associated with the IKEPolicy.EncryptionAlgorithm property.
// The encryption algorithm.
const (
	IKEPolicy_EncryptionAlgorithm_Aes128    = "aes128"
	IKEPolicy_EncryptionAlgorithm_Aes256    = "aes256"
	IKEPolicy_EncryptionAlgorithm_TripleDes = "triple_des"
)

// Constants associated with the IKEPolicy.NegotiationMode property.
// The IKE negotiation mode. Only `main` is supported.
const (
	IKEPolicy_NegotiationMode_Main = "main"
)

// UnmarshalIKEPolicy constructs an instance of IKEPolicy from the specified map.
func UnmarshalIKEPolicy(m map[string]interface{}) (result *IKEPolicy, err error) {
	obj := new(IKEPolicy)
	obj.AuthenticationAlgorithm, err = core.UnmarshalString(m, "authentication_algorithm")
	if err != nil {
		return
	}
	obj.Connections, err = UnmarshalVPNGatewayConnectionReferenceSliceAsProperty(m, "connections")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.DhGroup, err = core.UnmarshalInt64(m, "dh_group")
	if err != nil {
		return
	}
	obj.EncryptionAlgorithm, err = core.UnmarshalString(m, "encryption_algorithm")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IkeVersion, err = core.UnmarshalInt64(m, "ike_version")
	if err != nil {
		return
	}
	obj.KeyLifetime, err = core.UnmarshalInt64(m, "key_lifetime")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.NegotiationMode, err = core.UnmarshalString(m, "negotiation_mode")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupReferenceAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalIKEPolicySlice unmarshals a slice of IKEPolicy instances from the specified list of maps.
func UnmarshalIKEPolicySlice(s []interface{}) (slice []IKEPolicy, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'IKEPolicy'")
			return
		}
		obj, e := UnmarshalIKEPolicy(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalIKEPolicyAsProperty unmarshals an instance of IKEPolicy that is stored as a property
// within the specified map.
func UnmarshalIKEPolicyAsProperty(m map[string]interface{}, propertyName string) (result *IKEPolicy, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'IKEPolicy'", propertyName)
			return
		}
		result, err = UnmarshalIKEPolicy(objMap)
	}
	return
}

// UnmarshalIKEPolicySliceAsProperty unmarshals a slice of IKEPolicy instances that are stored as a property
// within the specified map.
func UnmarshalIKEPolicySliceAsProperty(m map[string]interface{}, propertyName string) (slice []IKEPolicy, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'IKEPolicy'", propertyName)
			return
		}
		slice, err = UnmarshalIKEPolicySlice(vSlice)
	}
	return
}

// IKEPolicyCollection : IKEPolicyCollection struct
type IKEPolicyCollection struct {
	// A reference to the first page of resources.
	First *IKEPolicyCollectionFirst `json:"first" validate:"required"`

	// Collection of IKE policies.
	IkePolicies []IKEPolicy `json:"ike_policies" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *IKEPolicyCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalIKEPolicyCollection constructs an instance of IKEPolicyCollection from the specified map.
func UnmarshalIKEPolicyCollection(m map[string]interface{}) (result *IKEPolicyCollection, err error) {
	obj := new(IKEPolicyCollection)
	obj.First, err = UnmarshalIKEPolicyCollectionFirstAsProperty(m, "first")
	if err != nil {
		return
	}
	obj.IkePolicies, err = UnmarshalIKEPolicySliceAsProperty(m, "ike_policies")
	if err != nil {
		return
	}
	obj.Limit, err = core.UnmarshalInt64(m, "limit")
	if err != nil {
		return
	}
	obj.Next, err = UnmarshalIKEPolicyCollectionNextAsProperty(m, "next")
	if err != nil {
		return
	}
	obj.TotalCount, err = core.UnmarshalInt64(m, "total_count")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalIKEPolicyCollectionSlice unmarshals a slice of IKEPolicyCollection instances from the specified list of maps.
func UnmarshalIKEPolicyCollectionSlice(s []interface{}) (slice []IKEPolicyCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'IKEPolicyCollection'")
			return
		}
		obj, e := UnmarshalIKEPolicyCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalIKEPolicyCollectionAsProperty unmarshals an instance of IKEPolicyCollection that is stored as a property
// within the specified map.
func UnmarshalIKEPolicyCollectionAsProperty(m map[string]interface{}, propertyName string) (result *IKEPolicyCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'IKEPolicyCollection'", propertyName)
			return
		}
		result, err = UnmarshalIKEPolicyCollection(objMap)
	}
	return
}

// UnmarshalIKEPolicyCollectionSliceAsProperty unmarshals a slice of IKEPolicyCollection instances that are stored as a property
// within the specified map.
func UnmarshalIKEPolicyCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []IKEPolicyCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'IKEPolicyCollection'", propertyName)
			return
		}
		slice, err = UnmarshalIKEPolicyCollectionSlice(vSlice)
	}
	return
}

// IKEPolicyCollectionFirst : A reference to the first page of resources.
type IKEPolicyCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalIKEPolicyCollectionFirst constructs an instance of IKEPolicyCollectionFirst from the specified map.
func UnmarshalIKEPolicyCollectionFirst(m map[string]interface{}) (result *IKEPolicyCollectionFirst, err error) {
	obj := new(IKEPolicyCollectionFirst)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalIKEPolicyCollectionFirstSlice unmarshals a slice of IKEPolicyCollectionFirst instances from the specified list of maps.
func UnmarshalIKEPolicyCollectionFirstSlice(s []interface{}) (slice []IKEPolicyCollectionFirst, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'IKEPolicyCollectionFirst'")
			return
		}
		obj, e := UnmarshalIKEPolicyCollectionFirst(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalIKEPolicyCollectionFirstAsProperty unmarshals an instance of IKEPolicyCollectionFirst that is stored as a property
// within the specified map.
func UnmarshalIKEPolicyCollectionFirstAsProperty(m map[string]interface{}, propertyName string) (result *IKEPolicyCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'IKEPolicyCollectionFirst'", propertyName)
			return
		}
		result, err = UnmarshalIKEPolicyCollectionFirst(objMap)
	}
	return
}

// UnmarshalIKEPolicyCollectionFirstSliceAsProperty unmarshals a slice of IKEPolicyCollectionFirst instances that are stored as a property
// within the specified map.
func UnmarshalIKEPolicyCollectionFirstSliceAsProperty(m map[string]interface{}, propertyName string) (slice []IKEPolicyCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'IKEPolicyCollectionFirst'", propertyName)
			return
		}
		slice, err = UnmarshalIKEPolicyCollectionFirstSlice(vSlice)
	}
	return
}

// IKEPolicyCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type IKEPolicyCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalIKEPolicyCollectionNext constructs an instance of IKEPolicyCollectionNext from the specified map.
func UnmarshalIKEPolicyCollectionNext(m map[string]interface{}) (result *IKEPolicyCollectionNext, err error) {
	obj := new(IKEPolicyCollectionNext)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalIKEPolicyCollectionNextSlice unmarshals a slice of IKEPolicyCollectionNext instances from the specified list of maps.
func UnmarshalIKEPolicyCollectionNextSlice(s []interface{}) (slice []IKEPolicyCollectionNext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'IKEPolicyCollectionNext'")
			return
		}
		obj, e := UnmarshalIKEPolicyCollectionNext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalIKEPolicyCollectionNextAsProperty unmarshals an instance of IKEPolicyCollectionNext that is stored as a property
// within the specified map.
func UnmarshalIKEPolicyCollectionNextAsProperty(m map[string]interface{}, propertyName string) (result *IKEPolicyCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'IKEPolicyCollectionNext'", propertyName)
			return
		}
		result, err = UnmarshalIKEPolicyCollectionNext(objMap)
	}
	return
}

// UnmarshalIKEPolicyCollectionNextSliceAsProperty unmarshals a slice of IKEPolicyCollectionNext instances that are stored as a property
// within the specified map.
func UnmarshalIKEPolicyCollectionNextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []IKEPolicyCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'IKEPolicyCollectionNext'", propertyName)
			return
		}
		slice, err = UnmarshalIKEPolicyCollectionNextSlice(vSlice)
	}
	return
}

// IKEPolicyIdentity : Identifies an IKE policy by a unique property.
// Models which "extend" this model:
// - IKEPolicyIdentityByID
// - IKEPolicyIdentityByHref
type IKEPolicyIdentity struct {
	// The unique identifier for this IKE policy.
	ID *string `json:"id,omitempty"`

	// The IKE policy's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*IKEPolicyIdentity) isaIKEPolicyIdentity() bool {
	return true
}

type IKEPolicyIdentityIntf interface {
	isaIKEPolicyIdentity() bool
}

// UnmarshalIKEPolicyIdentity constructs an instance of IKEPolicyIdentity from the specified map.
func UnmarshalIKEPolicyIdentity(m map[string]interface{}) (result IKEPolicyIdentityIntf, err error) {
	obj := new(IKEPolicyIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalIKEPolicyIdentitySlice unmarshals a slice of IKEPolicyIdentity instances from the specified list of maps.
func UnmarshalIKEPolicyIdentitySlice(s []interface{}) (slice []IKEPolicyIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'IKEPolicyIdentity'")
			return
		}
		obj, e := UnmarshalIKEPolicyIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalIKEPolicyIdentityAsProperty unmarshals an instance of IKEPolicyIdentity that is stored as a property
// within the specified map.
func UnmarshalIKEPolicyIdentityAsProperty(m map[string]interface{}, propertyName string) (result IKEPolicyIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'IKEPolicyIdentity'", propertyName)
			return
		}
		result, err = UnmarshalIKEPolicyIdentity(objMap)
	}
	return
}

// UnmarshalIKEPolicyIdentitySliceAsProperty unmarshals a slice of IKEPolicyIdentity instances that are stored as a property
// within the specified map.
func UnmarshalIKEPolicyIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []IKEPolicyIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'IKEPolicyIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalIKEPolicyIdentitySlice(vSlice)
	}
	return
}

// IP : IP struct
type IP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// UnmarshalIP constructs an instance of IP from the specified map.
func UnmarshalIP(m map[string]interface{}) (result *IP, err error) {
	obj := new(IP)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalIPSlice unmarshals a slice of IP instances from the specified list of maps.
func UnmarshalIPSlice(s []interface{}) (slice []IP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'IP'")
			return
		}
		obj, e := UnmarshalIP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalIPAsProperty unmarshals an instance of IP that is stored as a property
// within the specified map.
func UnmarshalIPAsProperty(m map[string]interface{}, propertyName string) (result *IP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'IP'", propertyName)
			return
		}
		result, err = UnmarshalIP(objMap)
	}
	return
}

// UnmarshalIPSliceAsProperty unmarshals a slice of IP instances that are stored as a property
// within the specified map.
func UnmarshalIPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []IP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'IP'", propertyName)
			return
		}
		slice, err = UnmarshalIPSlice(vSlice)
	}
	return
}

// IPsecPolicy : IPsecPolicy struct
type IPsecPolicy struct {
	// The authentication algorithm.
	AuthenticationAlgorithm *string `json:"authentication_algorithm" validate:"required"`

	// Collection of references to VPN connections that use this IPsec policy.
	Connections []VPNGatewayConnectionReference `json:"connections" validate:"required"`

	// The date and time that this IPsec policy was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The encapsulation mode used. Only `tunnel` is supported.
	EncapsulationMode *string `json:"encapsulation_mode" validate:"required"`

	// The encryption algorithm.
	EncryptionAlgorithm *string `json:"encryption_algorithm" validate:"required"`

	// The IPsec policy's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this IPsec policy.
	ID *string `json:"id" validate:"required"`

	// The key lifetime in seconds.
	KeyLifetime *int64 `json:"key_lifetime" validate:"required"`

	// The user-defined name for this IPsec policy.
	Name *string `json:"name" validate:"required"`

	// Perfect Forward Secrecy.
	Pfs *string `json:"pfs" validate:"required"`

	// The resource group for this IPsec policy.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The transform protocol used. Only `esp` is supported.
	TransformProtocol *string `json:"transform_protocol" validate:"required"`
}

// Constants associated with the IPsecPolicy.AuthenticationAlgorithm property.
// The authentication algorithm.
const (
	IPsecPolicy_AuthenticationAlgorithm_Md5    = "md5"
	IPsecPolicy_AuthenticationAlgorithm_Sha1   = "sha1"
	IPsecPolicy_AuthenticationAlgorithm_Sha256 = "sha256"
)

// Constants associated with the IPsecPolicy.EncapsulationMode property.
// The encapsulation mode used. Only `tunnel` is supported.
const (
	IPsecPolicy_EncapsulationMode_Tunnel = "tunnel"
)

// Constants associated with the IPsecPolicy.EncryptionAlgorithm property.
// The encryption algorithm.
const (
	IPsecPolicy_EncryptionAlgorithm_Aes128    = "aes128"
	IPsecPolicy_EncryptionAlgorithm_Aes256    = "aes256"
	IPsecPolicy_EncryptionAlgorithm_TripleDes = "triple_des"
)

// Constants associated with the IPsecPolicy.Pfs property.
// Perfect Forward Secrecy.
const (
	IPsecPolicy_Pfs_Disabled = "disabled"
	IPsecPolicy_Pfs_Group14  = "group_14"
	IPsecPolicy_Pfs_Group2   = "group_2"
	IPsecPolicy_Pfs_Group5   = "group_5"
)

// Constants associated with the IPsecPolicy.TransformProtocol property.
// The transform protocol used. Only `esp` is supported.
const (
	IPsecPolicy_TransformProtocol_Esp = "esp"
)

// UnmarshalIPsecPolicy constructs an instance of IPsecPolicy from the specified map.
func UnmarshalIPsecPolicy(m map[string]interface{}) (result *IPsecPolicy, err error) {
	obj := new(IPsecPolicy)
	obj.AuthenticationAlgorithm, err = core.UnmarshalString(m, "authentication_algorithm")
	if err != nil {
		return
	}
	obj.Connections, err = UnmarshalVPNGatewayConnectionReferenceSliceAsProperty(m, "connections")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.EncapsulationMode, err = core.UnmarshalString(m, "encapsulation_mode")
	if err != nil {
		return
	}
	obj.EncryptionAlgorithm, err = core.UnmarshalString(m, "encryption_algorithm")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.KeyLifetime, err = core.UnmarshalInt64(m, "key_lifetime")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Pfs, err = core.UnmarshalString(m, "pfs")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupReferenceAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.TransformProtocol, err = core.UnmarshalString(m, "transform_protocol")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalIPsecPolicySlice unmarshals a slice of IPsecPolicy instances from the specified list of maps.
func UnmarshalIPsecPolicySlice(s []interface{}) (slice []IPsecPolicy, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'IPsecPolicy'")
			return
		}
		obj, e := UnmarshalIPsecPolicy(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalIPsecPolicyAsProperty unmarshals an instance of IPsecPolicy that is stored as a property
// within the specified map.
func UnmarshalIPsecPolicyAsProperty(m map[string]interface{}, propertyName string) (result *IPsecPolicy, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'IPsecPolicy'", propertyName)
			return
		}
		result, err = UnmarshalIPsecPolicy(objMap)
	}
	return
}

// UnmarshalIPsecPolicySliceAsProperty unmarshals a slice of IPsecPolicy instances that are stored as a property
// within the specified map.
func UnmarshalIPsecPolicySliceAsProperty(m map[string]interface{}, propertyName string) (slice []IPsecPolicy, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'IPsecPolicy'", propertyName)
			return
		}
		slice, err = UnmarshalIPsecPolicySlice(vSlice)
	}
	return
}

// IPsecPolicyCollection : IPsecPolicyCollection struct
type IPsecPolicyCollection struct {
	// A reference to the first page of resources.
	First *IPsecPolicyCollectionFirst `json:"first" validate:"required"`

	// Collection of IPsec policies.
	IpsecPolicies []IPsecPolicy `json:"ipsec_policies" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *IPsecPolicyCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalIPsecPolicyCollection constructs an instance of IPsecPolicyCollection from the specified map.
func UnmarshalIPsecPolicyCollection(m map[string]interface{}) (result *IPsecPolicyCollection, err error) {
	obj := new(IPsecPolicyCollection)
	obj.First, err = UnmarshalIPsecPolicyCollectionFirstAsProperty(m, "first")
	if err != nil {
		return
	}
	obj.IpsecPolicies, err = UnmarshalIPsecPolicySliceAsProperty(m, "ipsec_policies")
	if err != nil {
		return
	}
	obj.Limit, err = core.UnmarshalInt64(m, "limit")
	if err != nil {
		return
	}
	obj.Next, err = UnmarshalIPsecPolicyCollectionNextAsProperty(m, "next")
	if err != nil {
		return
	}
	obj.TotalCount, err = core.UnmarshalInt64(m, "total_count")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalIPsecPolicyCollectionSlice unmarshals a slice of IPsecPolicyCollection instances from the specified list of maps.
func UnmarshalIPsecPolicyCollectionSlice(s []interface{}) (slice []IPsecPolicyCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'IPsecPolicyCollection'")
			return
		}
		obj, e := UnmarshalIPsecPolicyCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalIPsecPolicyCollectionAsProperty unmarshals an instance of IPsecPolicyCollection that is stored as a property
// within the specified map.
func UnmarshalIPsecPolicyCollectionAsProperty(m map[string]interface{}, propertyName string) (result *IPsecPolicyCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'IPsecPolicyCollection'", propertyName)
			return
		}
		result, err = UnmarshalIPsecPolicyCollection(objMap)
	}
	return
}

// UnmarshalIPsecPolicyCollectionSliceAsProperty unmarshals a slice of IPsecPolicyCollection instances that are stored as a property
// within the specified map.
func UnmarshalIPsecPolicyCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []IPsecPolicyCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'IPsecPolicyCollection'", propertyName)
			return
		}
		slice, err = UnmarshalIPsecPolicyCollectionSlice(vSlice)
	}
	return
}

// IPsecPolicyCollectionFirst : A reference to the first page of resources.
type IPsecPolicyCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalIPsecPolicyCollectionFirst constructs an instance of IPsecPolicyCollectionFirst from the specified map.
func UnmarshalIPsecPolicyCollectionFirst(m map[string]interface{}) (result *IPsecPolicyCollectionFirst, err error) {
	obj := new(IPsecPolicyCollectionFirst)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalIPsecPolicyCollectionFirstSlice unmarshals a slice of IPsecPolicyCollectionFirst instances from the specified list of maps.
func UnmarshalIPsecPolicyCollectionFirstSlice(s []interface{}) (slice []IPsecPolicyCollectionFirst, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'IPsecPolicyCollectionFirst'")
			return
		}
		obj, e := UnmarshalIPsecPolicyCollectionFirst(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalIPsecPolicyCollectionFirstAsProperty unmarshals an instance of IPsecPolicyCollectionFirst that is stored as a property
// within the specified map.
func UnmarshalIPsecPolicyCollectionFirstAsProperty(m map[string]interface{}, propertyName string) (result *IPsecPolicyCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'IPsecPolicyCollectionFirst'", propertyName)
			return
		}
		result, err = UnmarshalIPsecPolicyCollectionFirst(objMap)
	}
	return
}

// UnmarshalIPsecPolicyCollectionFirstSliceAsProperty unmarshals a slice of IPsecPolicyCollectionFirst instances that are stored as a property
// within the specified map.
func UnmarshalIPsecPolicyCollectionFirstSliceAsProperty(m map[string]interface{}, propertyName string) (slice []IPsecPolicyCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'IPsecPolicyCollectionFirst'", propertyName)
			return
		}
		slice, err = UnmarshalIPsecPolicyCollectionFirstSlice(vSlice)
	}
	return
}

// IPsecPolicyCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type IPsecPolicyCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalIPsecPolicyCollectionNext constructs an instance of IPsecPolicyCollectionNext from the specified map.
func UnmarshalIPsecPolicyCollectionNext(m map[string]interface{}) (result *IPsecPolicyCollectionNext, err error) {
	obj := new(IPsecPolicyCollectionNext)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalIPsecPolicyCollectionNextSlice unmarshals a slice of IPsecPolicyCollectionNext instances from the specified list of maps.
func UnmarshalIPsecPolicyCollectionNextSlice(s []interface{}) (slice []IPsecPolicyCollectionNext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'IPsecPolicyCollectionNext'")
			return
		}
		obj, e := UnmarshalIPsecPolicyCollectionNext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalIPsecPolicyCollectionNextAsProperty unmarshals an instance of IPsecPolicyCollectionNext that is stored as a property
// within the specified map.
func UnmarshalIPsecPolicyCollectionNextAsProperty(m map[string]interface{}, propertyName string) (result *IPsecPolicyCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'IPsecPolicyCollectionNext'", propertyName)
			return
		}
		result, err = UnmarshalIPsecPolicyCollectionNext(objMap)
	}
	return
}

// UnmarshalIPsecPolicyCollectionNextSliceAsProperty unmarshals a slice of IPsecPolicyCollectionNext instances that are stored as a property
// within the specified map.
func UnmarshalIPsecPolicyCollectionNextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []IPsecPolicyCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'IPsecPolicyCollectionNext'", propertyName)
			return
		}
		slice, err = UnmarshalIPsecPolicyCollectionNextSlice(vSlice)
	}
	return
}

// IPsecPolicyIdentity : IPsecPolicyIdentity struct
// Models which "extend" this model:
// - IPsecPolicyIdentityByID
// - IPsecPolicyIdentityByHref
type IPsecPolicyIdentity struct {
	// The unique identifier for this IPsec policy.
	ID *string `json:"id,omitempty"`

	// The IPsec policy's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*IPsecPolicyIdentity) isaIPsecPolicyIdentity() bool {
	return true
}

type IPsecPolicyIdentityIntf interface {
	isaIPsecPolicyIdentity() bool
}

// UnmarshalIPsecPolicyIdentity constructs an instance of IPsecPolicyIdentity from the specified map.
func UnmarshalIPsecPolicyIdentity(m map[string]interface{}) (result IPsecPolicyIdentityIntf, err error) {
	obj := new(IPsecPolicyIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalIPsecPolicyIdentitySlice unmarshals a slice of IPsecPolicyIdentity instances from the specified list of maps.
func UnmarshalIPsecPolicyIdentitySlice(s []interface{}) (slice []IPsecPolicyIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'IPsecPolicyIdentity'")
			return
		}
		obj, e := UnmarshalIPsecPolicyIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalIPsecPolicyIdentityAsProperty unmarshals an instance of IPsecPolicyIdentity that is stored as a property
// within the specified map.
func UnmarshalIPsecPolicyIdentityAsProperty(m map[string]interface{}, propertyName string) (result IPsecPolicyIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'IPsecPolicyIdentity'", propertyName)
			return
		}
		result, err = UnmarshalIPsecPolicyIdentity(objMap)
	}
	return
}

// UnmarshalIPsecPolicyIdentitySliceAsProperty unmarshals a slice of IPsecPolicyIdentity instances that are stored as a property
// within the specified map.
func UnmarshalIPsecPolicyIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []IPsecPolicyIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'IPsecPolicyIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalIPsecPolicyIdentitySlice(vSlice)
	}
	return
}

// Image : Image struct
type Image struct {
	// The date and time that the image was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this image.
	Crn *string `json:"crn" validate:"required"`

	// Details for the stored image file.
	File *ImageFile `json:"file" validate:"required"`

	// The URL for this image.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this image.
	ID *string `json:"id" validate:"required"`

	// The minimum size (in gigabytes) of a volume onto which this image may be provisioned.
	//
	// This property may be absent if the image has a `status` of `pending`, `tentative`, or
	// `failed`.
	MinimumProvisionedSize *int64 `json:"minimum_provisioned_size,omitempty"`

	// The user-defined or system-provided name for this image.
	Name *string `json:"name" validate:"required"`

	// The operating system included in this image.
	OperatingSystem *OperatingSystem `json:"operating_system,omitempty"`

	// The resource group for this image.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The status of this image.
	Status *string `json:"status" validate:"required"`

	// Whether the image is publicly visible or private to the account.
	Visibility *string `json:"visibility" validate:"required"`
}

// Constants associated with the Image.Status property.
// The status of this image.
const (
	Image_Status_Available  = "available"
	Image_Status_Deleting   = "deleting"
	Image_Status_Deprecated = "deprecated"
	Image_Status_Failed     = "failed"
	Image_Status_Pending    = "pending"
	Image_Status_Tentative  = "tentative"
)

// Constants associated with the Image.Visibility property.
// Whether the image is publicly visible or private to the account.
const (
	Image_Visibility_Private = "private"
	Image_Visibility_Public  = "public"
)

// UnmarshalImage constructs an instance of Image from the specified map.
func UnmarshalImage(m map[string]interface{}) (result *Image, err error) {
	obj := new(Image)
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.File, err = UnmarshalImageFileAsProperty(m, "file")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.MinimumProvisionedSize, err = core.UnmarshalInt64(m, "minimum_provisioned_size")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.OperatingSystem, err = UnmarshalOperatingSystemAsProperty(m, "operating_system")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupReferenceAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Status, err = core.UnmarshalString(m, "status")
	if err != nil {
		return
	}
	obj.Visibility, err = core.UnmarshalString(m, "visibility")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalImageSlice unmarshals a slice of Image instances from the specified list of maps.
func UnmarshalImageSlice(s []interface{}) (slice []Image, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Image'")
			return
		}
		obj, e := UnmarshalImage(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalImageAsProperty unmarshals an instance of Image that is stored as a property
// within the specified map.
func UnmarshalImageAsProperty(m map[string]interface{}, propertyName string) (result *Image, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Image'", propertyName)
			return
		}
		result, err = UnmarshalImage(objMap)
	}
	return
}

// UnmarshalImageSliceAsProperty unmarshals a slice of Image instances that are stored as a property
// within the specified map.
func UnmarshalImageSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Image, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Image'", propertyName)
			return
		}
		slice, err = UnmarshalImageSlice(vSlice)
	}
	return
}

// ImageCollection : ImageCollection struct
type ImageCollection struct {
	// A reference to the first page of resources.
	First *ImageCollectionFirst `json:"first" validate:"required"`

	// Collection of images.
	Images []Image `json:"images" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *ImageCollectionNext `json:"next,omitempty"`
}

// UnmarshalImageCollection constructs an instance of ImageCollection from the specified map.
func UnmarshalImageCollection(m map[string]interface{}) (result *ImageCollection, err error) {
	obj := new(ImageCollection)
	obj.First, err = UnmarshalImageCollectionFirstAsProperty(m, "first")
	if err != nil {
		return
	}
	obj.Images, err = UnmarshalImageSliceAsProperty(m, "images")
	if err != nil {
		return
	}
	obj.Limit, err = core.UnmarshalInt64(m, "limit")
	if err != nil {
		return
	}
	obj.Next, err = UnmarshalImageCollectionNextAsProperty(m, "next")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalImageCollectionSlice unmarshals a slice of ImageCollection instances from the specified list of maps.
func UnmarshalImageCollectionSlice(s []interface{}) (slice []ImageCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ImageCollection'")
			return
		}
		obj, e := UnmarshalImageCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalImageCollectionAsProperty unmarshals an instance of ImageCollection that is stored as a property
// within the specified map.
func UnmarshalImageCollectionAsProperty(m map[string]interface{}, propertyName string) (result *ImageCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ImageCollection'", propertyName)
			return
		}
		result, err = UnmarshalImageCollection(objMap)
	}
	return
}

// UnmarshalImageCollectionSliceAsProperty unmarshals a slice of ImageCollection instances that are stored as a property
// within the specified map.
func UnmarshalImageCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ImageCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ImageCollection'", propertyName)
			return
		}
		slice, err = UnmarshalImageCollectionSlice(vSlice)
	}
	return
}

// ImageCollectionFirst : A reference to the first page of resources.
type ImageCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalImageCollectionFirst constructs an instance of ImageCollectionFirst from the specified map.
func UnmarshalImageCollectionFirst(m map[string]interface{}) (result *ImageCollectionFirst, err error) {
	obj := new(ImageCollectionFirst)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalImageCollectionFirstSlice unmarshals a slice of ImageCollectionFirst instances from the specified list of maps.
func UnmarshalImageCollectionFirstSlice(s []interface{}) (slice []ImageCollectionFirst, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ImageCollectionFirst'")
			return
		}
		obj, e := UnmarshalImageCollectionFirst(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalImageCollectionFirstAsProperty unmarshals an instance of ImageCollectionFirst that is stored as a property
// within the specified map.
func UnmarshalImageCollectionFirstAsProperty(m map[string]interface{}, propertyName string) (result *ImageCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ImageCollectionFirst'", propertyName)
			return
		}
		result, err = UnmarshalImageCollectionFirst(objMap)
	}
	return
}

// UnmarshalImageCollectionFirstSliceAsProperty unmarshals a slice of ImageCollectionFirst instances that are stored as a property
// within the specified map.
func UnmarshalImageCollectionFirstSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ImageCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ImageCollectionFirst'", propertyName)
			return
		}
		slice, err = UnmarshalImageCollectionFirstSlice(vSlice)
	}
	return
}

// ImageCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type ImageCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalImageCollectionNext constructs an instance of ImageCollectionNext from the specified map.
func UnmarshalImageCollectionNext(m map[string]interface{}) (result *ImageCollectionNext, err error) {
	obj := new(ImageCollectionNext)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalImageCollectionNextSlice unmarshals a slice of ImageCollectionNext instances from the specified list of maps.
func UnmarshalImageCollectionNextSlice(s []interface{}) (slice []ImageCollectionNext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ImageCollectionNext'")
			return
		}
		obj, e := UnmarshalImageCollectionNext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalImageCollectionNextAsProperty unmarshals an instance of ImageCollectionNext that is stored as a property
// within the specified map.
func UnmarshalImageCollectionNextAsProperty(m map[string]interface{}, propertyName string) (result *ImageCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ImageCollectionNext'", propertyName)
			return
		}
		result, err = UnmarshalImageCollectionNext(objMap)
	}
	return
}

// UnmarshalImageCollectionNextSliceAsProperty unmarshals a slice of ImageCollectionNext instances that are stored as a property
// within the specified map.
func UnmarshalImageCollectionNextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ImageCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ImageCollectionNext'", propertyName)
			return
		}
		slice, err = UnmarshalImageCollectionNextSlice(vSlice)
	}
	return
}

// ImageFile : ImageFile struct
type ImageFile struct {
	// The size of the stored image file rounded up to the next gigabyte.
	//
	// This property may be absent if the associated image has a `status` of `pending` or
	// `failed`.
	Size *int64 `json:"size,omitempty"`
}

// UnmarshalImageFile constructs an instance of ImageFile from the specified map.
func UnmarshalImageFile(m map[string]interface{}) (result *ImageFile, err error) {
	obj := new(ImageFile)
	obj.Size, err = core.UnmarshalInt64(m, "size")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalImageFileSlice unmarshals a slice of ImageFile instances from the specified list of maps.
func UnmarshalImageFileSlice(s []interface{}) (slice []ImageFile, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ImageFile'")
			return
		}
		obj, e := UnmarshalImageFile(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalImageFileAsProperty unmarshals an instance of ImageFile that is stored as a property
// within the specified map.
func UnmarshalImageFileAsProperty(m map[string]interface{}, propertyName string) (result *ImageFile, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ImageFile'", propertyName)
			return
		}
		result, err = UnmarshalImageFile(objMap)
	}
	return
}

// UnmarshalImageFileSliceAsProperty unmarshals a slice of ImageFile instances that are stored as a property
// within the specified map.
func UnmarshalImageFileSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ImageFile, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ImageFile'", propertyName)
			return
		}
		slice, err = UnmarshalImageFileSlice(vSlice)
	}
	return
}

// ImageFilePrototype : ImageFilePrototype struct
type ImageFilePrototype struct {
	// The Cloud Object Store (COS) location of the image file.
	Href *string `json:"href" validate:"required"`
}

// NewImageFilePrototype : Instantiate ImageFilePrototype (Generic Model Constructor)
func (*VpcV1) NewImageFilePrototype(href string) (model *ImageFilePrototype, err error) {
	model = &ImageFilePrototype{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalImageFilePrototype constructs an instance of ImageFilePrototype from the specified map.
func UnmarshalImageFilePrototype(m map[string]interface{}) (result *ImageFilePrototype, err error) {
	obj := new(ImageFilePrototype)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalImageFilePrototypeSlice unmarshals a slice of ImageFilePrototype instances from the specified list of maps.
func UnmarshalImageFilePrototypeSlice(s []interface{}) (slice []ImageFilePrototype, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ImageFilePrototype'")
			return
		}
		obj, e := UnmarshalImageFilePrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalImageFilePrototypeAsProperty unmarshals an instance of ImageFilePrototype that is stored as a property
// within the specified map.
func UnmarshalImageFilePrototypeAsProperty(m map[string]interface{}, propertyName string) (result *ImageFilePrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ImageFilePrototype'", propertyName)
			return
		}
		result, err = UnmarshalImageFilePrototype(objMap)
	}
	return
}

// UnmarshalImageFilePrototypeSliceAsProperty unmarshals a slice of ImageFilePrototype instances that are stored as a property
// within the specified map.
func UnmarshalImageFilePrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ImageFilePrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ImageFilePrototype'", propertyName)
			return
		}
		slice, err = UnmarshalImageFilePrototypeSlice(vSlice)
	}
	return
}

// ImageIdentity : Identifies an image by a unique property.
// Models which "extend" this model:
// - ImageIdentityByID
// - ImageIdentityByCRN
// - ImageIdentityByHref
type ImageIdentity struct {
	// The unique identifier for this image.
	ID *string `json:"id,omitempty"`

	// The CRN for this image.
	Crn *string `json:"crn,omitempty"`

	// The URL for this image.
	Href *string `json:"href,omitempty"`
}

func (*ImageIdentity) isaImageIdentity() bool {
	return true
}

type ImageIdentityIntf interface {
	isaImageIdentity() bool
}

// UnmarshalImageIdentity constructs an instance of ImageIdentity from the specified map.
func UnmarshalImageIdentity(m map[string]interface{}) (result ImageIdentityIntf, err error) {
	obj := new(ImageIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalImageIdentitySlice unmarshals a slice of ImageIdentity instances from the specified list of maps.
func UnmarshalImageIdentitySlice(s []interface{}) (slice []ImageIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ImageIdentity'")
			return
		}
		obj, e := UnmarshalImageIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalImageIdentityAsProperty unmarshals an instance of ImageIdentity that is stored as a property
// within the specified map.
func UnmarshalImageIdentityAsProperty(m map[string]interface{}, propertyName string) (result ImageIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ImageIdentity'", propertyName)
			return
		}
		result, err = UnmarshalImageIdentity(objMap)
	}
	return
}

// UnmarshalImageIdentitySliceAsProperty unmarshals a slice of ImageIdentity instances that are stored as a property
// within the specified map.
func UnmarshalImageIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []ImageIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ImageIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalImageIdentitySlice(vSlice)
	}
	return
}

// ImagePrototype : ImagePrototype struct
// Models which "extend" this model:
// - ImagePrototypeImageByFile
type ImagePrototype struct {
	// The unique user-defined name for this image. Names starting with "ibm-" are not allowed. If unspecified, the name
	// will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The file from which to create the image.
	File *ImageFilePrototype `json:"file,omitempty"`

	// The operating system included in this image.
	OperatingSystem OperatingSystemIdentityIntf `json:"operating_system,omitempty"`
}

func (*ImagePrototype) isaImagePrototype() bool {
	return true
}

type ImagePrototypeIntf interface {
	isaImagePrototype() bool
}

// UnmarshalImagePrototype constructs an instance of ImagePrototype from the specified map.
func UnmarshalImagePrototype(m map[string]interface{}) (result ImagePrototypeIntf, err error) {
	obj := new(ImagePrototype)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupIdentityAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.File, err = UnmarshalImageFilePrototypeAsProperty(m, "file")
	if err != nil {
		return
	}
	obj.OperatingSystem, err = UnmarshalOperatingSystemIdentityAsProperty(m, "operating_system")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalImagePrototypeSlice unmarshals a slice of ImagePrototype instances from the specified list of maps.
func UnmarshalImagePrototypeSlice(s []interface{}) (slice []ImagePrototypeIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ImagePrototype'")
			return
		}
		obj, e := UnmarshalImagePrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalImagePrototypeAsProperty unmarshals an instance of ImagePrototype that is stored as a property
// within the specified map.
func UnmarshalImagePrototypeAsProperty(m map[string]interface{}, propertyName string) (result ImagePrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ImagePrototype'", propertyName)
			return
		}
		result, err = UnmarshalImagePrototype(objMap)
	}
	return
}

// UnmarshalImagePrototypeSliceAsProperty unmarshals a slice of ImagePrototype instances that are stored as a property
// within the specified map.
func UnmarshalImagePrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ImagePrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ImagePrototype'", propertyName)
			return
		}
		slice, err = UnmarshalImagePrototypeSlice(vSlice)
	}
	return
}

// ImageReference : ImageReference struct
type ImageReference struct {
	// The CRN for this image.
	Crn *string `json:"crn" validate:"required"`

	// The URL for this image.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this image.
	ID *string `json:"id" validate:"required"`

	// The user-defined or system-provided name for this image.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalImageReference constructs an instance of ImageReference from the specified map.
func UnmarshalImageReference(m map[string]interface{}) (result *ImageReference, err error) {
	obj := new(ImageReference)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalImageReferenceSlice unmarshals a slice of ImageReference instances from the specified list of maps.
func UnmarshalImageReferenceSlice(s []interface{}) (slice []ImageReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ImageReference'")
			return
		}
		obj, e := UnmarshalImageReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalImageReferenceAsProperty unmarshals an instance of ImageReference that is stored as a property
// within the specified map.
func UnmarshalImageReferenceAsProperty(m map[string]interface{}, propertyName string) (result *ImageReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ImageReference'", propertyName)
			return
		}
		result, err = UnmarshalImageReference(objMap)
	}
	return
}

// UnmarshalImageReferenceSliceAsProperty unmarshals a slice of ImageReference instances that are stored as a property
// within the specified map.
func UnmarshalImageReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ImageReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ImageReference'", propertyName)
			return
		}
		slice, err = UnmarshalImageReferenceSlice(vSlice)
	}
	return
}

// Instance : Instance struct
type Instance struct {
	// The total bandwidth (in megabits per second) shared across the virtual server instance's network interfaces.
	Bandwidth *int64 `json:"bandwidth" validate:"required"`

	// Boot volume attachment.
	BootVolumeAttachment *VolumeAttachmentReferenceInstanceContext `json:"boot_volume_attachment" validate:"required"`

	// The date and time that the virtual server instance was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this virtual server instance.
	Crn *string `json:"crn" validate:"required"`

	// The virtual server instance GPU configuration.
	Gpu *InstanceGPU `json:"gpu,omitempty"`

	// The URL for this virtual server instance.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this virtual server instance.
	ID *string `json:"id" validate:"required"`

	// The image the virtual server instance was provisioned from.
	Image *ImageReference `json:"image,omitempty"`

	// The amount of memory in gigabytes.
	Memory *int64 `json:"memory" validate:"required"`

	// The user-defined name for this virtual server instance (and default system hostname).
	Name *string `json:"name" validate:"required"`

	// Collection of the virtual server instance's network interfaces, including the primary network interface.
	NetworkInterfaces []NetworkInterfaceInstanceContextReference `json:"network_interfaces" validate:"required"`

	// Primary network interface.
	PrimaryNetworkInterface *NetworkInterfaceInstanceContextReference `json:"primary_network_interface" validate:"required"`

	// The profile this virtual server instance uses.
	Profile *InstanceProfileReference `json:"profile" validate:"required"`

	// The resource group for this instance.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The status of the virtual server instance.
	Status *string `json:"status" validate:"required"`

	// The virtual server instance VCPU configuration.
	Vcpu *InstanceVCPU `json:"vcpu" validate:"required"`

	// Collection of the virtual server instance's volume attachments, including the boot volume attachment.
	VolumeAttachments []VolumeAttachmentReferenceInstanceContext `json:"volume_attachments" validate:"required"`

	// The VPC the virtual server instance resides in.
	Vpc *VPCReference `json:"vpc" validate:"required"`

	// The zone the virtual server instance resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the Instance.Status property.
// The status of the virtual server instance.
const (
	Instance_Status_Failed     = "failed"
	Instance_Status_Paused     = "paused"
	Instance_Status_Pausing    = "pausing"
	Instance_Status_Pending    = "pending"
	Instance_Status_Restarting = "restarting"
	Instance_Status_Resuming   = "resuming"
	Instance_Status_Running    = "running"
	Instance_Status_Starting   = "starting"
	Instance_Status_Stopped    = "stopped"
	Instance_Status_Stopping   = "stopping"
)

// UnmarshalInstance constructs an instance of Instance from the specified map.
func UnmarshalInstance(m map[string]interface{}) (result *Instance, err error) {
	obj := new(Instance)
	obj.Bandwidth, err = core.UnmarshalInt64(m, "bandwidth")
	if err != nil {
		return
	}
	obj.BootVolumeAttachment, err = UnmarshalVolumeAttachmentReferenceInstanceContextAsProperty(m, "boot_volume_attachment")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Gpu, err = UnmarshalInstanceGPUAsProperty(m, "gpu")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Image, err = UnmarshalImageReferenceAsProperty(m, "image")
	if err != nil {
		return
	}
	obj.Memory, err = core.UnmarshalInt64(m, "memory")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.NetworkInterfaces, err = UnmarshalNetworkInterfaceInstanceContextReferenceSliceAsProperty(m, "network_interfaces")
	if err != nil {
		return
	}
	obj.PrimaryNetworkInterface, err = UnmarshalNetworkInterfaceInstanceContextReferenceAsProperty(m, "primary_network_interface")
	if err != nil {
		return
	}
	obj.Profile, err = UnmarshalInstanceProfileReferenceAsProperty(m, "profile")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupReferenceAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Status, err = core.UnmarshalString(m, "status")
	if err != nil {
		return
	}
	obj.Vcpu, err = UnmarshalInstanceVCPUAsProperty(m, "vcpu")
	if err != nil {
		return
	}
	obj.VolumeAttachments, err = UnmarshalVolumeAttachmentReferenceInstanceContextSliceAsProperty(m, "volume_attachments")
	if err != nil {
		return
	}
	obj.Vpc, err = UnmarshalVPCReferenceAsProperty(m, "vpc")
	if err != nil {
		return
	}
	obj.Zone, err = UnmarshalZoneReferenceAsProperty(m, "zone")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceSlice unmarshals a slice of Instance instances from the specified list of maps.
func UnmarshalInstanceSlice(s []interface{}) (slice []Instance, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Instance'")
			return
		}
		obj, e := UnmarshalInstance(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceAsProperty unmarshals an instance of Instance that is stored as a property
// within the specified map.
func UnmarshalInstanceAsProperty(m map[string]interface{}, propertyName string) (result *Instance, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Instance'", propertyName)
			return
		}
		result, err = UnmarshalInstance(objMap)
	}
	return
}

// UnmarshalInstanceSliceAsProperty unmarshals a slice of Instance instances that are stored as a property
// within the specified map.
func UnmarshalInstanceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Instance, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Instance'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceSlice(vSlice)
	}
	return
}

// InstanceAction : InstanceAction struct
type InstanceAction struct {
	// The date and time that the action was completed.
	CompletedAt *strfmt.DateTime `json:"completed_at,omitempty"`

	// The date and time that the action was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// If set to true, the action will be forced immediately, and all queued actions deleted. Ignored for the start action.
	Force *bool `json:"force,omitempty"`

	// The URL for this instance action.
	Href *string `json:"href" validate:"required"`

	// The identifier for this instance action.
	ID *string `json:"id" validate:"required"`

	// The date and time that the action was started.
	StartedAt *strfmt.DateTime `json:"started_at,omitempty"`

	// The current status of this action.
	Status *string `json:"status" validate:"required"`

	// The type of action.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceAction.Status property.
// The current status of this action.
const (
	InstanceAction_Status_Completed = "completed"
	InstanceAction_Status_Failed    = "failed"
	InstanceAction_Status_Pending   = "pending"
	InstanceAction_Status_Running   = "running"
)

// Constants associated with the InstanceAction.Type property.
// The type of action.
const (
	InstanceAction_Type_Reboot = "reboot"
	InstanceAction_Type_Start  = "start"
	InstanceAction_Type_Stop   = "stop"
)

// UnmarshalInstanceAction constructs an instance of InstanceAction from the specified map.
func UnmarshalInstanceAction(m map[string]interface{}) (result *InstanceAction, err error) {
	obj := new(InstanceAction)
	obj.CompletedAt, err = core.UnmarshalDateTime(m, "completed_at")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Force, err = core.UnmarshalBool(m, "force")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.StartedAt, err = core.UnmarshalDateTime(m, "started_at")
	if err != nil {
		return
	}
	obj.Status, err = core.UnmarshalString(m, "status")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceActionSlice unmarshals a slice of InstanceAction instances from the specified list of maps.
func UnmarshalInstanceActionSlice(s []interface{}) (slice []InstanceAction, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceAction'")
			return
		}
		obj, e := UnmarshalInstanceAction(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceActionAsProperty unmarshals an instance of InstanceAction that is stored as a property
// within the specified map.
func UnmarshalInstanceActionAsProperty(m map[string]interface{}, propertyName string) (result *InstanceAction, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceAction'", propertyName)
			return
		}
		result, err = UnmarshalInstanceAction(objMap)
	}
	return
}

// UnmarshalInstanceActionSliceAsProperty unmarshals a slice of InstanceAction instances that are stored as a property
// within the specified map.
func UnmarshalInstanceActionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceAction, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceAction'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceActionSlice(vSlice)
	}
	return
}

// InstanceCollection : InstanceCollection struct
type InstanceCollection struct {
	// A reference to the first page of resources.
	First *InstanceCollectionFirst `json:"first" validate:"required"`

	// Collection of virtual server instances.
	Instances []Instance `json:"instances" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *InstanceCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalInstanceCollection constructs an instance of InstanceCollection from the specified map.
func UnmarshalInstanceCollection(m map[string]interface{}) (result *InstanceCollection, err error) {
	obj := new(InstanceCollection)
	obj.First, err = UnmarshalInstanceCollectionFirstAsProperty(m, "first")
	if err != nil {
		return
	}
	obj.Instances, err = UnmarshalInstanceSliceAsProperty(m, "instances")
	if err != nil {
		return
	}
	obj.Limit, err = core.UnmarshalInt64(m, "limit")
	if err != nil {
		return
	}
	obj.Next, err = UnmarshalInstanceCollectionNextAsProperty(m, "next")
	if err != nil {
		return
	}
	obj.TotalCount, err = core.UnmarshalInt64(m, "total_count")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceCollectionSlice unmarshals a slice of InstanceCollection instances from the specified list of maps.
func UnmarshalInstanceCollectionSlice(s []interface{}) (slice []InstanceCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceCollection'")
			return
		}
		obj, e := UnmarshalInstanceCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceCollectionAsProperty unmarshals an instance of InstanceCollection that is stored as a property
// within the specified map.
func UnmarshalInstanceCollectionAsProperty(m map[string]interface{}, propertyName string) (result *InstanceCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceCollection'", propertyName)
			return
		}
		result, err = UnmarshalInstanceCollection(objMap)
	}
	return
}

// UnmarshalInstanceCollectionSliceAsProperty unmarshals a slice of InstanceCollection instances that are stored as a property
// within the specified map.
func UnmarshalInstanceCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceCollection'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceCollectionSlice(vSlice)
	}
	return
}

// InstanceCollectionFirst : A reference to the first page of resources.
type InstanceCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceCollectionFirst constructs an instance of InstanceCollectionFirst from the specified map.
func UnmarshalInstanceCollectionFirst(m map[string]interface{}) (result *InstanceCollectionFirst, err error) {
	obj := new(InstanceCollectionFirst)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceCollectionFirstSlice unmarshals a slice of InstanceCollectionFirst instances from the specified list of maps.
func UnmarshalInstanceCollectionFirstSlice(s []interface{}) (slice []InstanceCollectionFirst, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceCollectionFirst'")
			return
		}
		obj, e := UnmarshalInstanceCollectionFirst(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceCollectionFirstAsProperty unmarshals an instance of InstanceCollectionFirst that is stored as a property
// within the specified map.
func UnmarshalInstanceCollectionFirstAsProperty(m map[string]interface{}, propertyName string) (result *InstanceCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceCollectionFirst'", propertyName)
			return
		}
		result, err = UnmarshalInstanceCollectionFirst(objMap)
	}
	return
}

// UnmarshalInstanceCollectionFirstSliceAsProperty unmarshals a slice of InstanceCollectionFirst instances that are stored as a property
// within the specified map.
func UnmarshalInstanceCollectionFirstSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceCollectionFirst'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceCollectionFirstSlice(vSlice)
	}
	return
}

// InstanceCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type InstanceCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceCollectionNext constructs an instance of InstanceCollectionNext from the specified map.
func UnmarshalInstanceCollectionNext(m map[string]interface{}) (result *InstanceCollectionNext, err error) {
	obj := new(InstanceCollectionNext)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceCollectionNextSlice unmarshals a slice of InstanceCollectionNext instances from the specified list of maps.
func UnmarshalInstanceCollectionNextSlice(s []interface{}) (slice []InstanceCollectionNext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceCollectionNext'")
			return
		}
		obj, e := UnmarshalInstanceCollectionNext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceCollectionNextAsProperty unmarshals an instance of InstanceCollectionNext that is stored as a property
// within the specified map.
func UnmarshalInstanceCollectionNextAsProperty(m map[string]interface{}, propertyName string) (result *InstanceCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceCollectionNext'", propertyName)
			return
		}
		result, err = UnmarshalInstanceCollectionNext(objMap)
	}
	return
}

// UnmarshalInstanceCollectionNextSliceAsProperty unmarshals a slice of InstanceCollectionNext instances that are stored as a property
// within the specified map.
func UnmarshalInstanceCollectionNextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceCollectionNext'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceCollectionNextSlice(vSlice)
	}
	return
}

// InstanceGPU : The virtual server instance GPU configuration.
type InstanceGPU struct {
	// The number of GPUs assigned to the instance.
	Count *int64 `json:"count" validate:"required"`

	// The GPU manufacturer.
	Manufacturer *string `json:"manufacturer" validate:"required"`

	// The overall amount of GPU memory in GiB (gibibytes).
	Memory *int64 `json:"memory" validate:"required"`

	// The GPU model.
	Model *string `json:"model" validate:"required"`
}

// UnmarshalInstanceGPU constructs an instance of InstanceGPU from the specified map.
func UnmarshalInstanceGPU(m map[string]interface{}) (result *InstanceGPU, err error) {
	obj := new(InstanceGPU)
	obj.Count, err = core.UnmarshalInt64(m, "count")
	if err != nil {
		return
	}
	obj.Manufacturer, err = core.UnmarshalString(m, "manufacturer")
	if err != nil {
		return
	}
	obj.Memory, err = core.UnmarshalInt64(m, "memory")
	if err != nil {
		return
	}
	obj.Model, err = core.UnmarshalString(m, "model")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceGPUSlice unmarshals a slice of InstanceGPU instances from the specified list of maps.
func UnmarshalInstanceGPUSlice(s []interface{}) (slice []InstanceGPU, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceGPU'")
			return
		}
		obj, e := UnmarshalInstanceGPU(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceGPUAsProperty unmarshals an instance of InstanceGPU that is stored as a property
// within the specified map.
func UnmarshalInstanceGPUAsProperty(m map[string]interface{}, propertyName string) (result *InstanceGPU, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceGPU'", propertyName)
			return
		}
		result, err = UnmarshalInstanceGPU(objMap)
	}
	return
}

// UnmarshalInstanceGPUSliceAsProperty unmarshals a slice of InstanceGPU instances that are stored as a property
// within the specified map.
func UnmarshalInstanceGPUSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceGPU, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceGPU'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceGPUSlice(vSlice)
	}
	return
}

// InstanceInitialization : InstanceInitialization struct
type InstanceInitialization struct {
	// Collection of references to public SSH keys used at instance initialization.
	Keys []KeyReferenceInstanceInitializationContextIntf `json:"keys" validate:"required"`

	Password *InstanceInitializationPassword `json:"password,omitempty"`
}

// UnmarshalInstanceInitialization constructs an instance of InstanceInitialization from the specified map.
func UnmarshalInstanceInitialization(m map[string]interface{}) (result *InstanceInitialization, err error) {
	obj := new(InstanceInitialization)
	obj.Keys, err = UnmarshalKeyReferenceInstanceInitializationContextSliceAsProperty(m, "keys")
	if err != nil {
		return
	}
	obj.Password, err = UnmarshalInstanceInitializationPasswordAsProperty(m, "password")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceInitializationSlice unmarshals a slice of InstanceInitialization instances from the specified list of maps.
func UnmarshalInstanceInitializationSlice(s []interface{}) (slice []InstanceInitialization, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceInitialization'")
			return
		}
		obj, e := UnmarshalInstanceInitialization(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceInitializationAsProperty unmarshals an instance of InstanceInitialization that is stored as a property
// within the specified map.
func UnmarshalInstanceInitializationAsProperty(m map[string]interface{}, propertyName string) (result *InstanceInitialization, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceInitialization'", propertyName)
			return
		}
		result, err = UnmarshalInstanceInitialization(objMap)
	}
	return
}

// UnmarshalInstanceInitializationSliceAsProperty unmarshals a slice of InstanceInitialization instances that are stored as a property
// within the specified map.
func UnmarshalInstanceInitializationSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceInitialization, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceInitialization'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceInitializationSlice(vSlice)
	}
	return
}

// InstanceInitializationPassword : InstanceInitializationPassword struct
type InstanceInitializationPassword struct {
	// The administrator password at initialization, encrypted using `encryption_key`, and returned base64-encoded.
	EncryptedPassword *[]byte `json:"encrypted_password" validate:"required"`

	// The reference to the public SSH key used to encrypt the administrator password.
	EncryptionKey KeyReferenceInstanceInitializationContextIntf `json:"encryption_key" validate:"required"`
}

// UnmarshalInstanceInitializationPassword constructs an instance of InstanceInitializationPassword from the specified map.
func UnmarshalInstanceInitializationPassword(m map[string]interface{}) (result *InstanceInitializationPassword, err error) {
	obj := new(InstanceInitializationPassword)
	obj.EncryptedPassword, err = core.UnmarshalByteArray(m, "encrypted_password")
	if err != nil {
		return
	}
	obj.EncryptionKey, err = UnmarshalKeyReferenceInstanceInitializationContextAsProperty(m, "encryption_key")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceInitializationPasswordSlice unmarshals a slice of InstanceInitializationPassword instances from the specified list of maps.
func UnmarshalInstanceInitializationPasswordSlice(s []interface{}) (slice []InstanceInitializationPassword, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceInitializationPassword'")
			return
		}
		obj, e := UnmarshalInstanceInitializationPassword(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceInitializationPasswordAsProperty unmarshals an instance of InstanceInitializationPassword that is stored as a property
// within the specified map.
func UnmarshalInstanceInitializationPasswordAsProperty(m map[string]interface{}, propertyName string) (result *InstanceInitializationPassword, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceInitializationPassword'", propertyName)
			return
		}
		result, err = UnmarshalInstanceInitializationPassword(objMap)
	}
	return
}

// UnmarshalInstanceInitializationPasswordSliceAsProperty unmarshals a slice of InstanceInitializationPassword instances that are stored as a property
// within the specified map.
func UnmarshalInstanceInitializationPasswordSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceInitializationPassword, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceInitializationPassword'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceInitializationPasswordSlice(vSlice)
	}
	return
}

// InstanceProfile : InstanceProfile struct
type InstanceProfile struct {
	Bandwidth InstanceProfileBandwidthIntf `json:"bandwidth" validate:"required"`

	// The product family this virtual server instance profile belongs to.
	Family *string `json:"family,omitempty"`

	// The URL for this virtual server instance profile.
	Href *string `json:"href" validate:"required"`

	Memory InstanceProfileMemoryIntf `json:"memory" validate:"required"`

	// The name for this virtual server instance profile.
	Name *string `json:"name" validate:"required"`

	OsArchitecture *InstanceProfileOSArchitecture `json:"os_architecture" validate:"required"`

	PortSpeed InstanceProfilePortSpeedIntf `json:"port_speed" validate:"required"`

	VcpuArchitecture *InstanceProfileVCPUArchitecture `json:"vcpu_architecture" validate:"required"`

	VcpuCount InstanceProfileVCPUIntf `json:"vcpu_count" validate:"required"`
}

// UnmarshalInstanceProfile constructs an instance of InstanceProfile from the specified map.
func UnmarshalInstanceProfile(m map[string]interface{}) (result *InstanceProfile, err error) {
	obj := new(InstanceProfile)
	obj.Bandwidth, err = UnmarshalInstanceProfileBandwidthAsProperty(m, "bandwidth")
	if err != nil {
		return
	}
	obj.Family, err = core.UnmarshalString(m, "family")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.Memory, err = UnmarshalInstanceProfileMemoryAsProperty(m, "memory")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.OsArchitecture, err = UnmarshalInstanceProfileOSArchitectureAsProperty(m, "os_architecture")
	if err != nil {
		return
	}
	obj.PortSpeed, err = UnmarshalInstanceProfilePortSpeedAsProperty(m, "port_speed")
	if err != nil {
		return
	}
	obj.VcpuArchitecture, err = UnmarshalInstanceProfileVCPUArchitectureAsProperty(m, "vcpu_architecture")
	if err != nil {
		return
	}
	obj.VcpuCount, err = UnmarshalInstanceProfileVCPUAsProperty(m, "vcpu_count")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileSlice unmarshals a slice of InstanceProfile instances from the specified list of maps.
func UnmarshalInstanceProfileSlice(s []interface{}) (slice []InstanceProfile, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfile'")
			return
		}
		obj, e := UnmarshalInstanceProfile(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfileAsProperty unmarshals an instance of InstanceProfile that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfile, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfile'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfile(objMap)
	}
	return
}

// UnmarshalInstanceProfileSliceAsProperty unmarshals a slice of InstanceProfile instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfile, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfile'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileSlice(vSlice)
	}
	return
}

// InstanceProfileBandwidth : InstanceProfileBandwidth struct
// Models which "extend" this model:
// - InstanceProfileBandwidthFixed
// - InstanceProfileBandwidthRange
// - InstanceProfileBandwidthEnum
// - InstanceProfileBandwidthDependent
type InstanceProfileBandwidth struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the InstanceProfileBandwidth.Type property.
// The type for this profile field.
const (
	InstanceProfileBandwidth_Type_Fixed = "fixed"
)

func (*InstanceProfileBandwidth) isaInstanceProfileBandwidth() bool {
	return true
}

type InstanceProfileBandwidthIntf interface {
	isaInstanceProfileBandwidth() bool
}

// UnmarshalInstanceProfileBandwidth constructs an instance of InstanceProfileBandwidth from the specified map.
func UnmarshalInstanceProfileBandwidth(m map[string]interface{}) (result InstanceProfileBandwidthIntf, err error) {
	obj := new(InstanceProfileBandwidth)
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.Value, err = core.UnmarshalInt64(m, "value")
	if err != nil {
		return
	}
	obj.Default, err = core.UnmarshalInt64(m, "default")
	if err != nil {
		return
	}
	obj.Max, err = core.UnmarshalInt64(m, "max")
	if err != nil {
		return
	}
	obj.Min, err = core.UnmarshalInt64(m, "min")
	if err != nil {
		return
	}
	obj.Step, err = core.UnmarshalInt64(m, "step")
	if err != nil {
		return
	}
	obj.Values, err = core.UnmarshalInt64Slice(m, "values")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileBandwidthSlice unmarshals a slice of InstanceProfileBandwidth instances from the specified list of maps.
func UnmarshalInstanceProfileBandwidthSlice(s []interface{}) (slice []InstanceProfileBandwidthIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileBandwidth'")
			return
		}
		obj, e := UnmarshalInstanceProfileBandwidth(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalInstanceProfileBandwidthAsProperty unmarshals an instance of InstanceProfileBandwidth that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileBandwidthAsProperty(m map[string]interface{}, propertyName string) (result InstanceProfileBandwidthIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileBandwidth'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileBandwidth(objMap)
	}
	return
}

// UnmarshalInstanceProfileBandwidthSliceAsProperty unmarshals a slice of InstanceProfileBandwidth instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileBandwidthSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileBandwidthIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileBandwidth'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileBandwidthSlice(vSlice)
	}
	return
}

// InstanceProfileCollection : InstanceProfileCollection struct
type InstanceProfileCollection struct {
	// Collection of virtual server instance profiles.
	Profiles []InstanceProfile `json:"profiles" validate:"required"`
}

// UnmarshalInstanceProfileCollection constructs an instance of InstanceProfileCollection from the specified map.
func UnmarshalInstanceProfileCollection(m map[string]interface{}) (result *InstanceProfileCollection, err error) {
	obj := new(InstanceProfileCollection)
	obj.Profiles, err = UnmarshalInstanceProfileSliceAsProperty(m, "profiles")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileCollectionSlice unmarshals a slice of InstanceProfileCollection instances from the specified list of maps.
func UnmarshalInstanceProfileCollectionSlice(s []interface{}) (slice []InstanceProfileCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileCollection'")
			return
		}
		obj, e := UnmarshalInstanceProfileCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfileCollectionAsProperty unmarshals an instance of InstanceProfileCollection that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileCollectionAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfileCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileCollection'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileCollection(objMap)
	}
	return
}

// UnmarshalInstanceProfileCollectionSliceAsProperty unmarshals a slice of InstanceProfileCollection instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileCollection'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileCollectionSlice(vSlice)
	}
	return
}

// InstanceProfileIdentity : Identifies an instance profile by a unique property.
// Models which "extend" this model:
// - InstanceProfileIdentityByName
// - InstanceProfileIdentityByHref
type InstanceProfileIdentity struct {
	// The name for this virtual server instance profile.
	Name *string `json:"name,omitempty"`

	// The URL for this virtual server instance profile.
	Href *string `json:"href,omitempty"`
}

func (*InstanceProfileIdentity) isaInstanceProfileIdentity() bool {
	return true
}

type InstanceProfileIdentityIntf interface {
	isaInstanceProfileIdentity() bool
}

// UnmarshalInstanceProfileIdentity constructs an instance of InstanceProfileIdentity from the specified map.
func UnmarshalInstanceProfileIdentity(m map[string]interface{}) (result InstanceProfileIdentityIntf, err error) {
	obj := new(InstanceProfileIdentity)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileIdentitySlice unmarshals a slice of InstanceProfileIdentity instances from the specified list of maps.
func UnmarshalInstanceProfileIdentitySlice(s []interface{}) (slice []InstanceProfileIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileIdentity'")
			return
		}
		obj, e := UnmarshalInstanceProfileIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalInstanceProfileIdentityAsProperty unmarshals an instance of InstanceProfileIdentity that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileIdentityAsProperty(m map[string]interface{}, propertyName string) (result InstanceProfileIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileIdentity'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileIdentity(objMap)
	}
	return
}

// UnmarshalInstanceProfileIdentitySliceAsProperty unmarshals a slice of InstanceProfileIdentity instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileIdentitySlice(vSlice)
	}
	return
}

// InstanceProfileMemory : InstanceProfileMemory struct
// Models which "extend" this model:
// - InstanceProfileMemoryFixed
// - InstanceProfileMemoryRange
// - InstanceProfileMemoryEnum
// - InstanceProfileMemoryDependent
type InstanceProfileMemory struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the InstanceProfileMemory.Type property.
// The type for this profile field.
const (
	InstanceProfileMemory_Type_Fixed = "fixed"
)

func (*InstanceProfileMemory) isaInstanceProfileMemory() bool {
	return true
}

type InstanceProfileMemoryIntf interface {
	isaInstanceProfileMemory() bool
}

// UnmarshalInstanceProfileMemory constructs an instance of InstanceProfileMemory from the specified map.
func UnmarshalInstanceProfileMemory(m map[string]interface{}) (result InstanceProfileMemoryIntf, err error) {
	obj := new(InstanceProfileMemory)
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.Value, err = core.UnmarshalInt64(m, "value")
	if err != nil {
		return
	}
	obj.Default, err = core.UnmarshalInt64(m, "default")
	if err != nil {
		return
	}
	obj.Max, err = core.UnmarshalInt64(m, "max")
	if err != nil {
		return
	}
	obj.Min, err = core.UnmarshalInt64(m, "min")
	if err != nil {
		return
	}
	obj.Step, err = core.UnmarshalInt64(m, "step")
	if err != nil {
		return
	}
	obj.Values, err = core.UnmarshalInt64Slice(m, "values")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileMemorySlice unmarshals a slice of InstanceProfileMemory instances from the specified list of maps.
func UnmarshalInstanceProfileMemorySlice(s []interface{}) (slice []InstanceProfileMemoryIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileMemory'")
			return
		}
		obj, e := UnmarshalInstanceProfileMemory(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalInstanceProfileMemoryAsProperty unmarshals an instance of InstanceProfileMemory that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileMemoryAsProperty(m map[string]interface{}, propertyName string) (result InstanceProfileMemoryIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileMemory'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileMemory(objMap)
	}
	return
}

// UnmarshalInstanceProfileMemorySliceAsProperty unmarshals a slice of InstanceProfileMemory instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileMemorySliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileMemoryIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileMemory'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileMemorySlice(vSlice)
	}
	return
}

// InstanceProfileOSArchitecture : InstanceProfileOSArchitecture struct
type InstanceProfileOSArchitecture struct {
	// The default OS architecture for an instance with this profile.
	Default *string `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The supported OS architecture(s) for an instance with this profile.
	Values []string `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileOSArchitecture.Type property.
// The type for this profile field.
const (
	InstanceProfileOSArchitecture_Type_Enum = "enum"
)

// UnmarshalInstanceProfileOSArchitecture constructs an instance of InstanceProfileOSArchitecture from the specified map.
func UnmarshalInstanceProfileOSArchitecture(m map[string]interface{}) (result *InstanceProfileOSArchitecture, err error) {
	obj := new(InstanceProfileOSArchitecture)
	obj.Default, err = core.UnmarshalString(m, "default")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.Values, err = core.UnmarshalStringSlice(m, "values")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileOSArchitectureSlice unmarshals a slice of InstanceProfileOSArchitecture instances from the specified list of maps.
func UnmarshalInstanceProfileOSArchitectureSlice(s []interface{}) (slice []InstanceProfileOSArchitecture, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileOSArchitecture'")
			return
		}
		obj, e := UnmarshalInstanceProfileOSArchitecture(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfileOSArchitectureAsProperty unmarshals an instance of InstanceProfileOSArchitecture that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileOSArchitectureAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfileOSArchitecture, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileOSArchitecture'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileOSArchitecture(objMap)
	}
	return
}

// UnmarshalInstanceProfileOSArchitectureSliceAsProperty unmarshals a slice of InstanceProfileOSArchitecture instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileOSArchitectureSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileOSArchitecture, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileOSArchitecture'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileOSArchitectureSlice(vSlice)
	}
	return
}

// InstanceProfilePortSpeed : InstanceProfilePortSpeed struct
// Models which "extend" this model:
// - InstanceProfilePortSpeedFixed
// - InstanceProfilePortSpeedDependent
type InstanceProfilePortSpeed struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`
}

// Constants associated with the InstanceProfilePortSpeed.Type property.
// The type for this profile field.
const (
	InstanceProfilePortSpeed_Type_Fixed = "fixed"
)

func (*InstanceProfilePortSpeed) isaInstanceProfilePortSpeed() bool {
	return true
}

type InstanceProfilePortSpeedIntf interface {
	isaInstanceProfilePortSpeed() bool
}

// UnmarshalInstanceProfilePortSpeed constructs an instance of InstanceProfilePortSpeed from the specified map.
func UnmarshalInstanceProfilePortSpeed(m map[string]interface{}) (result InstanceProfilePortSpeedIntf, err error) {
	obj := new(InstanceProfilePortSpeed)
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.Value, err = core.UnmarshalInt64(m, "value")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfilePortSpeedSlice unmarshals a slice of InstanceProfilePortSpeed instances from the specified list of maps.
func UnmarshalInstanceProfilePortSpeedSlice(s []interface{}) (slice []InstanceProfilePortSpeedIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfilePortSpeed'")
			return
		}
		obj, e := UnmarshalInstanceProfilePortSpeed(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalInstanceProfilePortSpeedAsProperty unmarshals an instance of InstanceProfilePortSpeed that is stored as a property
// within the specified map.
func UnmarshalInstanceProfilePortSpeedAsProperty(m map[string]interface{}, propertyName string) (result InstanceProfilePortSpeedIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfilePortSpeed'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfilePortSpeed(objMap)
	}
	return
}

// UnmarshalInstanceProfilePortSpeedSliceAsProperty unmarshals a slice of InstanceProfilePortSpeed instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfilePortSpeedSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfilePortSpeedIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfilePortSpeed'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfilePortSpeedSlice(vSlice)
	}
	return
}

// InstanceProfileReference : InstanceProfileReference struct
type InstanceProfileReference struct {
	// The URL for this virtual server instance profile.
	Href *string `json:"href" validate:"required"`

	// The name for this virtual server instance profile.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalInstanceProfileReference constructs an instance of InstanceProfileReference from the specified map.
func UnmarshalInstanceProfileReference(m map[string]interface{}) (result *InstanceProfileReference, err error) {
	obj := new(InstanceProfileReference)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileReferenceSlice unmarshals a slice of InstanceProfileReference instances from the specified list of maps.
func UnmarshalInstanceProfileReferenceSlice(s []interface{}) (slice []InstanceProfileReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileReference'")
			return
		}
		obj, e := UnmarshalInstanceProfileReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfileReferenceAsProperty unmarshals an instance of InstanceProfileReference that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileReferenceAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfileReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileReference'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileReference(objMap)
	}
	return
}

// UnmarshalInstanceProfileReferenceSliceAsProperty unmarshals a slice of InstanceProfileReference instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileReference'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileReferenceSlice(vSlice)
	}
	return
}

// InstanceProfileVCPU : InstanceProfileVCPU struct
// Models which "extend" this model:
// - InstanceProfileVCPUFixed
// - InstanceProfileVCPURange
// - InstanceProfileVCPUEnum
// - InstanceProfileVCPUDependent
type InstanceProfileVCPU struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the InstanceProfileVCPU.Type property.
// The type for this profile field.
const (
	InstanceProfileVCPU_Type_Fixed = "fixed"
)

func (*InstanceProfileVCPU) isaInstanceProfileVCPU() bool {
	return true
}

type InstanceProfileVCPUIntf interface {
	isaInstanceProfileVCPU() bool
}

// UnmarshalInstanceProfileVCPU constructs an instance of InstanceProfileVCPU from the specified map.
func UnmarshalInstanceProfileVCPU(m map[string]interface{}) (result InstanceProfileVCPUIntf, err error) {
	obj := new(InstanceProfileVCPU)
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.Value, err = core.UnmarshalInt64(m, "value")
	if err != nil {
		return
	}
	obj.Default, err = core.UnmarshalInt64(m, "default")
	if err != nil {
		return
	}
	obj.Max, err = core.UnmarshalInt64(m, "max")
	if err != nil {
		return
	}
	obj.Min, err = core.UnmarshalInt64(m, "min")
	if err != nil {
		return
	}
	obj.Step, err = core.UnmarshalInt64(m, "step")
	if err != nil {
		return
	}
	obj.Values, err = core.UnmarshalInt64Slice(m, "values")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileVCPUSlice unmarshals a slice of InstanceProfileVCPU instances from the specified list of maps.
func UnmarshalInstanceProfileVCPUSlice(s []interface{}) (slice []InstanceProfileVCPUIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileVCPU'")
			return
		}
		obj, e := UnmarshalInstanceProfileVCPU(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalInstanceProfileVCPUAsProperty unmarshals an instance of InstanceProfileVCPU that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileVCPUAsProperty(m map[string]interface{}, propertyName string) (result InstanceProfileVCPUIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileVCPU'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileVCPU(objMap)
	}
	return
}

// UnmarshalInstanceProfileVCPUSliceAsProperty unmarshals a slice of InstanceProfileVCPU instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileVCPUSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileVCPUIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileVCPU'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileVCPUSlice(vSlice)
	}
	return
}

// InstanceProfileVCPUArchitecture : InstanceProfileVCPUArchitecture struct
type InstanceProfileVCPUArchitecture struct {
	// The default VCPU architecture for an instance with this profile.
	Default *string `json:"default,omitempty"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The VCPU architecture for an instance with this profile.
	Value *string `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileVCPUArchitecture.Type property.
// The type for this profile field.
const (
	InstanceProfileVCPUArchitecture_Type_Fixed = "fixed"
)

// UnmarshalInstanceProfileVCPUArchitecture constructs an instance of InstanceProfileVCPUArchitecture from the specified map.
func UnmarshalInstanceProfileVCPUArchitecture(m map[string]interface{}) (result *InstanceProfileVCPUArchitecture, err error) {
	obj := new(InstanceProfileVCPUArchitecture)
	obj.Default, err = core.UnmarshalString(m, "default")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.Value, err = core.UnmarshalString(m, "value")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileVCPUArchitectureSlice unmarshals a slice of InstanceProfileVCPUArchitecture instances from the specified list of maps.
func UnmarshalInstanceProfileVCPUArchitectureSlice(s []interface{}) (slice []InstanceProfileVCPUArchitecture, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileVCPUArchitecture'")
			return
		}
		obj, e := UnmarshalInstanceProfileVCPUArchitecture(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfileVCPUArchitectureAsProperty unmarshals an instance of InstanceProfileVCPUArchitecture that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileVCPUArchitectureAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfileVCPUArchitecture, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileVCPUArchitecture'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileVCPUArchitecture(objMap)
	}
	return
}

// UnmarshalInstanceProfileVCPUArchitectureSliceAsProperty unmarshals a slice of InstanceProfileVCPUArchitecture instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileVCPUArchitectureSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileVCPUArchitecture, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileVCPUArchitecture'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileVCPUArchitectureSlice(vSlice)
	}
	return
}

// InstancePrototype : InstancePrototype struct
// Models which "extend" this model:
// - InstancePrototypeInstanceByImage
type InstancePrototype struct {
	// The public SSH keys to install on the virtual server instance. Up to 10 keys may be provided; if no keys are
	// provided the instance will be inaccessible unless the image used provides a means of access. For Windows instances,
	// one of the keys will be used to encrypt the administrator password.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	// The unique user-defined name for this virtual server instance (and default system hostname). If unspecified, the
	// name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Collection of additional network interfaces to create for the virtual server instance.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The profile to use for this virtual server instance.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// User data to be made available when setting up the virtual server instance.
	UserData *string `json:"user_data,omitempty"`

	// Collection of volume attachments.
	VolumeAttachments []VolumeAttachmentPrototypeInstanceContext `json:"volume_attachments,omitempty"`

	// The VPC the virtual server instance is to be a part of. If provided, must match the
	// VPC tied to the subnets of the instance's network interfaces.
	Vpc VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The identity of the image to be used when provisioning the virtual server instance.
	Image ImageIdentityIntf `json:"image,omitempty"`

	// Primary network interface.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface,omitempty"`

	// The identity of the zone to provision the virtual server instance in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`
}

func (*InstancePrototype) isaInstancePrototype() bool {
	return true
}

type InstancePrototypeIntf interface {
	isaInstancePrototype() bool
}

// UnmarshalInstancePrototype constructs an instance of InstancePrototype from the specified map.
func UnmarshalInstancePrototype(m map[string]interface{}) (result InstancePrototypeIntf, err error) {
	obj := new(InstancePrototype)
	obj.Keys, err = UnmarshalKeyIdentitySliceAsProperty(m, "keys")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.NetworkInterfaces, err = UnmarshalNetworkInterfacePrototypeSliceAsProperty(m, "network_interfaces")
	if err != nil {
		return
	}
	obj.Profile, err = UnmarshalInstanceProfileIdentityAsProperty(m, "profile")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupIdentityAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.UserData, err = core.UnmarshalString(m, "user_data")
	if err != nil {
		return
	}
	obj.VolumeAttachments, err = UnmarshalVolumeAttachmentPrototypeInstanceContextSliceAsProperty(m, "volume_attachments")
	if err != nil {
		return
	}
	obj.Vpc, err = UnmarshalVPCIdentityAsProperty(m, "vpc")
	if err != nil {
		return
	}
	obj.BootVolumeAttachment, err = UnmarshalVolumeAttachmentPrototypeInstanceByImageContextAsProperty(m, "boot_volume_attachment")
	if err != nil {
		return
	}
	obj.Image, err = UnmarshalImageIdentityAsProperty(m, "image")
	if err != nil {
		return
	}
	obj.PrimaryNetworkInterface, err = UnmarshalNetworkInterfacePrototypeAsProperty(m, "primary_network_interface")
	if err != nil {
		return
	}
	obj.Zone, err = UnmarshalZoneIdentityAsProperty(m, "zone")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstancePrototypeSlice unmarshals a slice of InstancePrototype instances from the specified list of maps.
func UnmarshalInstancePrototypeSlice(s []interface{}) (slice []InstancePrototypeIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstancePrototype'")
			return
		}
		obj, e := UnmarshalInstancePrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalInstancePrototypeAsProperty unmarshals an instance of InstancePrototype that is stored as a property
// within the specified map.
func UnmarshalInstancePrototypeAsProperty(m map[string]interface{}, propertyName string) (result InstancePrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstancePrototype'", propertyName)
			return
		}
		result, err = UnmarshalInstancePrototype(objMap)
	}
	return
}

// UnmarshalInstancePrototypeSliceAsProperty unmarshals a slice of InstancePrototype instances that are stored as a property
// within the specified map.
func UnmarshalInstancePrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstancePrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstancePrototype'", propertyName)
			return
		}
		slice, err = UnmarshalInstancePrototypeSlice(vSlice)
	}
	return
}

// InstanceReference : InstanceReference struct
type InstanceReference struct {
	// The CRN for this virtual server instance.
	Crn *string `json:"crn" validate:"required"`

	// The URL for this virtual server instance.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this virtual server instance.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this virtual server instance (and default system hostname).
	Name *string `json:"name" validate:"required"`
}

// UnmarshalInstanceReference constructs an instance of InstanceReference from the specified map.
func UnmarshalInstanceReference(m map[string]interface{}) (result *InstanceReference, err error) {
	obj := new(InstanceReference)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceReferenceSlice unmarshals a slice of InstanceReference instances from the specified list of maps.
func UnmarshalInstanceReferenceSlice(s []interface{}) (slice []InstanceReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceReference'")
			return
		}
		obj, e := UnmarshalInstanceReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceReferenceAsProperty unmarshals an instance of InstanceReference that is stored as a property
// within the specified map.
func UnmarshalInstanceReferenceAsProperty(m map[string]interface{}, propertyName string) (result *InstanceReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceReference'", propertyName)
			return
		}
		result, err = UnmarshalInstanceReference(objMap)
	}
	return
}

// UnmarshalInstanceReferenceSliceAsProperty unmarshals a slice of InstanceReference instances that are stored as a property
// within the specified map.
func UnmarshalInstanceReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceReference'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceReferenceSlice(vSlice)
	}
	return
}

// InstanceVCPU : The virtual server instance VCPU configuration.
type InstanceVCPU struct {
	// The VCPU architecture.
	Architecture *string `json:"architecture" validate:"required"`

	// The number of VCPUs assigned.
	Count *int64 `json:"count" validate:"required"`
}

// UnmarshalInstanceVCPU constructs an instance of InstanceVCPU from the specified map.
func UnmarshalInstanceVCPU(m map[string]interface{}) (result *InstanceVCPU, err error) {
	obj := new(InstanceVCPU)
	obj.Architecture, err = core.UnmarshalString(m, "architecture")
	if err != nil {
		return
	}
	obj.Count, err = core.UnmarshalInt64(m, "count")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceVCPUSlice unmarshals a slice of InstanceVCPU instances from the specified list of maps.
func UnmarshalInstanceVCPUSlice(s []interface{}) (slice []InstanceVCPU, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceVCPU'")
			return
		}
		obj, e := UnmarshalInstanceVCPU(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceVCPUAsProperty unmarshals an instance of InstanceVCPU that is stored as a property
// within the specified map.
func UnmarshalInstanceVCPUAsProperty(m map[string]interface{}, propertyName string) (result *InstanceVCPU, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceVCPU'", propertyName)
			return
		}
		result, err = UnmarshalInstanceVCPU(objMap)
	}
	return
}

// UnmarshalInstanceVCPUSliceAsProperty unmarshals a slice of InstanceVCPU instances that are stored as a property
// within the specified map.
func UnmarshalInstanceVCPUSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceVCPU, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceVCPU'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceVCPUSlice(vSlice)
	}
	return
}

// Key : Key struct
type Key struct {
	// The date and time that the key was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this key.
	Crn *string `json:"crn" validate:"required"`

	// The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm (always
	// `SHA256`).
	Fingerprint *string `json:"fingerprint" validate:"required"`

	// The URL for this key.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this key.
	ID *string `json:"id" validate:"required"`

	// The length of this key (in bits).
	Length *int64 `json:"length" validate:"required"`

	// The unique user-defined name for this key. If unspecified, the name will be a hyphenated list of randomly-selected
	// words.
	Name *string `json:"name" validate:"required"`

	// The public SSH key.
	PublicKey *string `json:"public_key" validate:"required"`

	// The resource group for this key.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The cryptosystem used by this key.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the Key.Type property.
// The cryptosystem used by this key.
const (
	Key_Type_Rsa = "rsa"
)

// UnmarshalKey constructs an instance of Key from the specified map.
func UnmarshalKey(m map[string]interface{}) (result *Key, err error) {
	obj := new(Key)
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Fingerprint, err = core.UnmarshalString(m, "fingerprint")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Length, err = core.UnmarshalInt64(m, "length")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.PublicKey, err = core.UnmarshalString(m, "public_key")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupReferenceAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalKeySlice unmarshals a slice of Key instances from the specified list of maps.
func UnmarshalKeySlice(s []interface{}) (slice []Key, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Key'")
			return
		}
		obj, e := UnmarshalKey(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalKeyAsProperty unmarshals an instance of Key that is stored as a property
// within the specified map.
func UnmarshalKeyAsProperty(m map[string]interface{}, propertyName string) (result *Key, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Key'", propertyName)
			return
		}
		result, err = UnmarshalKey(objMap)
	}
	return
}

// UnmarshalKeySliceAsProperty unmarshals a slice of Key instances that are stored as a property
// within the specified map.
func UnmarshalKeySliceAsProperty(m map[string]interface{}, propertyName string) (slice []Key, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Key'", propertyName)
			return
		}
		slice, err = UnmarshalKeySlice(vSlice)
	}
	return
}

// KeyCollection : KeyCollection struct
type KeyCollection struct {
	// Collection of keys.
	Keys []Key `json:"keys" validate:"required"`
}

// UnmarshalKeyCollection constructs an instance of KeyCollection from the specified map.
func UnmarshalKeyCollection(m map[string]interface{}) (result *KeyCollection, err error) {
	obj := new(KeyCollection)
	obj.Keys, err = UnmarshalKeySliceAsProperty(m, "keys")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalKeyCollectionSlice unmarshals a slice of KeyCollection instances from the specified list of maps.
func UnmarshalKeyCollectionSlice(s []interface{}) (slice []KeyCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'KeyCollection'")
			return
		}
		obj, e := UnmarshalKeyCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalKeyCollectionAsProperty unmarshals an instance of KeyCollection that is stored as a property
// within the specified map.
func UnmarshalKeyCollectionAsProperty(m map[string]interface{}, propertyName string) (result *KeyCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'KeyCollection'", propertyName)
			return
		}
		result, err = UnmarshalKeyCollection(objMap)
	}
	return
}

// UnmarshalKeyCollectionSliceAsProperty unmarshals a slice of KeyCollection instances that are stored as a property
// within the specified map.
func UnmarshalKeyCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []KeyCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'KeyCollection'", propertyName)
			return
		}
		slice, err = UnmarshalKeyCollectionSlice(vSlice)
	}
	return
}

// KeyIdentity : Identifies a key by a unique property.
// Models which "extend" this model:
// - KeyIdentityByID
// - KeyIdentityByCRN
// - KeyIdentityByHref
// - KeyIdentityByFingerprint
type KeyIdentity struct {
	// The unique identifier for this key.
	ID *string `json:"id,omitempty"`

	// The CRN for this key.
	Crn *string `json:"crn,omitempty"`

	// The URL for this key.
	Href *string `json:"href,omitempty"`

	// The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm (always
	// `SHA256`).
	Fingerprint *string `json:"fingerprint,omitempty"`
}

func (*KeyIdentity) isaKeyIdentity() bool {
	return true
}

type KeyIdentityIntf interface {
	isaKeyIdentity() bool
}

// UnmarshalKeyIdentity constructs an instance of KeyIdentity from the specified map.
func UnmarshalKeyIdentity(m map[string]interface{}) (result KeyIdentityIntf, err error) {
	obj := new(KeyIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.Fingerprint, err = core.UnmarshalString(m, "fingerprint")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalKeyIdentitySlice unmarshals a slice of KeyIdentity instances from the specified list of maps.
func UnmarshalKeyIdentitySlice(s []interface{}) (slice []KeyIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'KeyIdentity'")
			return
		}
		obj, e := UnmarshalKeyIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalKeyIdentityAsProperty unmarshals an instance of KeyIdentity that is stored as a property
// within the specified map.
func UnmarshalKeyIdentityAsProperty(m map[string]interface{}, propertyName string) (result KeyIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'KeyIdentity'", propertyName)
			return
		}
		result, err = UnmarshalKeyIdentity(objMap)
	}
	return
}

// UnmarshalKeyIdentitySliceAsProperty unmarshals a slice of KeyIdentity instances that are stored as a property
// within the specified map.
func UnmarshalKeyIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []KeyIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'KeyIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalKeyIdentitySlice(vSlice)
	}
	return
}

// KeyReferenceInstanceInitializationContext : KeyReferenceInstanceInitializationContext struct
// Models which "extend" this model:
// - KeyReferenceInstanceInitializationContextKeyReference
// - KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint
type KeyReferenceInstanceInitializationContext struct {
	// The CRN for this key.
	Crn *string `json:"crn,omitempty"`

	// The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm (always
	// `SHA256`).
	Fingerprint *string `json:"fingerprint,omitempty"`

	// The URL for this key.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this key.
	ID *string `json:"id,omitempty"`

	// The user-defined name for this key.
	Name *string `json:"name,omitempty"`
}

func (*KeyReferenceInstanceInitializationContext) isaKeyReferenceInstanceInitializationContext() bool {
	return true
}

type KeyReferenceInstanceInitializationContextIntf interface {
	isaKeyReferenceInstanceInitializationContext() bool
}

// UnmarshalKeyReferenceInstanceInitializationContext constructs an instance of KeyReferenceInstanceInitializationContext from the specified map.
func UnmarshalKeyReferenceInstanceInitializationContext(m map[string]interface{}) (result KeyReferenceInstanceInitializationContextIntf, err error) {
	obj := new(KeyReferenceInstanceInitializationContext)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Fingerprint, err = core.UnmarshalString(m, "fingerprint")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalKeyReferenceInstanceInitializationContextSlice unmarshals a slice of KeyReferenceInstanceInitializationContext instances from the specified list of maps.
func UnmarshalKeyReferenceInstanceInitializationContextSlice(s []interface{}) (slice []KeyReferenceInstanceInitializationContextIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'KeyReferenceInstanceInitializationContext'")
			return
		}
		obj, e := UnmarshalKeyReferenceInstanceInitializationContext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalKeyReferenceInstanceInitializationContextAsProperty unmarshals an instance of KeyReferenceInstanceInitializationContext that is stored as a property
// within the specified map.
func UnmarshalKeyReferenceInstanceInitializationContextAsProperty(m map[string]interface{}, propertyName string) (result KeyReferenceInstanceInitializationContextIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'KeyReferenceInstanceInitializationContext'", propertyName)
			return
		}
		result, err = UnmarshalKeyReferenceInstanceInitializationContext(objMap)
	}
	return
}

// UnmarshalKeyReferenceInstanceInitializationContextSliceAsProperty unmarshals a slice of KeyReferenceInstanceInitializationContext instances that are stored as a property
// within the specified map.
func UnmarshalKeyReferenceInstanceInitializationContextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []KeyReferenceInstanceInitializationContextIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'KeyReferenceInstanceInitializationContext'", propertyName)
			return
		}
		slice, err = UnmarshalKeyReferenceInstanceInitializationContextSlice(vSlice)
	}
	return
}

// ListFloatingIpsOptions : The ListFloatingIps options.
type ListFloatingIpsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListFloatingIpsOptions : Instantiate ListFloatingIpsOptions
func (*VpcV1) NewListFloatingIpsOptions() *ListFloatingIpsOptions {
	return &ListFloatingIpsOptions{}
}

// SetStart : Allow user to set Start
func (options *ListFloatingIpsOptions) SetStart(start string) *ListFloatingIpsOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListFloatingIpsOptions) SetLimit(limit int64) *ListFloatingIpsOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListFloatingIpsOptions) SetResourceGroupID(resourceGroupID string) *ListFloatingIpsOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListFloatingIpsOptions) SetHeaders(param map[string]string) *ListFloatingIpsOptions {
	options.Headers = param
	return options
}

// ListIkePoliciesOptions : The ListIkePolicies options.
type ListIkePoliciesOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListIkePoliciesOptions : Instantiate ListIkePoliciesOptions
func (*VpcV1) NewListIkePoliciesOptions() *ListIkePoliciesOptions {
	return &ListIkePoliciesOptions{}
}

// SetStart : Allow user to set Start
func (options *ListIkePoliciesOptions) SetStart(start string) *ListIkePoliciesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListIkePoliciesOptions) SetLimit(limit int64) *ListIkePoliciesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListIkePoliciesOptions) SetHeaders(param map[string]string) *ListIkePoliciesOptions {
	options.Headers = param
	return options
}

// ListImagesOptions : The ListImages options.
type ListImagesOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to images with the specified visibility.
	Visibility *string `json:"visibility,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListImagesOptions.Visibility property.
// Filters the collection to images with the specified visibility.
const (
	ListImagesOptions_Visibility_Private = "private"
	ListImagesOptions_Visibility_Public  = "public"
)

// NewListImagesOptions : Instantiate ListImagesOptions
func (*VpcV1) NewListImagesOptions() *ListImagesOptions {
	return &ListImagesOptions{}
}

// SetStart : Allow user to set Start
func (options *ListImagesOptions) SetStart(start string) *ListImagesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListImagesOptions) SetLimit(limit int64) *ListImagesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListImagesOptions) SetResourceGroupID(resourceGroupID string) *ListImagesOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetVisibility : Allow user to set Visibility
func (options *ListImagesOptions) SetVisibility(visibility string) *ListImagesOptions {
	options.Visibility = core.StringPtr(visibility)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListImagesOptions) SetHeaders(param map[string]string) *ListImagesOptions {
	options.Headers = param
	return options
}

// ListInstanceProfilesOptions : The ListInstanceProfiles options.
type ListInstanceProfilesOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceProfilesOptions : Instantiate ListInstanceProfilesOptions
func (*VpcV1) NewListInstanceProfilesOptions() *ListInstanceProfilesOptions {
	return &ListInstanceProfilesOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceProfilesOptions) SetHeaders(param map[string]string) *ListInstanceProfilesOptions {
	options.Headers = param
	return options
}

// ListInstancesOptions : The ListInstances options.
type ListInstancesOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources with the exact specified name.
	Name *string `json:"name,omitempty"`

	// Filters the collection to resources in the VPC with the specified identifier.
	VpcID *string `json:"vpc.id,omitempty"`

	// Filters the collection to resources in the VPC with the specified CRN.
	VpcCrn *string `json:"vpc.crn,omitempty"`

	// Filters the collection to resources in the VPC with the exact specified name.
	VpcName *string `json:"vpc.name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstancesOptions : Instantiate ListInstancesOptions
func (*VpcV1) NewListInstancesOptions() *ListInstancesOptions {
	return &ListInstancesOptions{}
}

// SetStart : Allow user to set Start
func (options *ListInstancesOptions) SetStart(start string) *ListInstancesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListInstancesOptions) SetLimit(limit int64) *ListInstancesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListInstancesOptions) SetResourceGroupID(resourceGroupID string) *ListInstancesOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetName : Allow user to set Name
func (options *ListInstancesOptions) SetName(name string) *ListInstancesOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetVpcID : Allow user to set VpcID
func (options *ListInstancesOptions) SetVpcID(vpcID string) *ListInstancesOptions {
	options.VpcID = core.StringPtr(vpcID)
	return options
}

// SetVpcCrn : Allow user to set VpcCrn
func (options *ListInstancesOptions) SetVpcCrn(vpcCrn string) *ListInstancesOptions {
	options.VpcCrn = core.StringPtr(vpcCrn)
	return options
}

// SetVpcName : Allow user to set VpcName
func (options *ListInstancesOptions) SetVpcName(vpcName string) *ListInstancesOptions {
	options.VpcName = core.StringPtr(vpcName)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstancesOptions) SetHeaders(param map[string]string) *ListInstancesOptions {
	options.Headers = param
	return options
}

// ListIpsecPoliciesOptions : The ListIpsecPolicies options.
type ListIpsecPoliciesOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListIpsecPoliciesOptions : Instantiate ListIpsecPoliciesOptions
func (*VpcV1) NewListIpsecPoliciesOptions() *ListIpsecPoliciesOptions {
	return &ListIpsecPoliciesOptions{}
}

// SetStart : Allow user to set Start
func (options *ListIpsecPoliciesOptions) SetStart(start string) *ListIpsecPoliciesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListIpsecPoliciesOptions) SetLimit(limit int64) *ListIpsecPoliciesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListIpsecPoliciesOptions) SetHeaders(param map[string]string) *ListIpsecPoliciesOptions {
	options.Headers = param
	return options
}

// ListKeysOptions : The ListKeys options.
type ListKeysOptions struct {
	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListKeysOptions : Instantiate ListKeysOptions
func (*VpcV1) NewListKeysOptions() *ListKeysOptions {
	return &ListKeysOptions{}
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListKeysOptions) SetResourceGroupID(resourceGroupID string) *ListKeysOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListKeysOptions) SetHeaders(param map[string]string) *ListKeysOptions {
	options.Headers = param
	return options
}

// ListLoadBalancerListenerPoliciesOptions : The ListLoadBalancerListenerPolicies options.
type ListLoadBalancerListenerPoliciesOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancerListenerPoliciesOptions : Instantiate ListLoadBalancerListenerPoliciesOptions
func (*VpcV1) NewListLoadBalancerListenerPoliciesOptions(loadBalancerID string, listenerID string) *ListLoadBalancerListenerPoliciesOptions {
	return &ListLoadBalancerListenerPoliciesOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *ListLoadBalancerListenerPoliciesOptions) SetLoadBalancerID(loadBalancerID string) *ListLoadBalancerListenerPoliciesOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *ListLoadBalancerListenerPoliciesOptions) SetListenerID(listenerID string) *ListLoadBalancerListenerPoliciesOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancerListenerPoliciesOptions) SetHeaders(param map[string]string) *ListLoadBalancerListenerPoliciesOptions {
	options.Headers = param
	return options
}

// ListLoadBalancerListenerPolicyRulesOptions : The ListLoadBalancerListenerPolicyRules options.
type ListLoadBalancerListenerPolicyRulesOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// The policy identifier.
	PolicyID *string `json:"policy_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancerListenerPolicyRulesOptions : Instantiate ListLoadBalancerListenerPolicyRulesOptions
func (*VpcV1) NewListLoadBalancerListenerPolicyRulesOptions(loadBalancerID string, listenerID string, policyID string) *ListLoadBalancerListenerPolicyRulesOptions {
	return &ListLoadBalancerListenerPolicyRulesOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		PolicyID:       core.StringPtr(policyID),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *ListLoadBalancerListenerPolicyRulesOptions) SetLoadBalancerID(loadBalancerID string) *ListLoadBalancerListenerPolicyRulesOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *ListLoadBalancerListenerPolicyRulesOptions) SetListenerID(listenerID string) *ListLoadBalancerListenerPolicyRulesOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetPolicyID : Allow user to set PolicyID
func (options *ListLoadBalancerListenerPolicyRulesOptions) SetPolicyID(policyID string) *ListLoadBalancerListenerPolicyRulesOptions {
	options.PolicyID = core.StringPtr(policyID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancerListenerPolicyRulesOptions) SetHeaders(param map[string]string) *ListLoadBalancerListenerPolicyRulesOptions {
	options.Headers = param
	return options
}

// ListLoadBalancerListenersOptions : The ListLoadBalancerListeners options.
type ListLoadBalancerListenersOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancerListenersOptions : Instantiate ListLoadBalancerListenersOptions
func (*VpcV1) NewListLoadBalancerListenersOptions(loadBalancerID string) *ListLoadBalancerListenersOptions {
	return &ListLoadBalancerListenersOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *ListLoadBalancerListenersOptions) SetLoadBalancerID(loadBalancerID string) *ListLoadBalancerListenersOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancerListenersOptions) SetHeaders(param map[string]string) *ListLoadBalancerListenersOptions {
	options.Headers = param
	return options
}

// ListLoadBalancerPoolMembersOptions : The ListLoadBalancerPoolMembers options.
type ListLoadBalancerPoolMembersOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The pool identifier.
	PoolID *string `json:"pool_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancerPoolMembersOptions : Instantiate ListLoadBalancerPoolMembersOptions
func (*VpcV1) NewListLoadBalancerPoolMembersOptions(loadBalancerID string, poolID string) *ListLoadBalancerPoolMembersOptions {
	return &ListLoadBalancerPoolMembersOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		PoolID:         core.StringPtr(poolID),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *ListLoadBalancerPoolMembersOptions) SetLoadBalancerID(loadBalancerID string) *ListLoadBalancerPoolMembersOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetPoolID : Allow user to set PoolID
func (options *ListLoadBalancerPoolMembersOptions) SetPoolID(poolID string) *ListLoadBalancerPoolMembersOptions {
	options.PoolID = core.StringPtr(poolID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancerPoolMembersOptions) SetHeaders(param map[string]string) *ListLoadBalancerPoolMembersOptions {
	options.Headers = param
	return options
}

// ListLoadBalancerPoolsOptions : The ListLoadBalancerPools options.
type ListLoadBalancerPoolsOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancerPoolsOptions : Instantiate ListLoadBalancerPoolsOptions
func (*VpcV1) NewListLoadBalancerPoolsOptions(loadBalancerID string) *ListLoadBalancerPoolsOptions {
	return &ListLoadBalancerPoolsOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *ListLoadBalancerPoolsOptions) SetLoadBalancerID(loadBalancerID string) *ListLoadBalancerPoolsOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancerPoolsOptions) SetHeaders(param map[string]string) *ListLoadBalancerPoolsOptions {
	options.Headers = param
	return options
}

// ListLoadBalancersOptions : The ListLoadBalancers options.
type ListLoadBalancersOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancersOptions : Instantiate ListLoadBalancersOptions
func (*VpcV1) NewListLoadBalancersOptions() *ListLoadBalancersOptions {
	return &ListLoadBalancersOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancersOptions) SetHeaders(param map[string]string) *ListLoadBalancersOptions {
	options.Headers = param
	return options
}

// ListNetworkAclRulesOptions : The ListNetworkAclRules options.
type ListNetworkAclRulesOptions struct {
	// The network ACL identifier.
	NetworkAclID *string `json:"network_acl_id" validate:"required"`

	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to rules with the specified direction.
	Direction *string `json:"direction,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListNetworkAclRulesOptions.Direction property.
// Filters the collection to rules with the specified direction.
const (
	ListNetworkAclRulesOptions_Direction_Inbound  = "inbound"
	ListNetworkAclRulesOptions_Direction_Outbound = "outbound"
)

// NewListNetworkAclRulesOptions : Instantiate ListNetworkAclRulesOptions
func (*VpcV1) NewListNetworkAclRulesOptions(networkAclID string) *ListNetworkAclRulesOptions {
	return &ListNetworkAclRulesOptions{
		NetworkAclID: core.StringPtr(networkAclID),
	}
}

// SetNetworkAclID : Allow user to set NetworkAclID
func (options *ListNetworkAclRulesOptions) SetNetworkAclID(networkAclID string) *ListNetworkAclRulesOptions {
	options.NetworkAclID = core.StringPtr(networkAclID)
	return options
}

// SetStart : Allow user to set Start
func (options *ListNetworkAclRulesOptions) SetStart(start string) *ListNetworkAclRulesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListNetworkAclRulesOptions) SetLimit(limit int64) *ListNetworkAclRulesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetDirection : Allow user to set Direction
func (options *ListNetworkAclRulesOptions) SetDirection(direction string) *ListNetworkAclRulesOptions {
	options.Direction = core.StringPtr(direction)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListNetworkAclRulesOptions) SetHeaders(param map[string]string) *ListNetworkAclRulesOptions {
	options.Headers = param
	return options
}

// ListNetworkAclsOptions : The ListNetworkAcls options.
type ListNetworkAclsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListNetworkAclsOptions : Instantiate ListNetworkAclsOptions
func (*VpcV1) NewListNetworkAclsOptions() *ListNetworkAclsOptions {
	return &ListNetworkAclsOptions{}
}

// SetStart : Allow user to set Start
func (options *ListNetworkAclsOptions) SetStart(start string) *ListNetworkAclsOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListNetworkAclsOptions) SetLimit(limit int64) *ListNetworkAclsOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListNetworkAclsOptions) SetResourceGroupID(resourceGroupID string) *ListNetworkAclsOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListNetworkAclsOptions) SetHeaders(param map[string]string) *ListNetworkAclsOptions {
	options.Headers = param
	return options
}

// ListNetworkInterfaceFloatingIpsOptions : The ListNetworkInterfaceFloatingIps options.
type ListNetworkInterfaceFloatingIpsOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListNetworkInterfaceFloatingIpsOptions : Instantiate ListNetworkInterfaceFloatingIpsOptions
func (*VpcV1) NewListNetworkInterfaceFloatingIpsOptions(instanceID string, networkInterfaceID string) *ListNetworkInterfaceFloatingIpsOptions {
	return &ListNetworkInterfaceFloatingIpsOptions{
		InstanceID:         core.StringPtr(instanceID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *ListNetworkInterfaceFloatingIpsOptions) SetInstanceID(instanceID string) *ListNetworkInterfaceFloatingIpsOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (options *ListNetworkInterfaceFloatingIpsOptions) SetNetworkInterfaceID(networkInterfaceID string) *ListNetworkInterfaceFloatingIpsOptions {
	options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListNetworkInterfaceFloatingIpsOptions) SetHeaders(param map[string]string) *ListNetworkInterfaceFloatingIpsOptions {
	options.Headers = param
	return options
}

// ListNetworkInterfacesOptions : The ListNetworkInterfaces options.
type ListNetworkInterfacesOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListNetworkInterfacesOptions : Instantiate ListNetworkInterfacesOptions
func (*VpcV1) NewListNetworkInterfacesOptions(instanceID string) *ListNetworkInterfacesOptions {
	return &ListNetworkInterfacesOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *ListNetworkInterfacesOptions) SetInstanceID(instanceID string) *ListNetworkInterfacesOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListNetworkInterfacesOptions) SetHeaders(param map[string]string) *ListNetworkInterfacesOptions {
	options.Headers = param
	return options
}

// ListOperatingSystemsOptions : The ListOperatingSystems options.
type ListOperatingSystemsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListOperatingSystemsOptions : Instantiate ListOperatingSystemsOptions
func (*VpcV1) NewListOperatingSystemsOptions() *ListOperatingSystemsOptions {
	return &ListOperatingSystemsOptions{}
}

// SetStart : Allow user to set Start
func (options *ListOperatingSystemsOptions) SetStart(start string) *ListOperatingSystemsOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListOperatingSystemsOptions) SetLimit(limit int64) *ListOperatingSystemsOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListOperatingSystemsOptions) SetHeaders(param map[string]string) *ListOperatingSystemsOptions {
	options.Headers = param
	return options
}

// ListPublicGatewaysOptions : The ListPublicGateways options.
type ListPublicGatewaysOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListPublicGatewaysOptions : Instantiate ListPublicGatewaysOptions
func (*VpcV1) NewListPublicGatewaysOptions() *ListPublicGatewaysOptions {
	return &ListPublicGatewaysOptions{}
}

// SetStart : Allow user to set Start
func (options *ListPublicGatewaysOptions) SetStart(start string) *ListPublicGatewaysOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListPublicGatewaysOptions) SetLimit(limit int64) *ListPublicGatewaysOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListPublicGatewaysOptions) SetResourceGroupID(resourceGroupID string) *ListPublicGatewaysOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListPublicGatewaysOptions) SetHeaders(param map[string]string) *ListPublicGatewaysOptions {
	options.Headers = param
	return options
}

// ListRegionsOptions : The ListRegions options.
type ListRegionsOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListRegionsOptions : Instantiate ListRegionsOptions
func (*VpcV1) NewListRegionsOptions() *ListRegionsOptions {
	return &ListRegionsOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ListRegionsOptions) SetHeaders(param map[string]string) *ListRegionsOptions {
	options.Headers = param
	return options
}

// ListSecurityGroupNetworkInterfacesOptions : The ListSecurityGroupNetworkInterfaces options.
type ListSecurityGroupNetworkInterfacesOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSecurityGroupNetworkInterfacesOptions : Instantiate ListSecurityGroupNetworkInterfacesOptions
func (*VpcV1) NewListSecurityGroupNetworkInterfacesOptions(securityGroupID string) *ListSecurityGroupNetworkInterfacesOptions {
	return &ListSecurityGroupNetworkInterfacesOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (options *ListSecurityGroupNetworkInterfacesOptions) SetSecurityGroupID(securityGroupID string) *ListSecurityGroupNetworkInterfacesOptions {
	options.SecurityGroupID = core.StringPtr(securityGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListSecurityGroupNetworkInterfacesOptions) SetHeaders(param map[string]string) *ListSecurityGroupNetworkInterfacesOptions {
	options.Headers = param
	return options
}

// ListSecurityGroupRulesOptions : The ListSecurityGroupRules options.
type ListSecurityGroupRulesOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSecurityGroupRulesOptions : Instantiate ListSecurityGroupRulesOptions
func (*VpcV1) NewListSecurityGroupRulesOptions(securityGroupID string) *ListSecurityGroupRulesOptions {
	return &ListSecurityGroupRulesOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (options *ListSecurityGroupRulesOptions) SetSecurityGroupID(securityGroupID string) *ListSecurityGroupRulesOptions {
	options.SecurityGroupID = core.StringPtr(securityGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListSecurityGroupRulesOptions) SetHeaders(param map[string]string) *ListSecurityGroupRulesOptions {
	options.Headers = param
	return options
}

// ListSecurityGroupsOptions : The ListSecurityGroups options.
type ListSecurityGroupsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources in the VPC with the specified identifier.
	VpcID *string `json:"vpc.id,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSecurityGroupsOptions : Instantiate ListSecurityGroupsOptions
func (*VpcV1) NewListSecurityGroupsOptions() *ListSecurityGroupsOptions {
	return &ListSecurityGroupsOptions{}
}

// SetStart : Allow user to set Start
func (options *ListSecurityGroupsOptions) SetStart(start string) *ListSecurityGroupsOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListSecurityGroupsOptions) SetLimit(limit int64) *ListSecurityGroupsOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListSecurityGroupsOptions) SetResourceGroupID(resourceGroupID string) *ListSecurityGroupsOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetVpcID : Allow user to set VpcID
func (options *ListSecurityGroupsOptions) SetVpcID(vpcID string) *ListSecurityGroupsOptions {
	options.VpcID = core.StringPtr(vpcID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListSecurityGroupsOptions) SetHeaders(param map[string]string) *ListSecurityGroupsOptions {
	options.Headers = param
	return options
}

// ListSubnetsOptions : The ListSubnets options.
type ListSubnetsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSubnetsOptions : Instantiate ListSubnetsOptions
func (*VpcV1) NewListSubnetsOptions() *ListSubnetsOptions {
	return &ListSubnetsOptions{}
}

// SetStart : Allow user to set Start
func (options *ListSubnetsOptions) SetStart(start string) *ListSubnetsOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListSubnetsOptions) SetLimit(limit int64) *ListSubnetsOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListSubnetsOptions) SetResourceGroupID(resourceGroupID string) *ListSubnetsOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListSubnetsOptions) SetHeaders(param map[string]string) *ListSubnetsOptions {
	options.Headers = param
	return options
}

// ListVolumeAttachmentsOptions : The ListVolumeAttachments options.
type ListVolumeAttachmentsOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVolumeAttachmentsOptions : Instantiate ListVolumeAttachmentsOptions
func (*VpcV1) NewListVolumeAttachmentsOptions(instanceID string) *ListVolumeAttachmentsOptions {
	return &ListVolumeAttachmentsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *ListVolumeAttachmentsOptions) SetInstanceID(instanceID string) *ListVolumeAttachmentsOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVolumeAttachmentsOptions) SetHeaders(param map[string]string) *ListVolumeAttachmentsOptions {
	options.Headers = param
	return options
}

// ListVolumeProfilesOptions : The ListVolumeProfiles options.
type ListVolumeProfilesOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVolumeProfilesOptions : Instantiate ListVolumeProfilesOptions
func (*VpcV1) NewListVolumeProfilesOptions() *ListVolumeProfilesOptions {
	return &ListVolumeProfilesOptions{}
}

// SetStart : Allow user to set Start
func (options *ListVolumeProfilesOptions) SetStart(start string) *ListVolumeProfilesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListVolumeProfilesOptions) SetLimit(limit int64) *ListVolumeProfilesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVolumeProfilesOptions) SetHeaders(param map[string]string) *ListVolumeProfilesOptions {
	options.Headers = param
	return options
}

// ListVolumesOptions : The ListVolumes options.
type ListVolumesOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with the exact specified name.
	Name *string `json:"name,omitempty"`

	// Filters the collection to resources in the zone with the exact specified name.
	ZoneName *string `json:"zone.name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVolumesOptions : Instantiate ListVolumesOptions
func (*VpcV1) NewListVolumesOptions() *ListVolumesOptions {
	return &ListVolumesOptions{}
}

// SetStart : Allow user to set Start
func (options *ListVolumesOptions) SetStart(start string) *ListVolumesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListVolumesOptions) SetLimit(limit int64) *ListVolumesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetName : Allow user to set Name
func (options *ListVolumesOptions) SetName(name string) *ListVolumesOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetZoneName : Allow user to set ZoneName
func (options *ListVolumesOptions) SetZoneName(zoneName string) *ListVolumesOptions {
	options.ZoneName = core.StringPtr(zoneName)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVolumesOptions) SetHeaders(param map[string]string) *ListVolumesOptions {
	options.Headers = param
	return options
}

// ListVpcAddressPrefixesOptions : The ListVpcAddressPrefixes options.
type ListVpcAddressPrefixesOptions struct {
	// The VPC identifier.
	VpcID *string `json:"vpc_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVpcAddressPrefixesOptions : Instantiate ListVpcAddressPrefixesOptions
func (*VpcV1) NewListVpcAddressPrefixesOptions(vpcID string) *ListVpcAddressPrefixesOptions {
	return &ListVpcAddressPrefixesOptions{
		VpcID: core.StringPtr(vpcID),
	}
}

// SetVpcID : Allow user to set VpcID
func (options *ListVpcAddressPrefixesOptions) SetVpcID(vpcID string) *ListVpcAddressPrefixesOptions {
	options.VpcID = core.StringPtr(vpcID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVpcAddressPrefixesOptions) SetHeaders(param map[string]string) *ListVpcAddressPrefixesOptions {
	options.Headers = param
	return options
}

// ListVpcRoutesOptions : The ListVpcRoutes options.
type ListVpcRoutesOptions struct {
	// The VPC identifier.
	VpcID *string `json:"vpc_id" validate:"required"`

	// Filters the collection to resources in the zone with the exact specified name.
	ZoneName *string `json:"zone.name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVpcRoutesOptions : Instantiate ListVpcRoutesOptions
func (*VpcV1) NewListVpcRoutesOptions(vpcID string) *ListVpcRoutesOptions {
	return &ListVpcRoutesOptions{
		VpcID: core.StringPtr(vpcID),
	}
}

// SetVpcID : Allow user to set VpcID
func (options *ListVpcRoutesOptions) SetVpcID(vpcID string) *ListVpcRoutesOptions {
	options.VpcID = core.StringPtr(vpcID)
	return options
}

// SetZoneName : Allow user to set ZoneName
func (options *ListVpcRoutesOptions) SetZoneName(zoneName string) *ListVpcRoutesOptions {
	options.ZoneName = core.StringPtr(zoneName)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVpcRoutesOptions) SetHeaders(param map[string]string) *ListVpcRoutesOptions {
	options.Headers = param
	return options
}

// ListVpcsOptions : The ListVpcs options.
type ListVpcsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// The `classic_access` parameter filters the returned collection by the supplied field. If the supplied field is
	// `true`, only Classic Access VPCs will be returned. If the supplied field is `false`, only VPCs without Classic
	// Access will be returned.
	ClassicAccess *bool `json:"classic_access,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVpcsOptions : Instantiate ListVpcsOptions
func (*VpcV1) NewListVpcsOptions() *ListVpcsOptions {
	return &ListVpcsOptions{}
}

// SetStart : Allow user to set Start
func (options *ListVpcsOptions) SetStart(start string) *ListVpcsOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListVpcsOptions) SetLimit(limit int64) *ListVpcsOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListVpcsOptions) SetResourceGroupID(resourceGroupID string) *ListVpcsOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetClassicAccess : Allow user to set ClassicAccess
func (options *ListVpcsOptions) SetClassicAccess(classicAccess bool) *ListVpcsOptions {
	options.ClassicAccess = core.BoolPtr(classicAccess)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVpcsOptions) SetHeaders(param map[string]string) *ListVpcsOptions {
	options.Headers = param
	return options
}

// ListVpnGatewayConnectionLocalCidrsOptions : The ListVpnGatewayConnectionLocalCidrs options.
type ListVpnGatewayConnectionLocalCidrsOptions struct {
	// The VPN gateway identifier.
	VpnGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVpnGatewayConnectionLocalCidrsOptions : Instantiate ListVpnGatewayConnectionLocalCidrsOptions
func (*VpcV1) NewListVpnGatewayConnectionLocalCidrsOptions(vpnGatewayID string, id string) *ListVpnGatewayConnectionLocalCidrsOptions {
	return &ListVpnGatewayConnectionLocalCidrsOptions{
		VpnGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
	}
}

// SetVpnGatewayID : Allow user to set VpnGatewayID
func (options *ListVpnGatewayConnectionLocalCidrsOptions) SetVpnGatewayID(vpnGatewayID string) *ListVpnGatewayConnectionLocalCidrsOptions {
	options.VpnGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *ListVpnGatewayConnectionLocalCidrsOptions) SetID(id string) *ListVpnGatewayConnectionLocalCidrsOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVpnGatewayConnectionLocalCidrsOptions) SetHeaders(param map[string]string) *ListVpnGatewayConnectionLocalCidrsOptions {
	options.Headers = param
	return options
}

// ListVpnGatewayConnectionPeerCidrsOptions : The ListVpnGatewayConnectionPeerCidrs options.
type ListVpnGatewayConnectionPeerCidrsOptions struct {
	// The VPN gateway identifier.
	VpnGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVpnGatewayConnectionPeerCidrsOptions : Instantiate ListVpnGatewayConnectionPeerCidrsOptions
func (*VpcV1) NewListVpnGatewayConnectionPeerCidrsOptions(vpnGatewayID string, id string) *ListVpnGatewayConnectionPeerCidrsOptions {
	return &ListVpnGatewayConnectionPeerCidrsOptions{
		VpnGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
	}
}

// SetVpnGatewayID : Allow user to set VpnGatewayID
func (options *ListVpnGatewayConnectionPeerCidrsOptions) SetVpnGatewayID(vpnGatewayID string) *ListVpnGatewayConnectionPeerCidrsOptions {
	options.VpnGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *ListVpnGatewayConnectionPeerCidrsOptions) SetID(id string) *ListVpnGatewayConnectionPeerCidrsOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVpnGatewayConnectionPeerCidrsOptions) SetHeaders(param map[string]string) *ListVpnGatewayConnectionPeerCidrsOptions {
	options.Headers = param
	return options
}

// ListVpnGatewayConnectionsOptions : The ListVpnGatewayConnections options.
type ListVpnGatewayConnectionsOptions struct {
	// The VPN gateway identifier.
	VpnGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// Filters the collection to VPN connections with the specified status.
	Status *string `json:"status,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVpnGatewayConnectionsOptions : Instantiate ListVpnGatewayConnectionsOptions
func (*VpcV1) NewListVpnGatewayConnectionsOptions(vpnGatewayID string) *ListVpnGatewayConnectionsOptions {
	return &ListVpnGatewayConnectionsOptions{
		VpnGatewayID: core.StringPtr(vpnGatewayID),
	}
}

// SetVpnGatewayID : Allow user to set VpnGatewayID
func (options *ListVpnGatewayConnectionsOptions) SetVpnGatewayID(vpnGatewayID string) *ListVpnGatewayConnectionsOptions {
	options.VpnGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetStatus : Allow user to set Status
func (options *ListVpnGatewayConnectionsOptions) SetStatus(status string) *ListVpnGatewayConnectionsOptions {
	options.Status = core.StringPtr(status)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVpnGatewayConnectionsOptions) SetHeaders(param map[string]string) *ListVpnGatewayConnectionsOptions {
	options.Headers = param
	return options
}

// ListVpnGatewayIkePolicyConnectionsOptions : The ListVpnGatewayIkePolicyConnections options.
type ListVpnGatewayIkePolicyConnectionsOptions struct {
	// The IKE policy identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVpnGatewayIkePolicyConnectionsOptions : Instantiate ListVpnGatewayIkePolicyConnectionsOptions
func (*VpcV1) NewListVpnGatewayIkePolicyConnectionsOptions(id string) *ListVpnGatewayIkePolicyConnectionsOptions {
	return &ListVpnGatewayIkePolicyConnectionsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *ListVpnGatewayIkePolicyConnectionsOptions) SetID(id string) *ListVpnGatewayIkePolicyConnectionsOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVpnGatewayIkePolicyConnectionsOptions) SetHeaders(param map[string]string) *ListVpnGatewayIkePolicyConnectionsOptions {
	options.Headers = param
	return options
}

// ListVpnGatewayIpsecPolicyConnectionsOptions : The ListVpnGatewayIpsecPolicyConnections options.
type ListVpnGatewayIpsecPolicyConnectionsOptions struct {
	// The IPsec policy identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVpnGatewayIpsecPolicyConnectionsOptions : Instantiate ListVpnGatewayIpsecPolicyConnectionsOptions
func (*VpcV1) NewListVpnGatewayIpsecPolicyConnectionsOptions(id string) *ListVpnGatewayIpsecPolicyConnectionsOptions {
	return &ListVpnGatewayIpsecPolicyConnectionsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *ListVpnGatewayIpsecPolicyConnectionsOptions) SetID(id string) *ListVpnGatewayIpsecPolicyConnectionsOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVpnGatewayIpsecPolicyConnectionsOptions) SetHeaders(param map[string]string) *ListVpnGatewayIpsecPolicyConnectionsOptions {
	options.Headers = param
	return options
}

// ListVpnGatewaysOptions : The ListVpnGateways options.
type ListVpnGatewaysOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVpnGatewaysOptions : Instantiate ListVpnGatewaysOptions
func (*VpcV1) NewListVpnGatewaysOptions() *ListVpnGatewaysOptions {
	return &ListVpnGatewaysOptions{}
}

// SetStart : Allow user to set Start
func (options *ListVpnGatewaysOptions) SetStart(start string) *ListVpnGatewaysOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListVpnGatewaysOptions) SetLimit(limit int64) *ListVpnGatewaysOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListVpnGatewaysOptions) SetResourceGroupID(resourceGroupID string) *ListVpnGatewaysOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVpnGatewaysOptions) SetHeaders(param map[string]string) *ListVpnGatewaysOptions {
	options.Headers = param
	return options
}

// ListZonesOptions : The ListZones options.
type ListZonesOptions struct {
	// The region name.
	RegionName *string `json:"region_name" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListZonesOptions : Instantiate ListZonesOptions
func (*VpcV1) NewListZonesOptions(regionName string) *ListZonesOptions {
	return &ListZonesOptions{
		RegionName: core.StringPtr(regionName),
	}
}

// SetRegionName : Allow user to set RegionName
func (options *ListZonesOptions) SetRegionName(regionName string) *ListZonesOptions {
	options.RegionName = core.StringPtr(regionName)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListZonesOptions) SetHeaders(param map[string]string) *ListZonesOptions {
	options.Headers = param
	return options
}

// LoadBalancer : LoadBalancer struct
type LoadBalancer struct {
	// The date and time that this load balancer was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The load balancer's CRN.
	Crn *string `json:"crn" validate:"required"`

	// Fully qualified domain name assigned to this load balancer.
	Hostname *string `json:"hostname" validate:"required"`

	// The load balancer's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer.
	ID *string `json:"id" validate:"required"`

	// The type of this load balancer, public or private.
	IsPublic *bool `json:"is_public" validate:"required"`

	// The listeners of this load balancer.
	Listeners []LoadBalancerListenerReference `json:"listeners" validate:"required"`

	// The unique user-defined name for this load balancer.
	Name *string `json:"name" validate:"required"`

	// The operating status of this load balancer.
	OperatingStatus *string `json:"operating_status" validate:"required"`

	// The pools of this load balancer.
	Pools []LoadBalancerPoolReference `json:"pools" validate:"required"`

	// The private IP addresses assigned to this load balancer.
	PrivateIps []IP `json:"private_ips" validate:"required"`

	// The provisioning status of this load balancer.
	ProvisioningStatus *string `json:"provisioning_status" validate:"required"`

	// The public IP addresses assigned to this load balancer. These are applicable only for public load balancers.
	PublicIps []IP `json:"public_ips" validate:"required"`

	// The resource group for this load balancer.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The subnets this load balancer is part of.
	Subnets []SubnetReference `json:"subnets" validate:"required"`
}

// Constants associated with the LoadBalancer.OperatingStatus property.
// The operating status of this load balancer.
const (
	LoadBalancer_OperatingStatus_Offline = "offline"
	LoadBalancer_OperatingStatus_Online  = "online"
)

// Constants associated with the LoadBalancer.ProvisioningStatus property.
// The provisioning status of this load balancer.
const (
	LoadBalancer_ProvisioningStatus_Active             = "active"
	LoadBalancer_ProvisioningStatus_CreatePending      = "create_pending"
	LoadBalancer_ProvisioningStatus_DeletePending      = "delete_pending"
	LoadBalancer_ProvisioningStatus_Failed             = "failed"
	LoadBalancer_ProvisioningStatus_MaintenancePending = "maintenance_pending"
	LoadBalancer_ProvisioningStatus_UpdatePending      = "update_pending"
)

// UnmarshalLoadBalancer constructs an instance of LoadBalancer from the specified map.
func UnmarshalLoadBalancer(m map[string]interface{}) (result *LoadBalancer, err error) {
	obj := new(LoadBalancer)
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Hostname, err = core.UnmarshalString(m, "hostname")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IsPublic, err = core.UnmarshalBool(m, "is_public")
	if err != nil {
		return
	}
	obj.Listeners, err = UnmarshalLoadBalancerListenerReferenceSliceAsProperty(m, "listeners")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.OperatingStatus, err = core.UnmarshalString(m, "operating_status")
	if err != nil {
		return
	}
	obj.Pools, err = UnmarshalLoadBalancerPoolReferenceSliceAsProperty(m, "pools")
	if err != nil {
		return
	}
	obj.PrivateIps, err = UnmarshalIPSliceAsProperty(m, "private_ips")
	if err != nil {
		return
	}
	obj.ProvisioningStatus, err = core.UnmarshalString(m, "provisioning_status")
	if err != nil {
		return
	}
	obj.PublicIps, err = UnmarshalIPSliceAsProperty(m, "public_ips")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupReferenceAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Subnets, err = UnmarshalSubnetReferenceSliceAsProperty(m, "subnets")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerSlice unmarshals a slice of LoadBalancer instances from the specified list of maps.
func UnmarshalLoadBalancerSlice(s []interface{}) (slice []LoadBalancer, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancer'")
			return
		}
		obj, e := UnmarshalLoadBalancer(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerAsProperty unmarshals an instance of LoadBalancer that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancer, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancer'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancer(objMap)
	}
	return
}

// UnmarshalLoadBalancerSliceAsProperty unmarshals a slice of LoadBalancer instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancer, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancer'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerSlice(vSlice)
	}
	return
}

// LoadBalancerCollection : LoadBalancerCollection struct
type LoadBalancerCollection struct {
	// Collection of load balancers.
	LoadBalancers []LoadBalancer `json:"load_balancers" validate:"required"`
}

// UnmarshalLoadBalancerCollection constructs an instance of LoadBalancerCollection from the specified map.
func UnmarshalLoadBalancerCollection(m map[string]interface{}) (result *LoadBalancerCollection, err error) {
	obj := new(LoadBalancerCollection)
	obj.LoadBalancers, err = UnmarshalLoadBalancerSliceAsProperty(m, "load_balancers")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerCollectionSlice unmarshals a slice of LoadBalancerCollection instances from the specified list of maps.
func UnmarshalLoadBalancerCollectionSlice(s []interface{}) (slice []LoadBalancerCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerCollection'")
			return
		}
		obj, e := UnmarshalLoadBalancerCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerCollectionAsProperty unmarshals an instance of LoadBalancerCollection that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerCollectionAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerCollection'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerCollection(objMap)
	}
	return
}

// UnmarshalLoadBalancerCollectionSliceAsProperty unmarshals a slice of LoadBalancerCollection instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerCollection'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerCollectionSlice(vSlice)
	}
	return
}

// LoadBalancerListener : LoadBalancerListener struct
type LoadBalancerListener struct {
	// The certificate instance used for SSL termination. It is applicable only to `https`
	// protocol.
	CertificateInstance *CertificateInstanceReference `json:"certificate_instance,omitempty"`

	// The connection limit of the listener.
	ConnectionLimit *int64 `json:"connection_limit,omitempty"`

	// The date and time that this listener was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The default pool associated with the listener.
	DefaultPool *LoadBalancerPoolReference `json:"default_pool,omitempty"`

	// The listener's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer listener.
	ID *string `json:"id" validate:"required"`

	// The list of policies of this listener.
	Policies []LoadBalancerListenerPolicyReference `json:"policies,omitempty"`

	// The listener port number.
	Port *int64 `json:"port" validate:"required"`

	// The listener protocol.
	Protocol *string `json:"protocol" validate:"required"`

	// The provisioning status of this listener.
	ProvisioningStatus *string `json:"provisioning_status" validate:"required"`
}

// Constants associated with the LoadBalancerListener.Protocol property.
// The listener protocol.
const (
	LoadBalancerListener_Protocol_Http  = "http"
	LoadBalancerListener_Protocol_Https = "https"
	LoadBalancerListener_Protocol_Tcp   = "tcp"
)

// Constants associated with the LoadBalancerListener.ProvisioningStatus property.
// The provisioning status of this listener.
const (
	LoadBalancerListener_ProvisioningStatus_Active             = "active"
	LoadBalancerListener_ProvisioningStatus_CreatePending      = "create_pending"
	LoadBalancerListener_ProvisioningStatus_DeletePending      = "delete_pending"
	LoadBalancerListener_ProvisioningStatus_Failed             = "failed"
	LoadBalancerListener_ProvisioningStatus_MaintenancePending = "maintenance_pending"
	LoadBalancerListener_ProvisioningStatus_UpdatePending      = "update_pending"
)

// UnmarshalLoadBalancerListener constructs an instance of LoadBalancerListener from the specified map.
func UnmarshalLoadBalancerListener(m map[string]interface{}) (result *LoadBalancerListener, err error) {
	obj := new(LoadBalancerListener)
	obj.CertificateInstance, err = UnmarshalCertificateInstanceReferenceAsProperty(m, "certificate_instance")
	if err != nil {
		return
	}
	obj.ConnectionLimit, err = core.UnmarshalInt64(m, "connection_limit")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.DefaultPool, err = UnmarshalLoadBalancerPoolReferenceAsProperty(m, "default_pool")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Policies, err = UnmarshalLoadBalancerListenerPolicyReferenceSliceAsProperty(m, "policies")
	if err != nil {
		return
	}
	obj.Port, err = core.UnmarshalInt64(m, "port")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.ProvisioningStatus, err = core.UnmarshalString(m, "provisioning_status")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerSlice unmarshals a slice of LoadBalancerListener instances from the specified list of maps.
func UnmarshalLoadBalancerListenerSlice(s []interface{}) (slice []LoadBalancerListener, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListener'")
			return
		}
		obj, e := UnmarshalLoadBalancerListener(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerAsProperty unmarshals an instance of LoadBalancerListener that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListener, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListener'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListener(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerSliceAsProperty unmarshals a slice of LoadBalancerListener instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListener, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListener'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerSlice(vSlice)
	}
	return
}

// LoadBalancerListenerCollection : LoadBalancerListenerCollection struct
type LoadBalancerListenerCollection struct {
	// Collection of listeners.
	Listeners []LoadBalancerListener `json:"listeners" validate:"required"`
}

// UnmarshalLoadBalancerListenerCollection constructs an instance of LoadBalancerListenerCollection from the specified map.
func UnmarshalLoadBalancerListenerCollection(m map[string]interface{}) (result *LoadBalancerListenerCollection, err error) {
	obj := new(LoadBalancerListenerCollection)
	obj.Listeners, err = UnmarshalLoadBalancerListenerSliceAsProperty(m, "listeners")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerCollectionSlice unmarshals a slice of LoadBalancerListenerCollection instances from the specified list of maps.
func UnmarshalLoadBalancerListenerCollectionSlice(s []interface{}) (slice []LoadBalancerListenerCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerCollection'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerCollectionAsProperty unmarshals an instance of LoadBalancerListenerCollection that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerCollectionAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListenerCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerCollection'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerCollection(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerCollectionSliceAsProperty unmarshals a slice of LoadBalancerListenerCollection instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerCollection'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerCollectionSlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicy : LoadBalancerListenerPolicy struct
type LoadBalancerListenerPolicy struct {
	// The policy action.
	Action *string `json:"action" validate:"required"`

	// The date and time that this policy was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The listener policy's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The policy's unique identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this policy.
	Name *string `json:"name" validate:"required"`

	// Priority of the policy. Lower value indicates higher priority.
	Priority *int64 `json:"priority" validate:"required"`

	// The provisioning status of this policy.
	ProvisioningStatus *string `json:"provisioning_status" validate:"required"`

	// The rules of this policy.
	Rules []LoadBalancerListenerPolicyRuleReference `json:"rules" validate:"required"`

	// `LoadBalancerPoolReference` is in the response if `action` is `forward`.
	// `LoadBalancerListenerPolicyRedirectURL` is in the response if `action` is `redirect`.
	Target LoadBalancerListenerPolicyTargetReferenceIntf `json:"target,omitempty"`
}

// Constants associated with the LoadBalancerListenerPolicy.Action property.
// The policy action.
const (
	LoadBalancerListenerPolicy_Action_Forward  = "forward"
	LoadBalancerListenerPolicy_Action_Redirect = "redirect"
	LoadBalancerListenerPolicy_Action_Reject   = "reject"
)

// Constants associated with the LoadBalancerListenerPolicy.ProvisioningStatus property.
// The provisioning status of this policy.
const (
	LoadBalancerListenerPolicy_ProvisioningStatus_Active             = "active"
	LoadBalancerListenerPolicy_ProvisioningStatus_CreatePending      = "create_pending"
	LoadBalancerListenerPolicy_ProvisioningStatus_DeletePending      = "delete_pending"
	LoadBalancerListenerPolicy_ProvisioningStatus_Failed             = "failed"
	LoadBalancerListenerPolicy_ProvisioningStatus_MaintenancePending = "maintenance_pending"
	LoadBalancerListenerPolicy_ProvisioningStatus_UpdatePending      = "update_pending"
)

// UnmarshalLoadBalancerListenerPolicy constructs an instance of LoadBalancerListenerPolicy from the specified map.
func UnmarshalLoadBalancerListenerPolicy(m map[string]interface{}) (result *LoadBalancerListenerPolicy, err error) {
	obj := new(LoadBalancerListenerPolicy)
	obj.Action, err = core.UnmarshalString(m, "action")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Priority, err = core.UnmarshalInt64(m, "priority")
	if err != nil {
		return
	}
	obj.ProvisioningStatus, err = core.UnmarshalString(m, "provisioning_status")
	if err != nil {
		return
	}
	obj.Rules, err = UnmarshalLoadBalancerListenerPolicyRuleReferenceSliceAsProperty(m, "rules")
	if err != nil {
		return
	}
	obj.Target, err = UnmarshalLoadBalancerListenerPolicyTargetReferenceAsProperty(m, "target")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicySlice unmarshals a slice of LoadBalancerListenerPolicy instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicySlice(s []interface{}) (slice []LoadBalancerListenerPolicy, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicy'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicy(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyAsProperty unmarshals an instance of LoadBalancerListenerPolicy that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListenerPolicy, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicy'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicy(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicySliceAsProperty unmarshals a slice of LoadBalancerListenerPolicy instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicySliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicy, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicy'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicySlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyCollection : LoadBalancerListenerPolicyCollection struct
type LoadBalancerListenerPolicyCollection struct {
	// Collection of policies.
	Policies []LoadBalancerListenerPolicy `json:"policies" validate:"required"`
}

// UnmarshalLoadBalancerListenerPolicyCollection constructs an instance of LoadBalancerListenerPolicyCollection from the specified map.
func UnmarshalLoadBalancerListenerPolicyCollection(m map[string]interface{}) (result *LoadBalancerListenerPolicyCollection, err error) {
	obj := new(LoadBalancerListenerPolicyCollection)
	obj.Policies, err = UnmarshalLoadBalancerListenerPolicySliceAsProperty(m, "policies")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyCollectionSlice unmarshals a slice of LoadBalancerListenerPolicyCollection instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyCollectionSlice(s []interface{}) (slice []LoadBalancerListenerPolicyCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyCollection'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyCollectionAsProperty unmarshals an instance of LoadBalancerListenerPolicyCollection that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyCollectionAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListenerPolicyCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyCollection'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyCollection(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyCollectionSliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyCollection instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyCollection'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyCollectionSlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyPatchTarget : When `action` is `forward`, `LoadBalancerPoolIdentity` specifies which pool the load balancer forwards the traffic
// to. When `action` is `redirect`,
// `LoadBalancerListenerPolicyRedirectURLPatch` specifies the url and http status code used in the redirect response.
// Models which "extend" this model:
// - LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity
// - LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch
type LoadBalancerListenerPolicyPatchTarget struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id,omitempty"`

	// The pool's canonical URL.
	Href *string `json:"href,omitempty"`

	// The http status code in the redirect response.
	HttpStatusCode *int64 `json:"http_status_code,omitempty"`

	// The redirect target URL.
	URL *string `json:"url,omitempty"`
}

func (*LoadBalancerListenerPolicyPatchTarget) isaLoadBalancerListenerPolicyPatchTarget() bool {
	return true
}

type LoadBalancerListenerPolicyPatchTargetIntf interface {
	isaLoadBalancerListenerPolicyPatchTarget() bool
}

// UnmarshalLoadBalancerListenerPolicyPatchTarget constructs an instance of LoadBalancerListenerPolicyPatchTarget from the specified map.
func UnmarshalLoadBalancerListenerPolicyPatchTarget(m map[string]interface{}) (result LoadBalancerListenerPolicyPatchTargetIntf, err error) {
	obj := new(LoadBalancerListenerPolicyPatchTarget)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.HttpStatusCode, err = core.UnmarshalInt64(m, "http_status_code")
	if err != nil {
		return
	}
	obj.URL, err = core.UnmarshalString(m, "url")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetSlice unmarshals a slice of LoadBalancerListenerPolicyPatchTarget instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyPatchTargetSlice(s []interface{}) (slice []LoadBalancerListenerPolicyPatchTargetIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyPatchTarget'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyPatchTarget(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetAsProperty unmarshals an instance of LoadBalancerListenerPolicyPatchTarget that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPatchTargetAsProperty(m map[string]interface{}, propertyName string) (result LoadBalancerListenerPolicyPatchTargetIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyPatchTarget'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyPatchTarget(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetSliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyPatchTarget instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPatchTargetSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyPatchTargetIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyPatchTarget'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyPatchTargetSlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyPrototype : LoadBalancerListenerPolicyPrototype struct
type LoadBalancerListenerPolicyPrototype struct {
	// The policy action.
	Action *string `json:"action" validate:"required"`

	// The user-defined name for this policy. Names must be unique within the load balancer listener the policy resides in.
	Name *string `json:"name,omitempty"`

	// Priority of the policy. Lower value indicates higher priority.
	Priority *int64 `json:"priority" validate:"required"`

	// The list of rules of this policy.
	Rules []LoadBalancerListenerPolicyRulePrototype `json:"rules,omitempty"`

	// When `action` is `forward`, `LoadBalancerPoolIdentity` is required to specify which
	// pool the load balancer forwards the traffic to. When `action` is `redirect`,
	// `LoadBalancerListenerPolicyRedirectURLPrototype` is required to specify the url and
	// http status code used in the redirect response.
	Target LoadBalancerListenerPolicyPrototypeTargetIntf `json:"target,omitempty"`
}

// Constants associated with the LoadBalancerListenerPolicyPrototype.Action property.
// The policy action.
const (
	LoadBalancerListenerPolicyPrototype_Action_Forward  = "forward"
	LoadBalancerListenerPolicyPrototype_Action_Redirect = "redirect"
	LoadBalancerListenerPolicyPrototype_Action_Reject   = "reject"
)

// NewLoadBalancerListenerPolicyPrototype : Instantiate LoadBalancerListenerPolicyPrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyPrototype(action string, priority int64) (model *LoadBalancerListenerPolicyPrototype, err error) {
	model = &LoadBalancerListenerPolicyPrototype{
		Action:   core.StringPtr(action),
		Priority: core.Int64Ptr(priority),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototype constructs an instance of LoadBalancerListenerPolicyPrototype from the specified map.
func UnmarshalLoadBalancerListenerPolicyPrototype(m map[string]interface{}) (result *LoadBalancerListenerPolicyPrototype, err error) {
	obj := new(LoadBalancerListenerPolicyPrototype)
	obj.Action, err = core.UnmarshalString(m, "action")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Priority, err = core.UnmarshalInt64(m, "priority")
	if err != nil {
		return
	}
	obj.Rules, err = UnmarshalLoadBalancerListenerPolicyRulePrototypeSliceAsProperty(m, "rules")
	if err != nil {
		return
	}
	obj.Target, err = UnmarshalLoadBalancerListenerPolicyPrototypeTargetAsProperty(m, "target")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototypeSlice unmarshals a slice of LoadBalancerListenerPolicyPrototype instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyPrototypeSlice(s []interface{}) (slice []LoadBalancerListenerPolicyPrototype, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyPrototype'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyPrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototypeAsProperty unmarshals an instance of LoadBalancerListenerPolicyPrototype that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPrototypeAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListenerPolicyPrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyPrototype'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyPrototype(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototypeSliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyPrototype instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyPrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyPrototype'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyPrototypeSlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyPrototypeTarget : When `action` is `forward`, `LoadBalancerPoolIdentity` is required to specify which pool the load balancer forwards
// the traffic to. When `action` is `redirect`,
// `LoadBalancerListenerPolicyRedirectURLPrototype` is required to specify the url and http status code used in the
// redirect response.
// Models which "extend" this model:
// - LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity
// - LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype
type LoadBalancerListenerPolicyPrototypeTarget struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id,omitempty"`

	// The pool's canonical URL.
	Href *string `json:"href,omitempty"`

	// The http status code in the redirect response.
	HttpStatusCode *int64 `json:"http_status_code,omitempty"`

	// The redirect target URL.
	URL *string `json:"url,omitempty"`
}

func (*LoadBalancerListenerPolicyPrototypeTarget) isaLoadBalancerListenerPolicyPrototypeTarget() bool {
	return true
}

type LoadBalancerListenerPolicyPrototypeTargetIntf interface {
	isaLoadBalancerListenerPolicyPrototypeTarget() bool
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTarget constructs an instance of LoadBalancerListenerPolicyPrototypeTarget from the specified map.
func UnmarshalLoadBalancerListenerPolicyPrototypeTarget(m map[string]interface{}) (result LoadBalancerListenerPolicyPrototypeTargetIntf, err error) {
	obj := new(LoadBalancerListenerPolicyPrototypeTarget)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.HttpStatusCode, err = core.UnmarshalInt64(m, "http_status_code")
	if err != nil {
		return
	}
	obj.URL, err = core.UnmarshalString(m, "url")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetSlice unmarshals a slice of LoadBalancerListenerPolicyPrototypeTarget instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetSlice(s []interface{}) (slice []LoadBalancerListenerPolicyPrototypeTargetIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyPrototypeTarget'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyPrototypeTarget(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetAsProperty unmarshals an instance of LoadBalancerListenerPolicyPrototypeTarget that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetAsProperty(m map[string]interface{}, propertyName string) (result LoadBalancerListenerPolicyPrototypeTargetIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyPrototypeTarget'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyPrototypeTarget(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetSliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyPrototypeTarget instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyPrototypeTargetIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyPrototypeTarget'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyPrototypeTargetSlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyReference : LoadBalancerListenerPolicyReference struct
type LoadBalancerListenerPolicyReference struct {
	// The listener policy's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The policy's unique identifier.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalLoadBalancerListenerPolicyReference constructs an instance of LoadBalancerListenerPolicyReference from the specified map.
func UnmarshalLoadBalancerListenerPolicyReference(m map[string]interface{}) (result *LoadBalancerListenerPolicyReference, err error) {
	obj := new(LoadBalancerListenerPolicyReference)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyReferenceSlice unmarshals a slice of LoadBalancerListenerPolicyReference instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyReferenceSlice(s []interface{}) (slice []LoadBalancerListenerPolicyReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyReference'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyReferenceAsProperty unmarshals an instance of LoadBalancerListenerPolicyReference that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyReferenceAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListenerPolicyReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyReference'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyReference(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyReferenceSliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyReference instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyReference'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyReferenceSlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyRule : LoadBalancerListenerPolicyRule struct
type LoadBalancerListenerPolicyRule struct {
	// The condition of the rule.
	Condition *string `json:"condition" validate:"required"`

	// The date and time that this rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// HTTP header field. This is only applicable to "header" rule type.
	Field *string `json:"field,omitempty"`

	// The rule's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The rule's unique identifier.
	ID *string `json:"id" validate:"required"`

	// The provisioning status of this rule.
	ProvisioningStatus *string `json:"provisioning_status" validate:"required"`

	// The type of the rule.
	Type *string `json:"type" validate:"required"`

	// Value to be matched for rule condition.
	Value *string `json:"value" validate:"required"`
}

// Constants associated with the LoadBalancerListenerPolicyRule.Condition property.
// The condition of the rule.
const (
	LoadBalancerListenerPolicyRule_Condition_Contains     = "contains"
	LoadBalancerListenerPolicyRule_Condition_Equals       = "equals"
	LoadBalancerListenerPolicyRule_Condition_MatchesRegex = "matches_regex"
)

// Constants associated with the LoadBalancerListenerPolicyRule.ProvisioningStatus property.
// The provisioning status of this rule.
const (
	LoadBalancerListenerPolicyRule_ProvisioningStatus_Active             = "active"
	LoadBalancerListenerPolicyRule_ProvisioningStatus_CreatePending      = "create_pending"
	LoadBalancerListenerPolicyRule_ProvisioningStatus_DeletePending      = "delete_pending"
	LoadBalancerListenerPolicyRule_ProvisioningStatus_Failed             = "failed"
	LoadBalancerListenerPolicyRule_ProvisioningStatus_MaintenancePending = "maintenance_pending"
	LoadBalancerListenerPolicyRule_ProvisioningStatus_UpdatePending      = "update_pending"
)

// Constants associated with the LoadBalancerListenerPolicyRule.Type property.
// The type of the rule.
const (
	LoadBalancerListenerPolicyRule_Type_Header   = "header"
	LoadBalancerListenerPolicyRule_Type_Hostname = "hostname"
	LoadBalancerListenerPolicyRule_Type_Path     = "path"
)

// UnmarshalLoadBalancerListenerPolicyRule constructs an instance of LoadBalancerListenerPolicyRule from the specified map.
func UnmarshalLoadBalancerListenerPolicyRule(m map[string]interface{}) (result *LoadBalancerListenerPolicyRule, err error) {
	obj := new(LoadBalancerListenerPolicyRule)
	obj.Condition, err = core.UnmarshalString(m, "condition")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Field, err = core.UnmarshalString(m, "field")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.ProvisioningStatus, err = core.UnmarshalString(m, "provisioning_status")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.Value, err = core.UnmarshalString(m, "value")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyRuleSlice unmarshals a slice of LoadBalancerListenerPolicyRule instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyRuleSlice(s []interface{}) (slice []LoadBalancerListenerPolicyRule, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyRule'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyRule(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyRuleAsProperty unmarshals an instance of LoadBalancerListenerPolicyRule that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyRuleAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListenerPolicyRule, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyRule'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyRule(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyRuleSliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyRule instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyRuleSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyRule, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyRule'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyRuleSlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyRuleCollection : LoadBalancerListenerPolicyRuleCollection struct
type LoadBalancerListenerPolicyRuleCollection struct {
	// Collection of rules.
	Rules []LoadBalancerListenerPolicyRule `json:"rules" validate:"required"`
}

// UnmarshalLoadBalancerListenerPolicyRuleCollection constructs an instance of LoadBalancerListenerPolicyRuleCollection from the specified map.
func UnmarshalLoadBalancerListenerPolicyRuleCollection(m map[string]interface{}) (result *LoadBalancerListenerPolicyRuleCollection, err error) {
	obj := new(LoadBalancerListenerPolicyRuleCollection)
	obj.Rules, err = UnmarshalLoadBalancerListenerPolicyRuleSliceAsProperty(m, "rules")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyRuleCollectionSlice unmarshals a slice of LoadBalancerListenerPolicyRuleCollection instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyRuleCollectionSlice(s []interface{}) (slice []LoadBalancerListenerPolicyRuleCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyRuleCollection'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyRuleCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyRuleCollectionAsProperty unmarshals an instance of LoadBalancerListenerPolicyRuleCollection that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyRuleCollectionAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListenerPolicyRuleCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyRuleCollection'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyRuleCollection(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyRuleCollectionSliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyRuleCollection instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyRuleCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyRuleCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyRuleCollection'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyRuleCollectionSlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyRulePrototype : LoadBalancerListenerPolicyRulePrototype struct
type LoadBalancerListenerPolicyRulePrototype struct {
	// The condition of the rule.
	Condition *string `json:"condition" validate:"required"`

	// HTTP header field. This is only applicable to "header" rule type.
	Field *string `json:"field,omitempty"`

	// The type of the rule.
	Type *string `json:"type" validate:"required"`

	// Value to be matched for rule condition.
	Value *string `json:"value" validate:"required"`
}

// Constants associated with the LoadBalancerListenerPolicyRulePrototype.Condition property.
// The condition of the rule.
const (
	LoadBalancerListenerPolicyRulePrototype_Condition_Contains     = "contains"
	LoadBalancerListenerPolicyRulePrototype_Condition_Equals       = "equals"
	LoadBalancerListenerPolicyRulePrototype_Condition_MatchesRegex = "matches_regex"
)

// Constants associated with the LoadBalancerListenerPolicyRulePrototype.Type property.
// The type of the rule.
const (
	LoadBalancerListenerPolicyRulePrototype_Type_Header   = "header"
	LoadBalancerListenerPolicyRulePrototype_Type_Hostname = "hostname"
	LoadBalancerListenerPolicyRulePrototype_Type_Path     = "path"
)

// NewLoadBalancerListenerPolicyRulePrototype : Instantiate LoadBalancerListenerPolicyRulePrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyRulePrototype(condition string, typeVar string, value string) (model *LoadBalancerListenerPolicyRulePrototype, err error) {
	model = &LoadBalancerListenerPolicyRulePrototype{
		Condition: core.StringPtr(condition),
		Type:      core.StringPtr(typeVar),
		Value:     core.StringPtr(value),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerListenerPolicyRulePrototype constructs an instance of LoadBalancerListenerPolicyRulePrototype from the specified map.
func UnmarshalLoadBalancerListenerPolicyRulePrototype(m map[string]interface{}) (result *LoadBalancerListenerPolicyRulePrototype, err error) {
	obj := new(LoadBalancerListenerPolicyRulePrototype)
	obj.Condition, err = core.UnmarshalString(m, "condition")
	if err != nil {
		return
	}
	obj.Field, err = core.UnmarshalString(m, "field")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.Value, err = core.UnmarshalString(m, "value")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyRulePrototypeSlice unmarshals a slice of LoadBalancerListenerPolicyRulePrototype instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyRulePrototypeSlice(s []interface{}) (slice []LoadBalancerListenerPolicyRulePrototype, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyRulePrototype'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyRulePrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyRulePrototypeAsProperty unmarshals an instance of LoadBalancerListenerPolicyRulePrototype that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyRulePrototypeAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListenerPolicyRulePrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyRulePrototype'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyRulePrototype(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyRulePrototypeSliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyRulePrototype instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyRulePrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyRulePrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyRulePrototype'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyRulePrototypeSlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyRuleReference : LoadBalancerListenerPolicyRuleReference struct
type LoadBalancerListenerPolicyRuleReference struct {
	// The rule's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The rule's unique identifier.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalLoadBalancerListenerPolicyRuleReference constructs an instance of LoadBalancerListenerPolicyRuleReference from the specified map.
func UnmarshalLoadBalancerListenerPolicyRuleReference(m map[string]interface{}) (result *LoadBalancerListenerPolicyRuleReference, err error) {
	obj := new(LoadBalancerListenerPolicyRuleReference)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyRuleReferenceSlice unmarshals a slice of LoadBalancerListenerPolicyRuleReference instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyRuleReferenceSlice(s []interface{}) (slice []LoadBalancerListenerPolicyRuleReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyRuleReference'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyRuleReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyRuleReferenceAsProperty unmarshals an instance of LoadBalancerListenerPolicyRuleReference that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyRuleReferenceAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListenerPolicyRuleReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyRuleReference'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyRuleReference(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyRuleReferenceSliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyRuleReference instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyRuleReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyRuleReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyRuleReference'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyRuleReferenceSlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyTargetReference : `LoadBalancerPoolReference` is in the response if `action` is `forward`.
// `LoadBalancerListenerPolicyRedirectURL` is in the response if `action` is `redirect`.
// Models which "extend" this model:
// - LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference
// - LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL
type LoadBalancerListenerPolicyTargetReference struct {
	// The pool's canonical URL.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this load balancer pool.
	ID *string `json:"id,omitempty"`

	// The user-defined name for this load balancer pool.
	Name *string `json:"name,omitempty"`

	// The http status code in the redirect response.
	HttpStatusCode *int64 `json:"http_status_code,omitempty"`

	// The redirect target URL.
	URL *string `json:"url,omitempty"`
}

func (*LoadBalancerListenerPolicyTargetReference) isaLoadBalancerListenerPolicyTargetReference() bool {
	return true
}

type LoadBalancerListenerPolicyTargetReferenceIntf interface {
	isaLoadBalancerListenerPolicyTargetReference() bool
}

// UnmarshalLoadBalancerListenerPolicyTargetReference constructs an instance of LoadBalancerListenerPolicyTargetReference from the specified map.
func UnmarshalLoadBalancerListenerPolicyTargetReference(m map[string]interface{}) (result LoadBalancerListenerPolicyTargetReferenceIntf, err error) {
	obj := new(LoadBalancerListenerPolicyTargetReference)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.HttpStatusCode, err = core.UnmarshalInt64(m, "http_status_code")
	if err != nil {
		return
	}
	obj.URL, err = core.UnmarshalString(m, "url")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyTargetReferenceSlice unmarshals a slice of LoadBalancerListenerPolicyTargetReference instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyTargetReferenceSlice(s []interface{}) (slice []LoadBalancerListenerPolicyTargetReferenceIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyTargetReference'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyTargetReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyTargetReferenceAsProperty unmarshals an instance of LoadBalancerListenerPolicyTargetReference that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyTargetReferenceAsProperty(m map[string]interface{}, propertyName string) (result LoadBalancerListenerPolicyTargetReferenceIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyTargetReference'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyTargetReference(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyTargetReferenceSliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyTargetReference instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyTargetReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyTargetReferenceIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyTargetReference'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyTargetReferenceSlice(vSlice)
	}
	return
}

// LoadBalancerListenerPrototypeLoadBalancerContext : LoadBalancerListenerPrototypeLoadBalancerContext struct
type LoadBalancerListenerPrototypeLoadBalancerContext struct {
	// The connection limit of the listener.
	ConnectionLimit *int64 `json:"connection_limit,omitempty"`

	// The default pool associated with the listener.
	DefaultPool *LoadBalancerPoolIdentityByName `json:"default_pool,omitempty"`

	// The listener port number.
	Port *int64 `json:"port" validate:"required"`

	// The listener protocol.
	Protocol *string `json:"protocol" validate:"required"`
}

// Constants associated with the LoadBalancerListenerPrototypeLoadBalancerContext.Protocol property.
// The listener protocol.
const (
	LoadBalancerListenerPrototypeLoadBalancerContext_Protocol_Http  = "http"
	LoadBalancerListenerPrototypeLoadBalancerContext_Protocol_Https = "https"
	LoadBalancerListenerPrototypeLoadBalancerContext_Protocol_Tcp   = "tcp"
)

// NewLoadBalancerListenerPrototypeLoadBalancerContext : Instantiate LoadBalancerListenerPrototypeLoadBalancerContext (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPrototypeLoadBalancerContext(port int64, protocol string) (model *LoadBalancerListenerPrototypeLoadBalancerContext, err error) {
	model = &LoadBalancerListenerPrototypeLoadBalancerContext{
		Port:     core.Int64Ptr(port),
		Protocol: core.StringPtr(protocol),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerListenerPrototypeLoadBalancerContext constructs an instance of LoadBalancerListenerPrototypeLoadBalancerContext from the specified map.
func UnmarshalLoadBalancerListenerPrototypeLoadBalancerContext(m map[string]interface{}) (result *LoadBalancerListenerPrototypeLoadBalancerContext, err error) {
	obj := new(LoadBalancerListenerPrototypeLoadBalancerContext)
	obj.ConnectionLimit, err = core.UnmarshalInt64(m, "connection_limit")
	if err != nil {
		return
	}
	obj.DefaultPool, err = UnmarshalLoadBalancerPoolIdentityByNameAsProperty(m, "default_pool")
	if err != nil {
		return
	}
	obj.Port, err = core.UnmarshalInt64(m, "port")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPrototypeLoadBalancerContextSlice unmarshals a slice of LoadBalancerListenerPrototypeLoadBalancerContext instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPrototypeLoadBalancerContextSlice(s []interface{}) (slice []LoadBalancerListenerPrototypeLoadBalancerContext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPrototypeLoadBalancerContext'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPrototypeLoadBalancerContext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPrototypeLoadBalancerContextAsProperty unmarshals an instance of LoadBalancerListenerPrototypeLoadBalancerContext that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPrototypeLoadBalancerContextAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListenerPrototypeLoadBalancerContext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPrototypeLoadBalancerContext'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPrototypeLoadBalancerContext(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPrototypeLoadBalancerContextSliceAsProperty unmarshals a slice of LoadBalancerListenerPrototypeLoadBalancerContext instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPrototypeLoadBalancerContextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPrototypeLoadBalancerContext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPrototypeLoadBalancerContext'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPrototypeLoadBalancerContextSlice(vSlice)
	}
	return
}

// LoadBalancerListenerReference : LoadBalancerListenerReference struct
type LoadBalancerListenerReference struct {
	// The listener's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer listener.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalLoadBalancerListenerReference constructs an instance of LoadBalancerListenerReference from the specified map.
func UnmarshalLoadBalancerListenerReference(m map[string]interface{}) (result *LoadBalancerListenerReference, err error) {
	obj := new(LoadBalancerListenerReference)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerReferenceSlice unmarshals a slice of LoadBalancerListenerReference instances from the specified list of maps.
func UnmarshalLoadBalancerListenerReferenceSlice(s []interface{}) (slice []LoadBalancerListenerReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerReference'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerReferenceAsProperty unmarshals an instance of LoadBalancerListenerReference that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerReferenceAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListenerReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerReference'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerReference(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerReferenceSliceAsProperty unmarshals a slice of LoadBalancerListenerReference instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerReference'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerReferenceSlice(vSlice)
	}
	return
}

// LoadBalancerPool : LoadBalancerPool struct
type LoadBalancerPool struct {
	// The load balancing algorithm.
	Algorithm *string `json:"algorithm" validate:"required"`

	// The date and time that this pool was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The health monitor of this pool.
	HealthMonitor *LoadBalancerPoolHealthMonitor `json:"health_monitor" validate:"required"`

	// The pool's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer pool.
	ID *string `json:"id" validate:"required"`

	// The backend server members of the pool.
	Members []LoadBalancerPoolMemberReference `json:"members,omitempty"`

	// The user-defined name for this load balancer pool.
	Name *string `json:"name" validate:"required"`

	// The pool protocol.
	Protocol *string `json:"protocol" validate:"required"`

	// The provisioning status of this pool.
	ProvisioningStatus *string `json:"provisioning_status" validate:"required"`

	// The session persistence of this pool.
	SessionPersistence *LoadBalancerPoolSessionPersistence `json:"session_persistence,omitempty"`
}

// Constants associated with the LoadBalancerPool.Algorithm property.
// The load balancing algorithm.
const (
	LoadBalancerPool_Algorithm_LeastConnections   = "least_connections"
	LoadBalancerPool_Algorithm_RoundRobin         = "round_robin"
	LoadBalancerPool_Algorithm_WeightedRoundRobin = "weighted_round_robin"
)

// Constants associated with the LoadBalancerPool.Protocol property.
// The pool protocol.
const (
	LoadBalancerPool_Protocol_Http = "http"
	LoadBalancerPool_Protocol_Tcp  = "tcp"
)

// Constants associated with the LoadBalancerPool.ProvisioningStatus property.
// The provisioning status of this pool.
const (
	LoadBalancerPool_ProvisioningStatus_Active             = "active"
	LoadBalancerPool_ProvisioningStatus_CreatePending      = "create_pending"
	LoadBalancerPool_ProvisioningStatus_DeletePending      = "delete_pending"
	LoadBalancerPool_ProvisioningStatus_Failed             = "failed"
	LoadBalancerPool_ProvisioningStatus_MaintenancePending = "maintenance_pending"
	LoadBalancerPool_ProvisioningStatus_UpdatePending      = "update_pending"
)

// UnmarshalLoadBalancerPool constructs an instance of LoadBalancerPool from the specified map.
func UnmarshalLoadBalancerPool(m map[string]interface{}) (result *LoadBalancerPool, err error) {
	obj := new(LoadBalancerPool)
	obj.Algorithm, err = core.UnmarshalString(m, "algorithm")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.HealthMonitor, err = UnmarshalLoadBalancerPoolHealthMonitorAsProperty(m, "health_monitor")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Members, err = UnmarshalLoadBalancerPoolMemberReferenceSliceAsProperty(m, "members")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.ProvisioningStatus, err = core.UnmarshalString(m, "provisioning_status")
	if err != nil {
		return
	}
	obj.SessionPersistence, err = UnmarshalLoadBalancerPoolSessionPersistenceAsProperty(m, "session_persistence")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolSlice unmarshals a slice of LoadBalancerPool instances from the specified list of maps.
func UnmarshalLoadBalancerPoolSlice(s []interface{}) (slice []LoadBalancerPool, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPool'")
			return
		}
		obj, e := UnmarshalLoadBalancerPool(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerPoolAsProperty unmarshals an instance of LoadBalancerPool that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerPool, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPool'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPool(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolSliceAsProperty unmarshals a slice of LoadBalancerPool instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPool, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPool'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolSlice(vSlice)
	}
	return
}

// LoadBalancerPoolCollection : LoadBalancerPoolCollection struct
type LoadBalancerPoolCollection struct {
	// Collection of pools.
	Pools []LoadBalancerPool `json:"pools" validate:"required"`
}

// UnmarshalLoadBalancerPoolCollection constructs an instance of LoadBalancerPoolCollection from the specified map.
func UnmarshalLoadBalancerPoolCollection(m map[string]interface{}) (result *LoadBalancerPoolCollection, err error) {
	obj := new(LoadBalancerPoolCollection)
	obj.Pools, err = UnmarshalLoadBalancerPoolSliceAsProperty(m, "pools")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolCollectionSlice unmarshals a slice of LoadBalancerPoolCollection instances from the specified list of maps.
func UnmarshalLoadBalancerPoolCollectionSlice(s []interface{}) (slice []LoadBalancerPoolCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolCollection'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerPoolCollectionAsProperty unmarshals an instance of LoadBalancerPoolCollection that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolCollectionAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerPoolCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolCollection'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolCollection(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolCollectionSliceAsProperty unmarshals a slice of LoadBalancerPoolCollection instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolCollection'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolCollectionSlice(vSlice)
	}
	return
}

// LoadBalancerPoolHealthMonitor : LoadBalancerPoolHealthMonitor struct
type LoadBalancerPoolHealthMonitor struct {
	// The health check interval in seconds. Interval must be greater than timeout value.
	Delay *int64 `json:"delay" validate:"required"`

	// The health check max retries.
	MaxRetries *int64 `json:"max_retries" validate:"required"`

	// The health check port number. If specified, this overrides the ports specified in the server member resources.
	Port *int64 `json:"port,omitempty"`

	// The health check timeout in seconds.
	Timeout *int64 `json:"timeout" validate:"required"`

	// The pool protocol.
	Type *string `json:"type" validate:"required"`

	// The health check URL. This is applicable only to `http` type of health monitor.
	UrlPath *string `json:"url_path,omitempty"`
}

// Constants associated with the LoadBalancerPoolHealthMonitor.Type property.
// The pool protocol.
const (
	LoadBalancerPoolHealthMonitor_Type_Http = "http"
	LoadBalancerPoolHealthMonitor_Type_Tcp  = "tcp"
)

// UnmarshalLoadBalancerPoolHealthMonitor constructs an instance of LoadBalancerPoolHealthMonitor from the specified map.
func UnmarshalLoadBalancerPoolHealthMonitor(m map[string]interface{}) (result *LoadBalancerPoolHealthMonitor, err error) {
	obj := new(LoadBalancerPoolHealthMonitor)
	obj.Delay, err = core.UnmarshalInt64(m, "delay")
	if err != nil {
		return
	}
	obj.MaxRetries, err = core.UnmarshalInt64(m, "max_retries")
	if err != nil {
		return
	}
	obj.Port, err = core.UnmarshalInt64(m, "port")
	if err != nil {
		return
	}
	obj.Timeout, err = core.UnmarshalInt64(m, "timeout")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.UrlPath, err = core.UnmarshalString(m, "url_path")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolHealthMonitorSlice unmarshals a slice of LoadBalancerPoolHealthMonitor instances from the specified list of maps.
func UnmarshalLoadBalancerPoolHealthMonitorSlice(s []interface{}) (slice []LoadBalancerPoolHealthMonitor, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolHealthMonitor'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolHealthMonitor(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerPoolHealthMonitorAsProperty unmarshals an instance of LoadBalancerPoolHealthMonitor that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolHealthMonitorAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerPoolHealthMonitor, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolHealthMonitor'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolHealthMonitor(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolHealthMonitorSliceAsProperty unmarshals a slice of LoadBalancerPoolHealthMonitor instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolHealthMonitorSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolHealthMonitor, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolHealthMonitor'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolHealthMonitorSlice(vSlice)
	}
	return
}

// LoadBalancerPoolHealthMonitorPatch : LoadBalancerPoolHealthMonitorPatch struct
type LoadBalancerPoolHealthMonitorPatch struct {
	// The health check interval in seconds. Interval must be greater than timeout value.
	Delay *int64 `json:"delay" validate:"required"`

	// The health check max retries.
	MaxRetries *int64 `json:"max_retries" validate:"required"`

	// The health check port number. If specified, this overrides the ports specified in the server member resources.
	// Specify `null` to remove an existing port value.
	Port *int64 `json:"port,omitempty"`

	// The health check timeout in seconds.
	Timeout *int64 `json:"timeout" validate:"required"`

	// The pool protocol.
	Type *string `json:"type" validate:"required"`

	// The health check URL. This is applicable only to `http` type of health monitor.
	UrlPath *string `json:"url_path,omitempty"`
}

// Constants associated with the LoadBalancerPoolHealthMonitorPatch.Type property.
// The pool protocol.
const (
	LoadBalancerPoolHealthMonitorPatch_Type_Http = "http"
	LoadBalancerPoolHealthMonitorPatch_Type_Tcp  = "tcp"
)

// NewLoadBalancerPoolHealthMonitorPatch : Instantiate LoadBalancerPoolHealthMonitorPatch (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolHealthMonitorPatch(delay int64, maxRetries int64, timeout int64, typeVar string) (model *LoadBalancerPoolHealthMonitorPatch, err error) {
	model = &LoadBalancerPoolHealthMonitorPatch{
		Delay:      core.Int64Ptr(delay),
		MaxRetries: core.Int64Ptr(maxRetries),
		Timeout:    core.Int64Ptr(timeout),
		Type:       core.StringPtr(typeVar),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolHealthMonitorPatch constructs an instance of LoadBalancerPoolHealthMonitorPatch from the specified map.
func UnmarshalLoadBalancerPoolHealthMonitorPatch(m map[string]interface{}) (result *LoadBalancerPoolHealthMonitorPatch, err error) {
	obj := new(LoadBalancerPoolHealthMonitorPatch)
	obj.Delay, err = core.UnmarshalInt64(m, "delay")
	if err != nil {
		return
	}
	obj.MaxRetries, err = core.UnmarshalInt64(m, "max_retries")
	if err != nil {
		return
	}
	obj.Port, err = core.UnmarshalInt64(m, "port")
	if err != nil {
		return
	}
	obj.Timeout, err = core.UnmarshalInt64(m, "timeout")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.UrlPath, err = core.UnmarshalString(m, "url_path")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolHealthMonitorPatchSlice unmarshals a slice of LoadBalancerPoolHealthMonitorPatch instances from the specified list of maps.
func UnmarshalLoadBalancerPoolHealthMonitorPatchSlice(s []interface{}) (slice []LoadBalancerPoolHealthMonitorPatch, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolHealthMonitorPatch'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolHealthMonitorPatch(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerPoolHealthMonitorPatchAsProperty unmarshals an instance of LoadBalancerPoolHealthMonitorPatch that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolHealthMonitorPatchAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerPoolHealthMonitorPatch, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolHealthMonitorPatch'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolHealthMonitorPatch(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolHealthMonitorPatchSliceAsProperty unmarshals a slice of LoadBalancerPoolHealthMonitorPatch instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolHealthMonitorPatchSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolHealthMonitorPatch, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolHealthMonitorPatch'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolHealthMonitorPatchSlice(vSlice)
	}
	return
}

// LoadBalancerPoolHealthMonitorPrototype : LoadBalancerPoolHealthMonitorPrototype struct
type LoadBalancerPoolHealthMonitorPrototype struct {
	// The health check interval in seconds. Interval must be greater than timeout value.
	Delay *int64 `json:"delay" validate:"required"`

	// The health check max retries.
	MaxRetries *int64 `json:"max_retries" validate:"required"`

	// The health check port number. If specified, this overrides the ports specified in the server member resources.
	Port *int64 `json:"port,omitempty"`

	// The health check timeout in seconds.
	Timeout *int64 `json:"timeout" validate:"required"`

	// The pool protocol.
	Type *string `json:"type" validate:"required"`

	// The health check URL. This is applicable only to `http` type of health monitor.
	UrlPath *string `json:"url_path,omitempty"`
}

// Constants associated with the LoadBalancerPoolHealthMonitorPrototype.Type property.
// The pool protocol.
const (
	LoadBalancerPoolHealthMonitorPrototype_Type_Http = "http"
	LoadBalancerPoolHealthMonitorPrototype_Type_Tcp  = "tcp"
)

// NewLoadBalancerPoolHealthMonitorPrototype : Instantiate LoadBalancerPoolHealthMonitorPrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolHealthMonitorPrototype(delay int64, maxRetries int64, timeout int64, typeVar string) (model *LoadBalancerPoolHealthMonitorPrototype, err error) {
	model = &LoadBalancerPoolHealthMonitorPrototype{
		Delay:      core.Int64Ptr(delay),
		MaxRetries: core.Int64Ptr(maxRetries),
		Timeout:    core.Int64Ptr(timeout),
		Type:       core.StringPtr(typeVar),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolHealthMonitorPrototype constructs an instance of LoadBalancerPoolHealthMonitorPrototype from the specified map.
func UnmarshalLoadBalancerPoolHealthMonitorPrototype(m map[string]interface{}) (result *LoadBalancerPoolHealthMonitorPrototype, err error) {
	obj := new(LoadBalancerPoolHealthMonitorPrototype)
	obj.Delay, err = core.UnmarshalInt64(m, "delay")
	if err != nil {
		return
	}
	obj.MaxRetries, err = core.UnmarshalInt64(m, "max_retries")
	if err != nil {
		return
	}
	obj.Port, err = core.UnmarshalInt64(m, "port")
	if err != nil {
		return
	}
	obj.Timeout, err = core.UnmarshalInt64(m, "timeout")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.UrlPath, err = core.UnmarshalString(m, "url_path")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolHealthMonitorPrototypeSlice unmarshals a slice of LoadBalancerPoolHealthMonitorPrototype instances from the specified list of maps.
func UnmarshalLoadBalancerPoolHealthMonitorPrototypeSlice(s []interface{}) (slice []LoadBalancerPoolHealthMonitorPrototype, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolHealthMonitorPrototype'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolHealthMonitorPrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerPoolHealthMonitorPrototypeAsProperty unmarshals an instance of LoadBalancerPoolHealthMonitorPrototype that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolHealthMonitorPrototypeAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerPoolHealthMonitorPrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolHealthMonitorPrototype'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolHealthMonitorPrototype(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolHealthMonitorPrototypeSliceAsProperty unmarshals a slice of LoadBalancerPoolHealthMonitorPrototype instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolHealthMonitorPrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolHealthMonitorPrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolHealthMonitorPrototype'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolHealthMonitorPrototypeSlice(vSlice)
	}
	return
}

// LoadBalancerPoolIdentity : Identifies a load balancer pool by a unique property.
// Models which "extend" this model:
// - LoadBalancerPoolIdentityByID
// - LoadBalancerPoolIdentityByHref
type LoadBalancerPoolIdentity struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id,omitempty"`

	// The pool's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*LoadBalancerPoolIdentity) isaLoadBalancerPoolIdentity() bool {
	return true
}

type LoadBalancerPoolIdentityIntf interface {
	isaLoadBalancerPoolIdentity() bool
}

// UnmarshalLoadBalancerPoolIdentity constructs an instance of LoadBalancerPoolIdentity from the specified map.
func UnmarshalLoadBalancerPoolIdentity(m map[string]interface{}) (result LoadBalancerPoolIdentityIntf, err error) {
	obj := new(LoadBalancerPoolIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolIdentitySlice unmarshals a slice of LoadBalancerPoolIdentity instances from the specified list of maps.
func UnmarshalLoadBalancerPoolIdentitySlice(s []interface{}) (slice []LoadBalancerPoolIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolIdentity'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalLoadBalancerPoolIdentityAsProperty unmarshals an instance of LoadBalancerPoolIdentity that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolIdentityAsProperty(m map[string]interface{}, propertyName string) (result LoadBalancerPoolIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolIdentity'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolIdentity(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolIdentitySliceAsProperty unmarshals a slice of LoadBalancerPoolIdentity instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolIdentitySlice(vSlice)
	}
	return
}

// LoadBalancerPoolIdentityByName : LoadBalancerPoolIdentityByName struct
type LoadBalancerPoolIdentityByName struct {
	// The user-defined name for this load balancer pool.
	Name *string `json:"name" validate:"required"`
}

// NewLoadBalancerPoolIdentityByName : Instantiate LoadBalancerPoolIdentityByName (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolIdentityByName(name string) (model *LoadBalancerPoolIdentityByName, err error) {
	model = &LoadBalancerPoolIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolIdentityByName constructs an instance of LoadBalancerPoolIdentityByName from the specified map.
func UnmarshalLoadBalancerPoolIdentityByName(m map[string]interface{}) (result *LoadBalancerPoolIdentityByName, err error) {
	obj := new(LoadBalancerPoolIdentityByName)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolIdentityByNameSlice unmarshals a slice of LoadBalancerPoolIdentityByName instances from the specified list of maps.
func UnmarshalLoadBalancerPoolIdentityByNameSlice(s []interface{}) (slice []LoadBalancerPoolIdentityByName, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolIdentityByName'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolIdentityByName(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerPoolIdentityByNameAsProperty unmarshals an instance of LoadBalancerPoolIdentityByName that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolIdentityByNameAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerPoolIdentityByName, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolIdentityByName'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolIdentityByName(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolIdentityByNameSliceAsProperty unmarshals a slice of LoadBalancerPoolIdentityByName instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolIdentityByNameSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolIdentityByName, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolIdentityByName'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolIdentityByNameSlice(vSlice)
	}
	return
}

// LoadBalancerPoolMember : LoadBalancerPoolMember struct
type LoadBalancerPoolMember struct {
	// The date and time that this member was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Health of the server member in the pool.
	Health *string `json:"health" validate:"required"`

	// The member's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer pool member.
	ID *string `json:"id" validate:"required"`

	// The port number of the application running in the server member.
	Port *int64 `json:"port" validate:"required"`

	// The provisioning status of this member.
	ProvisioningStatus *string `json:"provisioning_status" validate:"required"`

	// The pool member target.
	Target LoadBalancerPoolMemberTargetIntf `json:"target" validate:"required"`

	// Weight of the server member. This takes effect only when the load balancing algorithm of its belonging pool is
	// `weighted_round_robin`.
	Weight *int64 `json:"weight,omitempty"`
}

// Constants associated with the LoadBalancerPoolMember.Health property.
// Health of the server member in the pool.
const (
	LoadBalancerPoolMember_Health_Faulted = "faulted"
	LoadBalancerPoolMember_Health_Ok      = "ok"
	LoadBalancerPoolMember_Health_Unknown = "unknown"
)

// Constants associated with the LoadBalancerPoolMember.ProvisioningStatus property.
// The provisioning status of this member.
const (
	LoadBalancerPoolMember_ProvisioningStatus_Active             = "active"
	LoadBalancerPoolMember_ProvisioningStatus_CreatePending      = "create_pending"
	LoadBalancerPoolMember_ProvisioningStatus_DeletePending      = "delete_pending"
	LoadBalancerPoolMember_ProvisioningStatus_Failed             = "failed"
	LoadBalancerPoolMember_ProvisioningStatus_MaintenancePending = "maintenance_pending"
	LoadBalancerPoolMember_ProvisioningStatus_UpdatePending      = "update_pending"
)

// UnmarshalLoadBalancerPoolMember constructs an instance of LoadBalancerPoolMember from the specified map.
func UnmarshalLoadBalancerPoolMember(m map[string]interface{}) (result *LoadBalancerPoolMember, err error) {
	obj := new(LoadBalancerPoolMember)
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Health, err = core.UnmarshalString(m, "health")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Port, err = core.UnmarshalInt64(m, "port")
	if err != nil {
		return
	}
	obj.ProvisioningStatus, err = core.UnmarshalString(m, "provisioning_status")
	if err != nil {
		return
	}
	obj.Target, err = UnmarshalLoadBalancerPoolMemberTargetAsProperty(m, "target")
	if err != nil {
		return
	}
	obj.Weight, err = core.UnmarshalInt64(m, "weight")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolMemberSlice unmarshals a slice of LoadBalancerPoolMember instances from the specified list of maps.
func UnmarshalLoadBalancerPoolMemberSlice(s []interface{}) (slice []LoadBalancerPoolMember, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolMember'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolMember(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerPoolMemberAsProperty unmarshals an instance of LoadBalancerPoolMember that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolMemberAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerPoolMember, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolMember'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolMember(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolMemberSliceAsProperty unmarshals a slice of LoadBalancerPoolMember instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolMemberSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolMember, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolMember'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolMemberSlice(vSlice)
	}
	return
}

// LoadBalancerPoolMemberCollection : LoadBalancerPoolMemberCollection struct
type LoadBalancerPoolMemberCollection struct {
	// Collection of members.
	Members []LoadBalancerPoolMember `json:"members" validate:"required"`
}

// UnmarshalLoadBalancerPoolMemberCollection constructs an instance of LoadBalancerPoolMemberCollection from the specified map.
func UnmarshalLoadBalancerPoolMemberCollection(m map[string]interface{}) (result *LoadBalancerPoolMemberCollection, err error) {
	obj := new(LoadBalancerPoolMemberCollection)
	obj.Members, err = UnmarshalLoadBalancerPoolMemberSliceAsProperty(m, "members")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolMemberCollectionSlice unmarshals a slice of LoadBalancerPoolMemberCollection instances from the specified list of maps.
func UnmarshalLoadBalancerPoolMemberCollectionSlice(s []interface{}) (slice []LoadBalancerPoolMemberCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolMemberCollection'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolMemberCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerPoolMemberCollectionAsProperty unmarshals an instance of LoadBalancerPoolMemberCollection that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolMemberCollectionAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerPoolMemberCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolMemberCollection'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolMemberCollection(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolMemberCollectionSliceAsProperty unmarshals a slice of LoadBalancerPoolMemberCollection instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolMemberCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolMemberCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolMemberCollection'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolMemberCollectionSlice(vSlice)
	}
	return
}

// LoadBalancerPoolMemberPrototype : LoadBalancerPoolMemberPrototype struct
type LoadBalancerPoolMemberPrototype struct {
	// The port number of the application running in the server member.
	Port *int64 `json:"port" validate:"required"`

	// The pool member target.
	Target LoadBalancerPoolMemberTargetPrototypeIntf `json:"target" validate:"required"`

	// Weight of the server member. This takes effect only when the load balancing algorithm of its belonging pool is
	// `weighted_round_robin`.
	Weight *int64 `json:"weight,omitempty"`
}

// NewLoadBalancerPoolMemberPrototype : Instantiate LoadBalancerPoolMemberPrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolMemberPrototype(port int64, target LoadBalancerPoolMemberTargetPrototypeIntf) (model *LoadBalancerPoolMemberPrototype, err error) {
	model = &LoadBalancerPoolMemberPrototype{
		Port:   core.Int64Ptr(port),
		Target: target,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolMemberPrototype constructs an instance of LoadBalancerPoolMemberPrototype from the specified map.
func UnmarshalLoadBalancerPoolMemberPrototype(m map[string]interface{}) (result *LoadBalancerPoolMemberPrototype, err error) {
	obj := new(LoadBalancerPoolMemberPrototype)
	obj.Port, err = core.UnmarshalInt64(m, "port")
	if err != nil {
		return
	}
	obj.Target, err = UnmarshalLoadBalancerPoolMemberTargetPrototypeAsProperty(m, "target")
	if err != nil {
		return
	}
	obj.Weight, err = core.UnmarshalInt64(m, "weight")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolMemberPrototypeSlice unmarshals a slice of LoadBalancerPoolMemberPrototype instances from the specified list of maps.
func UnmarshalLoadBalancerPoolMemberPrototypeSlice(s []interface{}) (slice []LoadBalancerPoolMemberPrototype, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolMemberPrototype'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolMemberPrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerPoolMemberPrototypeAsProperty unmarshals an instance of LoadBalancerPoolMemberPrototype that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolMemberPrototypeAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerPoolMemberPrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolMemberPrototype'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolMemberPrototype(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolMemberPrototypeSliceAsProperty unmarshals a slice of LoadBalancerPoolMemberPrototype instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolMemberPrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolMemberPrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolMemberPrototype'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolMemberPrototypeSlice(vSlice)
	}
	return
}

// LoadBalancerPoolMemberReference : LoadBalancerPoolMemberReference struct
type LoadBalancerPoolMemberReference struct {
	// The member's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer pool member.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalLoadBalancerPoolMemberReference constructs an instance of LoadBalancerPoolMemberReference from the specified map.
func UnmarshalLoadBalancerPoolMemberReference(m map[string]interface{}) (result *LoadBalancerPoolMemberReference, err error) {
	obj := new(LoadBalancerPoolMemberReference)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolMemberReferenceSlice unmarshals a slice of LoadBalancerPoolMemberReference instances from the specified list of maps.
func UnmarshalLoadBalancerPoolMemberReferenceSlice(s []interface{}) (slice []LoadBalancerPoolMemberReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolMemberReference'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolMemberReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerPoolMemberReferenceAsProperty unmarshals an instance of LoadBalancerPoolMemberReference that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolMemberReferenceAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerPoolMemberReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolMemberReference'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolMemberReference(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolMemberReferenceSliceAsProperty unmarshals a slice of LoadBalancerPoolMemberReference instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolMemberReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolMemberReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolMemberReference'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolMemberReferenceSlice(vSlice)
	}
	return
}

// LoadBalancerPoolMemberTarget : The pool member target.
// Models which "extend" this model:
// - LoadBalancerPoolMemberTargetByAddress
type LoadBalancerPoolMemberTarget struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`
}

func (*LoadBalancerPoolMemberTarget) isaLoadBalancerPoolMemberTarget() bool {
	return true
}

type LoadBalancerPoolMemberTargetIntf interface {
	isaLoadBalancerPoolMemberTarget() bool
}

// UnmarshalLoadBalancerPoolMemberTarget constructs an instance of LoadBalancerPoolMemberTarget from the specified map.
func UnmarshalLoadBalancerPoolMemberTarget(m map[string]interface{}) (result LoadBalancerPoolMemberTargetIntf, err error) {
	obj := new(LoadBalancerPoolMemberTarget)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolMemberTargetSlice unmarshals a slice of LoadBalancerPoolMemberTarget instances from the specified list of maps.
func UnmarshalLoadBalancerPoolMemberTargetSlice(s []interface{}) (slice []LoadBalancerPoolMemberTargetIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolMemberTarget'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolMemberTarget(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalLoadBalancerPoolMemberTargetAsProperty unmarshals an instance of LoadBalancerPoolMemberTarget that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolMemberTargetAsProperty(m map[string]interface{}, propertyName string) (result LoadBalancerPoolMemberTargetIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolMemberTarget'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolMemberTarget(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolMemberTargetSliceAsProperty unmarshals a slice of LoadBalancerPoolMemberTarget instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolMemberTargetSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolMemberTargetIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolMemberTarget'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolMemberTargetSlice(vSlice)
	}
	return
}

// LoadBalancerPoolMemberTargetPrototype : The pool member target.
// Models which "extend" this model:
// - LoadBalancerPoolMemberTargetPrototypeByAddress
type LoadBalancerPoolMemberTargetPrototype struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`
}

func (*LoadBalancerPoolMemberTargetPrototype) isaLoadBalancerPoolMemberTargetPrototype() bool {
	return true
}

type LoadBalancerPoolMemberTargetPrototypeIntf interface {
	isaLoadBalancerPoolMemberTargetPrototype() bool
}

// UnmarshalLoadBalancerPoolMemberTargetPrototype constructs an instance of LoadBalancerPoolMemberTargetPrototype from the specified map.
func UnmarshalLoadBalancerPoolMemberTargetPrototype(m map[string]interface{}) (result LoadBalancerPoolMemberTargetPrototypeIntf, err error) {
	obj := new(LoadBalancerPoolMemberTargetPrototype)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolMemberTargetPrototypeSlice unmarshals a slice of LoadBalancerPoolMemberTargetPrototype instances from the specified list of maps.
func UnmarshalLoadBalancerPoolMemberTargetPrototypeSlice(s []interface{}) (slice []LoadBalancerPoolMemberTargetPrototypeIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolMemberTargetPrototype'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolMemberTargetPrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalLoadBalancerPoolMemberTargetPrototypeAsProperty unmarshals an instance of LoadBalancerPoolMemberTargetPrototype that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolMemberTargetPrototypeAsProperty(m map[string]interface{}, propertyName string) (result LoadBalancerPoolMemberTargetPrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolMemberTargetPrototype'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolMemberTargetPrototype(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolMemberTargetPrototypeSliceAsProperty unmarshals a slice of LoadBalancerPoolMemberTargetPrototype instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolMemberTargetPrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolMemberTargetPrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolMemberTargetPrototype'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolMemberTargetPrototypeSlice(vSlice)
	}
	return
}

// LoadBalancerPoolPrototype : LoadBalancerPoolPrototype struct
type LoadBalancerPoolPrototype struct {
	// The load balancing algorithm.
	Algorithm *string `json:"algorithm" validate:"required"`

	// The health monitor of this pool.
	HealthMonitor *LoadBalancerPoolHealthMonitorPrototype `json:"health_monitor" validate:"required"`

	// The members for this load balancer pool. For load balancers in the `network` family, the same `port` and `target`
	// tuple cannot be shared by a member of any other load balancer.
	Members []LoadBalancerPoolMemberPrototype `json:"members,omitempty"`

	// The user-defined name for this load balancer pool. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The pool protocol.
	Protocol *string `json:"protocol" validate:"required"`

	// The session persistence of this pool.
	SessionPersistence *LoadBalancerPoolSessionPersistencePrototype `json:"session_persistence,omitempty"`
}

// Constants associated with the LoadBalancerPoolPrototype.Algorithm property.
// The load balancing algorithm.
const (
	LoadBalancerPoolPrototype_Algorithm_LeastConnections   = "least_connections"
	LoadBalancerPoolPrototype_Algorithm_RoundRobin         = "round_robin"
	LoadBalancerPoolPrototype_Algorithm_WeightedRoundRobin = "weighted_round_robin"
)

// Constants associated with the LoadBalancerPoolPrototype.Protocol property.
// The pool protocol.
const (
	LoadBalancerPoolPrototype_Protocol_Http = "http"
	LoadBalancerPoolPrototype_Protocol_Tcp  = "tcp"
)

// NewLoadBalancerPoolPrototype : Instantiate LoadBalancerPoolPrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolPrototype(algorithm string, healthMonitor *LoadBalancerPoolHealthMonitorPrototype, protocol string) (model *LoadBalancerPoolPrototype, err error) {
	model = &LoadBalancerPoolPrototype{
		Algorithm:     core.StringPtr(algorithm),
		HealthMonitor: healthMonitor,
		Protocol:      core.StringPtr(protocol),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolPrototype constructs an instance of LoadBalancerPoolPrototype from the specified map.
func UnmarshalLoadBalancerPoolPrototype(m map[string]interface{}) (result *LoadBalancerPoolPrototype, err error) {
	obj := new(LoadBalancerPoolPrototype)
	obj.Algorithm, err = core.UnmarshalString(m, "algorithm")
	if err != nil {
		return
	}
	obj.HealthMonitor, err = UnmarshalLoadBalancerPoolHealthMonitorPrototypeAsProperty(m, "health_monitor")
	if err != nil {
		return
	}
	obj.Members, err = UnmarshalLoadBalancerPoolMemberPrototypeSliceAsProperty(m, "members")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.SessionPersistence, err = UnmarshalLoadBalancerPoolSessionPersistencePrototypeAsProperty(m, "session_persistence")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolPrototypeSlice unmarshals a slice of LoadBalancerPoolPrototype instances from the specified list of maps.
func UnmarshalLoadBalancerPoolPrototypeSlice(s []interface{}) (slice []LoadBalancerPoolPrototype, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolPrototype'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolPrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerPoolPrototypeAsProperty unmarshals an instance of LoadBalancerPoolPrototype that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolPrototypeAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerPoolPrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolPrototype'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolPrototype(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolPrototypeSliceAsProperty unmarshals a slice of LoadBalancerPoolPrototype instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolPrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolPrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolPrototype'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolPrototypeSlice(vSlice)
	}
	return
}

// LoadBalancerPoolReference : LoadBalancerPoolReference struct
type LoadBalancerPoolReference struct {
	// The pool's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer pool.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this load balancer pool.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalLoadBalancerPoolReference constructs an instance of LoadBalancerPoolReference from the specified map.
func UnmarshalLoadBalancerPoolReference(m map[string]interface{}) (result *LoadBalancerPoolReference, err error) {
	obj := new(LoadBalancerPoolReference)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolReferenceSlice unmarshals a slice of LoadBalancerPoolReference instances from the specified list of maps.
func UnmarshalLoadBalancerPoolReferenceSlice(s []interface{}) (slice []LoadBalancerPoolReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolReference'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerPoolReferenceAsProperty unmarshals an instance of LoadBalancerPoolReference that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolReferenceAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerPoolReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolReference'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolReference(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolReferenceSliceAsProperty unmarshals a slice of LoadBalancerPoolReference instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolReference'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolReferenceSlice(vSlice)
	}
	return
}

// LoadBalancerPoolSessionPersistence : LoadBalancerPoolSessionPersistence struct
type LoadBalancerPoolSessionPersistence struct {
	// The session persistence type.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the LoadBalancerPoolSessionPersistence.Type property.
// The session persistence type.
const (
	LoadBalancerPoolSessionPersistence_Type_SourceIp = "source_ip"
)

// UnmarshalLoadBalancerPoolSessionPersistence constructs an instance of LoadBalancerPoolSessionPersistence from the specified map.
func UnmarshalLoadBalancerPoolSessionPersistence(m map[string]interface{}) (result *LoadBalancerPoolSessionPersistence, err error) {
	obj := new(LoadBalancerPoolSessionPersistence)
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolSessionPersistenceSlice unmarshals a slice of LoadBalancerPoolSessionPersistence instances from the specified list of maps.
func UnmarshalLoadBalancerPoolSessionPersistenceSlice(s []interface{}) (slice []LoadBalancerPoolSessionPersistence, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolSessionPersistence'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolSessionPersistence(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerPoolSessionPersistenceAsProperty unmarshals an instance of LoadBalancerPoolSessionPersistence that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolSessionPersistenceAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerPoolSessionPersistence, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolSessionPersistence'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolSessionPersistence(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolSessionPersistenceSliceAsProperty unmarshals a slice of LoadBalancerPoolSessionPersistence instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolSessionPersistenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolSessionPersistence, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolSessionPersistence'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolSessionPersistenceSlice(vSlice)
	}
	return
}

// LoadBalancerPoolSessionPersistencePatch : LoadBalancerPoolSessionPersistencePatch struct
type LoadBalancerPoolSessionPersistencePatch struct {
	// The session persistence type.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the LoadBalancerPoolSessionPersistencePatch.Type property.
// The session persistence type.
const (
	LoadBalancerPoolSessionPersistencePatch_Type_SourceIp = "source_ip"
)

// NewLoadBalancerPoolSessionPersistencePatch : Instantiate LoadBalancerPoolSessionPersistencePatch (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolSessionPersistencePatch(typeVar string) (model *LoadBalancerPoolSessionPersistencePatch, err error) {
	model = &LoadBalancerPoolSessionPersistencePatch{
		Type: core.StringPtr(typeVar),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolSessionPersistencePatch constructs an instance of LoadBalancerPoolSessionPersistencePatch from the specified map.
func UnmarshalLoadBalancerPoolSessionPersistencePatch(m map[string]interface{}) (result *LoadBalancerPoolSessionPersistencePatch, err error) {
	obj := new(LoadBalancerPoolSessionPersistencePatch)
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolSessionPersistencePatchSlice unmarshals a slice of LoadBalancerPoolSessionPersistencePatch instances from the specified list of maps.
func UnmarshalLoadBalancerPoolSessionPersistencePatchSlice(s []interface{}) (slice []LoadBalancerPoolSessionPersistencePatch, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolSessionPersistencePatch'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolSessionPersistencePatch(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerPoolSessionPersistencePatchAsProperty unmarshals an instance of LoadBalancerPoolSessionPersistencePatch that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolSessionPersistencePatchAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerPoolSessionPersistencePatch, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolSessionPersistencePatch'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolSessionPersistencePatch(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolSessionPersistencePatchSliceAsProperty unmarshals a slice of LoadBalancerPoolSessionPersistencePatch instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolSessionPersistencePatchSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolSessionPersistencePatch, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolSessionPersistencePatch'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolSessionPersistencePatchSlice(vSlice)
	}
	return
}

// LoadBalancerPoolSessionPersistencePrototype : LoadBalancerPoolSessionPersistencePrototype struct
type LoadBalancerPoolSessionPersistencePrototype struct {
	// The session persistence type.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the LoadBalancerPoolSessionPersistencePrototype.Type property.
// The session persistence type.
const (
	LoadBalancerPoolSessionPersistencePrototype_Type_SourceIp = "source_ip"
)

// NewLoadBalancerPoolSessionPersistencePrototype : Instantiate LoadBalancerPoolSessionPersistencePrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolSessionPersistencePrototype(typeVar string) (model *LoadBalancerPoolSessionPersistencePrototype, err error) {
	model = &LoadBalancerPoolSessionPersistencePrototype{
		Type: core.StringPtr(typeVar),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolSessionPersistencePrototype constructs an instance of LoadBalancerPoolSessionPersistencePrototype from the specified map.
func UnmarshalLoadBalancerPoolSessionPersistencePrototype(m map[string]interface{}) (result *LoadBalancerPoolSessionPersistencePrototype, err error) {
	obj := new(LoadBalancerPoolSessionPersistencePrototype)
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolSessionPersistencePrototypeSlice unmarshals a slice of LoadBalancerPoolSessionPersistencePrototype instances from the specified list of maps.
func UnmarshalLoadBalancerPoolSessionPersistencePrototypeSlice(s []interface{}) (slice []LoadBalancerPoolSessionPersistencePrototype, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolSessionPersistencePrototype'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolSessionPersistencePrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerPoolSessionPersistencePrototypeAsProperty unmarshals an instance of LoadBalancerPoolSessionPersistencePrototype that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolSessionPersistencePrototypeAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerPoolSessionPersistencePrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolSessionPersistencePrototype'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolSessionPersistencePrototype(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolSessionPersistencePrototypeSliceAsProperty unmarshals a slice of LoadBalancerPoolSessionPersistencePrototype instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolSessionPersistencePrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolSessionPersistencePrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolSessionPersistencePrototype'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolSessionPersistencePrototypeSlice(vSlice)
	}
	return
}

// LoadBalancerStatistics : LoadBalancerStatistics struct
type LoadBalancerStatistics struct {
	// Number of active connections of this load balancer.
	ActiveConnections *int64 `json:"active_connections" validate:"required"`

	// Current connection rate (connections per second) of this load balancer.
	ConnectionRate *float32 `json:"connection_rate" validate:"required"`

	// Total number of data processed (bytes) of this load balancer within current calendar month.
	DataProcessedThisMonth *int64 `json:"data_processed_this_month" validate:"required"`

	// Current throughput (Mbps) of this load balancer.
	Throughput *float32 `json:"throughput" validate:"required"`
}

// UnmarshalLoadBalancerStatistics constructs an instance of LoadBalancerStatistics from the specified map.
func UnmarshalLoadBalancerStatistics(m map[string]interface{}) (result *LoadBalancerStatistics, err error) {
	obj := new(LoadBalancerStatistics)
	obj.ActiveConnections, err = core.UnmarshalInt64(m, "active_connections")
	if err != nil {
		return
	}
	obj.ConnectionRate, err = core.UnmarshalFloat32(m, "connection_rate")
	if err != nil {
		return
	}
	obj.DataProcessedThisMonth, err = core.UnmarshalInt64(m, "data_processed_this_month")
	if err != nil {
		return
	}
	obj.Throughput, err = core.UnmarshalFloat32(m, "throughput")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerStatisticsSlice unmarshals a slice of LoadBalancerStatistics instances from the specified list of maps.
func UnmarshalLoadBalancerStatisticsSlice(s []interface{}) (slice []LoadBalancerStatistics, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerStatistics'")
			return
		}
		obj, e := UnmarshalLoadBalancerStatistics(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerStatisticsAsProperty unmarshals an instance of LoadBalancerStatistics that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerStatisticsAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerStatistics, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerStatistics'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerStatistics(objMap)
	}
	return
}

// UnmarshalLoadBalancerStatisticsSliceAsProperty unmarshals a slice of LoadBalancerStatistics instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerStatisticsSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerStatistics, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerStatistics'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerStatisticsSlice(vSlice)
	}
	return
}

// NetworkACL : NetworkACL struct
type NetworkACL struct {
	// The date and time that the network ACL was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this network ACL.
	Crn *string `json:"crn" validate:"required"`

	// The URL for this network ACL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network ACL.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this network ACL.
	Name *string `json:"name" validate:"required"`

	// The resource group for this Network ACL.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The ordered rules for this network ACL. If no rules exist, all traffic will be denied.
	Rules []NetworkACLRuleItemIntf `json:"rules" validate:"required"`

	// The subnets to which this network ACL is attached.
	Subnets []SubnetReference `json:"subnets" validate:"required"`

	// The VPC this network ACL is a part of.
	Vpc *VPCReference `json:"vpc" validate:"required"`
}

// UnmarshalNetworkACL constructs an instance of NetworkACL from the specified map.
func UnmarshalNetworkACL(m map[string]interface{}) (result *NetworkACL, err error) {
	obj := new(NetworkACL)
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupReferenceAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Rules, err = UnmarshalNetworkACLRuleItemSliceAsProperty(m, "rules")
	if err != nil {
		return
	}
	obj.Subnets, err = UnmarshalSubnetReferenceSliceAsProperty(m, "subnets")
	if err != nil {
		return
	}
	obj.Vpc, err = UnmarshalVPCReferenceAsProperty(m, "vpc")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLSlice unmarshals a slice of NetworkACL instances from the specified list of maps.
func UnmarshalNetworkACLSlice(s []interface{}) (slice []NetworkACL, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACL'")
			return
		}
		obj, e := UnmarshalNetworkACL(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLAsProperty unmarshals an instance of NetworkACL that is stored as a property
// within the specified map.
func UnmarshalNetworkACLAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACL, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACL'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACL(objMap)
	}
	return
}

// UnmarshalNetworkACLSliceAsProperty unmarshals a slice of NetworkACL instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACL, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACL'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLSlice(vSlice)
	}
	return
}

// NetworkACLCollection : NetworkACLCollection struct
type NetworkACLCollection struct {
	// A reference to the first page of resources.
	First *NetworkACLCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// Collection of network ACLs.
	NetworkAcls []NetworkACL `json:"network_acls" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *NetworkACLCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalNetworkACLCollection constructs an instance of NetworkACLCollection from the specified map.
func UnmarshalNetworkACLCollection(m map[string]interface{}) (result *NetworkACLCollection, err error) {
	obj := new(NetworkACLCollection)
	obj.First, err = UnmarshalNetworkACLCollectionFirstAsProperty(m, "first")
	if err != nil {
		return
	}
	obj.Limit, err = core.UnmarshalInt64(m, "limit")
	if err != nil {
		return
	}
	obj.NetworkAcls, err = UnmarshalNetworkACLSliceAsProperty(m, "network_acls")
	if err != nil {
		return
	}
	obj.Next, err = UnmarshalNetworkACLCollectionNextAsProperty(m, "next")
	if err != nil {
		return
	}
	obj.TotalCount, err = core.UnmarshalInt64(m, "total_count")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLCollectionSlice unmarshals a slice of NetworkACLCollection instances from the specified list of maps.
func UnmarshalNetworkACLCollectionSlice(s []interface{}) (slice []NetworkACLCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLCollection'")
			return
		}
		obj, e := UnmarshalNetworkACLCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLCollectionAsProperty unmarshals an instance of NetworkACLCollection that is stored as a property
// within the specified map.
func UnmarshalNetworkACLCollectionAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLCollection'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLCollection(objMap)
	}
	return
}

// UnmarshalNetworkACLCollectionSliceAsProperty unmarshals a slice of NetworkACLCollection instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLCollection'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLCollectionSlice(vSlice)
	}
	return
}

// NetworkACLCollectionFirst : A reference to the first page of resources.
type NetworkACLCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalNetworkACLCollectionFirst constructs an instance of NetworkACLCollectionFirst from the specified map.
func UnmarshalNetworkACLCollectionFirst(m map[string]interface{}) (result *NetworkACLCollectionFirst, err error) {
	obj := new(NetworkACLCollectionFirst)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLCollectionFirstSlice unmarshals a slice of NetworkACLCollectionFirst instances from the specified list of maps.
func UnmarshalNetworkACLCollectionFirstSlice(s []interface{}) (slice []NetworkACLCollectionFirst, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLCollectionFirst'")
			return
		}
		obj, e := UnmarshalNetworkACLCollectionFirst(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLCollectionFirstAsProperty unmarshals an instance of NetworkACLCollectionFirst that is stored as a property
// within the specified map.
func UnmarshalNetworkACLCollectionFirstAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLCollectionFirst'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLCollectionFirst(objMap)
	}
	return
}

// UnmarshalNetworkACLCollectionFirstSliceAsProperty unmarshals a slice of NetworkACLCollectionFirst instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLCollectionFirstSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLCollectionFirst'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLCollectionFirstSlice(vSlice)
	}
	return
}

// NetworkACLCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type NetworkACLCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalNetworkACLCollectionNext constructs an instance of NetworkACLCollectionNext from the specified map.
func UnmarshalNetworkACLCollectionNext(m map[string]interface{}) (result *NetworkACLCollectionNext, err error) {
	obj := new(NetworkACLCollectionNext)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLCollectionNextSlice unmarshals a slice of NetworkACLCollectionNext instances from the specified list of maps.
func UnmarshalNetworkACLCollectionNextSlice(s []interface{}) (slice []NetworkACLCollectionNext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLCollectionNext'")
			return
		}
		obj, e := UnmarshalNetworkACLCollectionNext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLCollectionNextAsProperty unmarshals an instance of NetworkACLCollectionNext that is stored as a property
// within the specified map.
func UnmarshalNetworkACLCollectionNextAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLCollectionNext'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLCollectionNext(objMap)
	}
	return
}

// UnmarshalNetworkACLCollectionNextSliceAsProperty unmarshals a slice of NetworkACLCollectionNext instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLCollectionNextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLCollectionNext'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLCollectionNextSlice(vSlice)
	}
	return
}

// NetworkACLIdentity : Identifies a network ACL by a unique property.
// Models which "extend" this model:
// - NetworkACLIdentityByID
// - NetworkACLIdentityByCRN
// - NetworkACLIdentityByHref
type NetworkACLIdentity struct {
	// The unique identifier for this network ACL.
	ID *string `json:"id,omitempty"`

	// The CRN for this network ACL.
	Crn *string `json:"crn,omitempty"`

	// The URL for this network ACL.
	Href *string `json:"href,omitempty"`
}

func (*NetworkACLIdentity) isaNetworkACLIdentity() bool {
	return true
}

type NetworkACLIdentityIntf interface {
	isaNetworkACLIdentity() bool
}

// UnmarshalNetworkACLIdentity constructs an instance of NetworkACLIdentity from the specified map.
func UnmarshalNetworkACLIdentity(m map[string]interface{}) (result NetworkACLIdentityIntf, err error) {
	obj := new(NetworkACLIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLIdentitySlice unmarshals a slice of NetworkACLIdentity instances from the specified list of maps.
func UnmarshalNetworkACLIdentitySlice(s []interface{}) (slice []NetworkACLIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLIdentity'")
			return
		}
		obj, e := UnmarshalNetworkACLIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalNetworkACLIdentityAsProperty unmarshals an instance of NetworkACLIdentity that is stored as a property
// within the specified map.
func UnmarshalNetworkACLIdentityAsProperty(m map[string]interface{}, propertyName string) (result NetworkACLIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLIdentity'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLIdentity(objMap)
	}
	return
}

// UnmarshalNetworkACLIdentitySliceAsProperty unmarshals a slice of NetworkACLIdentity instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLIdentitySlice(vSlice)
	}
	return
}

// NetworkACLPrototype : NetworkACLPrototype struct
// Models which "extend" this model:
// - NetworkACLPrototypeNetworkACLByRules
// - NetworkACLPrototypeNetworkACLBySourceNetworkACL
type NetworkACLPrototype struct {
	// The user-defined name for this network ACL. Names must be unique within the VPC the Network ACL resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The VPC this network ACL is to be a part of.
	Vpc VPCIdentityIntf `json:"vpc" validate:"required"`

	// Array of prototype objects for rules to create along with this network ACL. If unspecified, no rules will be
	// created, resulting in all traffic being denied.
	Rules []NetworkACLRulePrototypeNetworkACLContextIntf `json:"rules,omitempty"`

	// Network ACL to copy rules from.
	SourceNetworkAcl NetworkACLIdentityIntf `json:"source_network_acl,omitempty"`
}

func (*NetworkACLPrototype) isaNetworkACLPrototype() bool {
	return true
}

type NetworkACLPrototypeIntf interface {
	isaNetworkACLPrototype() bool
}

// UnmarshalNetworkACLPrototype constructs an instance of NetworkACLPrototype from the specified map.
func UnmarshalNetworkACLPrototype(m map[string]interface{}) (result NetworkACLPrototypeIntf, err error) {
	obj := new(NetworkACLPrototype)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupIdentityAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Vpc, err = UnmarshalVPCIdentityAsProperty(m, "vpc")
	if err != nil {
		return
	}
	obj.Rules, err = UnmarshalNetworkACLRulePrototypeNetworkACLContextSliceAsProperty(m, "rules")
	if err != nil {
		return
	}
	obj.SourceNetworkAcl, err = UnmarshalNetworkACLIdentityAsProperty(m, "source_network_acl")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLPrototypeSlice unmarshals a slice of NetworkACLPrototype instances from the specified list of maps.
func UnmarshalNetworkACLPrototypeSlice(s []interface{}) (slice []NetworkACLPrototypeIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLPrototype'")
			return
		}
		obj, e := UnmarshalNetworkACLPrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalNetworkACLPrototypeAsProperty unmarshals an instance of NetworkACLPrototype that is stored as a property
// within the specified map.
func UnmarshalNetworkACLPrototypeAsProperty(m map[string]interface{}, propertyName string) (result NetworkACLPrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLPrototype'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLPrototype(objMap)
	}
	return
}

// UnmarshalNetworkACLPrototypeSliceAsProperty unmarshals a slice of NetworkACLPrototype instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLPrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLPrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLPrototype'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLPrototypeSlice(vSlice)
	}
	return
}

// NetworkACLReference : NetworkACLReference struct
type NetworkACLReference struct {
	// The CRN for this network ACL.
	Crn *string `json:"crn" validate:"required"`

	// The URL for this network ACL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network ACL.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this network ACL.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalNetworkACLReference constructs an instance of NetworkACLReference from the specified map.
func UnmarshalNetworkACLReference(m map[string]interface{}) (result *NetworkACLReference, err error) {
	obj := new(NetworkACLReference)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLReferenceSlice unmarshals a slice of NetworkACLReference instances from the specified list of maps.
func UnmarshalNetworkACLReferenceSlice(s []interface{}) (slice []NetworkACLReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLReference'")
			return
		}
		obj, e := UnmarshalNetworkACLReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLReferenceAsProperty unmarshals an instance of NetworkACLReference that is stored as a property
// within the specified map.
func UnmarshalNetworkACLReferenceAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLReference'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLReference(objMap)
	}
	return
}

// UnmarshalNetworkACLReferenceSliceAsProperty unmarshals a slice of NetworkACLReference instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLReference'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLReferenceSlice(vSlice)
	}
	return
}

// NetworkACLRule : NetworkACLRule struct
// Models which "extend" this model:
// - NetworkACLRuleProtocolTCPUDP
// - NetworkACLRuleProtocolICMP
// - NetworkACLRuleProtocolAll
type NetworkACLRule struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IpVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`

	// The ICMP traffic code to allow. If unspecified, all codes are allowed. This can only be specified if type is also
	// specified.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow. If unspecified, all types are allowed by this rule.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRule.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRule_Action_Allow = "allow"
	NetworkACLRule_Action_Deny  = "deny"
)

// Constants associated with the NetworkACLRule.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRule_Direction_Inbound  = "inbound"
	NetworkACLRule_Direction_Outbound = "outbound"
)

// Constants associated with the NetworkACLRule.IpVersion property.
// The IP version for this rule.
const (
	NetworkACLRule_IpVersion_Ipv4 = "ipv4"
	NetworkACLRule_IpVersion_Ipv6 = "ipv6"
)

// Constants associated with the NetworkACLRule.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRule_Protocol_All  = "all"
	NetworkACLRule_Protocol_Icmp = "icmp"
	NetworkACLRule_Protocol_Tcp  = "tcp"
	NetworkACLRule_Protocol_Udp  = "udp"
)

func (*NetworkACLRule) isaNetworkACLRule() bool {
	return true
}

type NetworkACLRuleIntf interface {
	isaNetworkACLRule() bool
}

// UnmarshalNetworkACLRule constructs an instance of NetworkACLRule from the specified map.
func UnmarshalNetworkACLRule(m map[string]interface{}) (result NetworkACLRuleIntf, err error) {
	discValue, err := core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	if discValue == nil {
		err = fmt.Errorf("discriminator property 'protocol' not found in JSON object")
		return
	}
	if *discValue == "all" {
		result, err = UnmarshalNetworkACLRuleProtocolAll(m)
	} else if *discValue == "icmp" {
		result, err = UnmarshalNetworkACLRuleProtocolICMP(m)
	} else if *discValue == "tcp" {
		result, err = UnmarshalNetworkACLRuleProtocolTCPUDP(m)
	} else if *discValue == "udp" {
		result, err = UnmarshalNetworkACLRuleProtocolTCPUDP(m)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'protocol': %s", *discValue)
	}
	return
}

// UnmarshalNetworkACLRuleSlice unmarshals a slice of NetworkACLRule instances from the specified list of maps.
func UnmarshalNetworkACLRuleSlice(s []interface{}) (slice []NetworkACLRuleIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRule'")
			return
		}
		obj, e := UnmarshalNetworkACLRule(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalNetworkACLRuleAsProperty unmarshals an instance of NetworkACLRule that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleAsProperty(m map[string]interface{}, propertyName string) (result NetworkACLRuleIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRule'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRule(objMap)
	}
	return
}

// UnmarshalNetworkACLRuleSliceAsProperty unmarshals a slice of NetworkACLRule instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRuleIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRule'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRuleSlice(vSlice)
	}
	return
}

// NetworkACLRuleCollection : NetworkACLRuleCollection struct
type NetworkACLRuleCollection struct {
	// A reference to the first page of resources.
	First *NetworkACLRuleCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *NetworkACLRuleCollectionNext `json:"next,omitempty"`

	// Ordered collection of rules.
	Rules []NetworkACLRuleItemIntf `json:"rules" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalNetworkACLRuleCollection constructs an instance of NetworkACLRuleCollection from the specified map.
func UnmarshalNetworkACLRuleCollection(m map[string]interface{}) (result *NetworkACLRuleCollection, err error) {
	obj := new(NetworkACLRuleCollection)
	obj.First, err = UnmarshalNetworkACLRuleCollectionFirstAsProperty(m, "first")
	if err != nil {
		return
	}
	obj.Limit, err = core.UnmarshalInt64(m, "limit")
	if err != nil {
		return
	}
	obj.Next, err = UnmarshalNetworkACLRuleCollectionNextAsProperty(m, "next")
	if err != nil {
		return
	}
	obj.Rules, err = UnmarshalNetworkACLRuleItemSliceAsProperty(m, "rules")
	if err != nil {
		return
	}
	obj.TotalCount, err = core.UnmarshalInt64(m, "total_count")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRuleCollectionSlice unmarshals a slice of NetworkACLRuleCollection instances from the specified list of maps.
func UnmarshalNetworkACLRuleCollectionSlice(s []interface{}) (slice []NetworkACLRuleCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRuleCollection'")
			return
		}
		obj, e := UnmarshalNetworkACLRuleCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRuleCollectionAsProperty unmarshals an instance of NetworkACLRuleCollection that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleCollectionAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRuleCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRuleCollection'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRuleCollection(objMap)
	}
	return
}

// UnmarshalNetworkACLRuleCollectionSliceAsProperty unmarshals a slice of NetworkACLRuleCollection instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRuleCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRuleCollection'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRuleCollectionSlice(vSlice)
	}
	return
}

// NetworkACLRuleCollectionFirst : A reference to the first page of resources.
type NetworkACLRuleCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalNetworkACLRuleCollectionFirst constructs an instance of NetworkACLRuleCollectionFirst from the specified map.
func UnmarshalNetworkACLRuleCollectionFirst(m map[string]interface{}) (result *NetworkACLRuleCollectionFirst, err error) {
	obj := new(NetworkACLRuleCollectionFirst)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRuleCollectionFirstSlice unmarshals a slice of NetworkACLRuleCollectionFirst instances from the specified list of maps.
func UnmarshalNetworkACLRuleCollectionFirstSlice(s []interface{}) (slice []NetworkACLRuleCollectionFirst, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRuleCollectionFirst'")
			return
		}
		obj, e := UnmarshalNetworkACLRuleCollectionFirst(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRuleCollectionFirstAsProperty unmarshals an instance of NetworkACLRuleCollectionFirst that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleCollectionFirstAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRuleCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRuleCollectionFirst'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRuleCollectionFirst(objMap)
	}
	return
}

// UnmarshalNetworkACLRuleCollectionFirstSliceAsProperty unmarshals a slice of NetworkACLRuleCollectionFirst instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleCollectionFirstSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRuleCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRuleCollectionFirst'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRuleCollectionFirstSlice(vSlice)
	}
	return
}

// NetworkACLRuleCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type NetworkACLRuleCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalNetworkACLRuleCollectionNext constructs an instance of NetworkACLRuleCollectionNext from the specified map.
func UnmarshalNetworkACLRuleCollectionNext(m map[string]interface{}) (result *NetworkACLRuleCollectionNext, err error) {
	obj := new(NetworkACLRuleCollectionNext)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRuleCollectionNextSlice unmarshals a slice of NetworkACLRuleCollectionNext instances from the specified list of maps.
func UnmarshalNetworkACLRuleCollectionNextSlice(s []interface{}) (slice []NetworkACLRuleCollectionNext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRuleCollectionNext'")
			return
		}
		obj, e := UnmarshalNetworkACLRuleCollectionNext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRuleCollectionNextAsProperty unmarshals an instance of NetworkACLRuleCollectionNext that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleCollectionNextAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRuleCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRuleCollectionNext'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRuleCollectionNext(objMap)
	}
	return
}

// UnmarshalNetworkACLRuleCollectionNextSliceAsProperty unmarshals a slice of NetworkACLRuleCollectionNext instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleCollectionNextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRuleCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRuleCollectionNext'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRuleCollectionNextSlice(vSlice)
	}
	return
}

// NetworkACLRuleItem : NetworkACLRuleItem struct
// Models which "extend" this model:
// - NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP
// - NetworkACLRuleItemNetworkACLRuleProtocolICMP
// - NetworkACLRuleItemNetworkACLRuleProtocolAll
type NetworkACLRuleItem struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. In a rule collection, this always
	// refers to the next item in the collection. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IpVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`

	// The ICMP traffic code to allow. If unspecified, all codes are allowed. This can only be specified if type is also
	// specified.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow. If unspecified, all types are allowed by this rule.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRuleItem.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRuleItem_Action_Allow = "allow"
	NetworkACLRuleItem_Action_Deny  = "deny"
)

// Constants associated with the NetworkACLRuleItem.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRuleItem_Direction_Inbound  = "inbound"
	NetworkACLRuleItem_Direction_Outbound = "outbound"
)

// Constants associated with the NetworkACLRuleItem.IpVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleItem_IpVersion_Ipv4 = "ipv4"
	NetworkACLRuleItem_IpVersion_Ipv6 = "ipv6"
)

// Constants associated with the NetworkACLRuleItem.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleItem_Protocol_All  = "all"
	NetworkACLRuleItem_Protocol_Icmp = "icmp"
	NetworkACLRuleItem_Protocol_Tcp  = "tcp"
	NetworkACLRuleItem_Protocol_Udp  = "udp"
)

func (*NetworkACLRuleItem) isaNetworkACLRuleItem() bool {
	return true
}

type NetworkACLRuleItemIntf interface {
	isaNetworkACLRuleItem() bool
}

// UnmarshalNetworkACLRuleItem constructs an instance of NetworkACLRuleItem from the specified map.
func UnmarshalNetworkACLRuleItem(m map[string]interface{}) (result NetworkACLRuleItemIntf, err error) {
	discValue, err := core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	if discValue == nil {
		err = fmt.Errorf("discriminator property 'protocol' not found in JSON object")
		return
	}
	if *discValue == "all" {
		result, err = UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolAll(m)
	} else if *discValue == "icmp" {
		result, err = UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolICMP(m)
	} else if *discValue == "tcp" {
		result, err = UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTCPUDP(m)
	} else if *discValue == "udp" {
		result, err = UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTCPUDP(m)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'protocol': %s", *discValue)
	}
	return
}

// UnmarshalNetworkACLRuleItemSlice unmarshals a slice of NetworkACLRuleItem instances from the specified list of maps.
func UnmarshalNetworkACLRuleItemSlice(s []interface{}) (slice []NetworkACLRuleItemIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRuleItem'")
			return
		}
		obj, e := UnmarshalNetworkACLRuleItem(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalNetworkACLRuleItemAsProperty unmarshals an instance of NetworkACLRuleItem that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleItemAsProperty(m map[string]interface{}, propertyName string) (result NetworkACLRuleItemIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRuleItem'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRuleItem(objMap)
	}
	return
}

// UnmarshalNetworkACLRuleItemSliceAsProperty unmarshals a slice of NetworkACLRuleItem instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleItemSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRuleItemIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRuleItem'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRuleItemSlice(vSlice)
	}
	return
}

// NetworkACLRulePatchBefore : The rule to move this rule immediately before. Specify `null` to move this rule after all existing rules.
// Models which "extend" this model:
// - NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID
// - NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref
type NetworkACLRulePatchBefore struct {
	// The unique identifier for this rule.
	ID *string `json:"id,omitempty"`

	// The URL for this rule.
	Href *string `json:"href,omitempty"`
}

func (*NetworkACLRulePatchBefore) isaNetworkACLRulePatchBefore() bool {
	return true
}

type NetworkACLRulePatchBeforeIntf interface {
	isaNetworkACLRulePatchBefore() bool
}

// UnmarshalNetworkACLRulePatchBefore constructs an instance of NetworkACLRulePatchBefore from the specified map.
func UnmarshalNetworkACLRulePatchBefore(m map[string]interface{}) (result NetworkACLRulePatchBeforeIntf, err error) {
	obj := new(NetworkACLRulePatchBefore)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRulePatchBeforeSlice unmarshals a slice of NetworkACLRulePatchBefore instances from the specified list of maps.
func UnmarshalNetworkACLRulePatchBeforeSlice(s []interface{}) (slice []NetworkACLRulePatchBeforeIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRulePatchBefore'")
			return
		}
		obj, e := UnmarshalNetworkACLRulePatchBefore(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalNetworkACLRulePatchBeforeAsProperty unmarshals an instance of NetworkACLRulePatchBefore that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePatchBeforeAsProperty(m map[string]interface{}, propertyName string) (result NetworkACLRulePatchBeforeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRulePatchBefore'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRulePatchBefore(objMap)
	}
	return
}

// UnmarshalNetworkACLRulePatchBeforeSliceAsProperty unmarshals a slice of NetworkACLRulePatchBefore instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePatchBeforeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRulePatchBeforeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRulePatchBefore'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRulePatchBeforeSlice(vSlice)
	}
	return
}

// NetworkACLRulePrototype : NetworkACLRulePrototype struct
// Models which "extend" this model:
// - NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP
// - NetworkACLRulePrototypeNetworkACLRuleProtocolICMP
// - NetworkACLRulePrototypeNetworkACLRuleProtocolAll
type NetworkACLRulePrototype struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule to insert this rule immediately before. If omitted, this rule will be
	// inserted after all existing rules.
	Before NetworkACLRulePrototypeBeforeIntf `json:"before,omitempty"`

	// The destination IP address or CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source IP address or CIDR block.  The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at,omitempty"`

	// The URL for this rule.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this rule.
	ID *string `json:"id,omitempty"`

	// The IP version for this rule.
	IpVersion *string `json:"ip_version,omitempty"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`

	// The ICMP traffic code to allow. If unspecified, all codes are allowed. This can only be specified if type is also
	// specified.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow. If unspecified, all types are allowed by this rule.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRulePrototype.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRulePrototype_Action_Allow = "allow"
	NetworkACLRulePrototype_Action_Deny  = "deny"
)

// Constants associated with the NetworkACLRulePrototype.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRulePrototype_Direction_Inbound  = "inbound"
	NetworkACLRulePrototype_Direction_Outbound = "outbound"
)

// Constants associated with the NetworkACLRulePrototype.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototype_Protocol_All  = "all"
	NetworkACLRulePrototype_Protocol_Icmp = "icmp"
	NetworkACLRulePrototype_Protocol_Tcp  = "tcp"
	NetworkACLRulePrototype_Protocol_Udp  = "udp"
)

// Constants associated with the NetworkACLRulePrototype.IpVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototype_IpVersion_Ipv4 = "ipv4"
	NetworkACLRulePrototype_IpVersion_Ipv6 = "ipv6"
)

func (*NetworkACLRulePrototype) isaNetworkACLRulePrototype() bool {
	return true
}

type NetworkACLRulePrototypeIntf interface {
	isaNetworkACLRulePrototype() bool
}

// UnmarshalNetworkACLRulePrototype constructs an instance of NetworkACLRulePrototype from the specified map.
func UnmarshalNetworkACLRulePrototype(m map[string]interface{}) (result NetworkACLRulePrototypeIntf, err error) {
	discValue, err := core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	if discValue == nil {
		err = fmt.Errorf("discriminator property 'protocol' not found in JSON object")
		return
	}
	if *discValue == "all" {
		result, err = UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolAll(m)
	} else if *discValue == "icmp" {
		result, err = UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolICMP(m)
	} else if *discValue == "tcp" {
		result, err = UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP(m)
	} else if *discValue == "udp" {
		result, err = UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP(m)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'protocol': %s", *discValue)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeSlice unmarshals a slice of NetworkACLRulePrototype instances from the specified list of maps.
func UnmarshalNetworkACLRulePrototypeSlice(s []interface{}) (slice []NetworkACLRulePrototypeIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRulePrototype'")
			return
		}
		obj, e := UnmarshalNetworkACLRulePrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeAsProperty unmarshals an instance of NetworkACLRulePrototype that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeAsProperty(m map[string]interface{}, propertyName string) (result NetworkACLRulePrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRulePrototype'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRulePrototype(objMap)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeSliceAsProperty unmarshals a slice of NetworkACLRulePrototype instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRulePrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRulePrototype'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRulePrototypeSlice(vSlice)
	}
	return
}

// NetworkACLRulePrototypeBefore : The rule to insert this rule immediately before. If omitted, this rule will be inserted after all existing rules.
// Models which "extend" this model:
// - NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID
// - NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref
type NetworkACLRulePrototypeBefore struct {
	// The unique identifier for this rule.
	ID *string `json:"id,omitempty"`

	// The URL for this rule.
	Href *string `json:"href,omitempty"`
}

func (*NetworkACLRulePrototypeBefore) isaNetworkACLRulePrototypeBefore() bool {
	return true
}

type NetworkACLRulePrototypeBeforeIntf interface {
	isaNetworkACLRulePrototypeBefore() bool
}

// UnmarshalNetworkACLRulePrototypeBefore constructs an instance of NetworkACLRulePrototypeBefore from the specified map.
func UnmarshalNetworkACLRulePrototypeBefore(m map[string]interface{}) (result NetworkACLRulePrototypeBeforeIntf, err error) {
	obj := new(NetworkACLRulePrototypeBefore)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRulePrototypeBeforeSlice unmarshals a slice of NetworkACLRulePrototypeBefore instances from the specified list of maps.
func UnmarshalNetworkACLRulePrototypeBeforeSlice(s []interface{}) (slice []NetworkACLRulePrototypeBeforeIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRulePrototypeBefore'")
			return
		}
		obj, e := UnmarshalNetworkACLRulePrototypeBefore(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeBeforeAsProperty unmarshals an instance of NetworkACLRulePrototypeBefore that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeBeforeAsProperty(m map[string]interface{}, propertyName string) (result NetworkACLRulePrototypeBeforeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRulePrototypeBefore'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRulePrototypeBefore(objMap)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeBeforeSliceAsProperty unmarshals a slice of NetworkACLRulePrototypeBefore instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeBeforeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRulePrototypeBeforeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRulePrototypeBefore'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRulePrototypeBeforeSlice(vSlice)
	}
	return
}

// NetworkACLRulePrototypeNetworkACLContext : NetworkACLRulePrototypeNetworkACLContext struct
// Models which "extend" this model:
// - NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP
// - NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP
// - NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll
type NetworkACLRulePrototypeNetworkACLContext struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The destination IP address or CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source IP address or CIDR block.  The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at,omitempty"`

	// The URL for this rule.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this rule.
	ID *string `json:"id,omitempty"`

	// The IP version for this rule.
	IpVersion *string `json:"ip_version,omitempty"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`

	// The ICMP traffic code to allow. If unspecified, all codes are allowed. This can only be specified if type is also
	// specified.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow. If unspecified, all types are allowed by this rule.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLContext.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRulePrototypeNetworkACLContext_Action_Allow = "allow"
	NetworkACLRulePrototypeNetworkACLContext_Action_Deny  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContext.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRulePrototypeNetworkACLContext_Direction_Inbound  = "inbound"
	NetworkACLRulePrototypeNetworkACLContext_Direction_Outbound = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContext.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLContext_Protocol_All  = "all"
	NetworkACLRulePrototypeNetworkACLContext_Protocol_Icmp = "icmp"
	NetworkACLRulePrototypeNetworkACLContext_Protocol_Tcp  = "tcp"
	NetworkACLRulePrototypeNetworkACLContext_Protocol_Udp  = "udp"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContext.IpVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLContext_IpVersion_Ipv4 = "ipv4"
	NetworkACLRulePrototypeNetworkACLContext_IpVersion_Ipv6 = "ipv6"
)

func (*NetworkACLRulePrototypeNetworkACLContext) isaNetworkACLRulePrototypeNetworkACLContext() bool {
	return true
}

type NetworkACLRulePrototypeNetworkACLContextIntf interface {
	isaNetworkACLRulePrototypeNetworkACLContext() bool
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContext constructs an instance of NetworkACLRulePrototypeNetworkACLContext from the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLContext(m map[string]interface{}) (result NetworkACLRulePrototypeNetworkACLContextIntf, err error) {
	discValue, err := core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	if discValue == nil {
		err = fmt.Errorf("discriminator property 'protocol' not found in JSON object")
		return
	}
	if *discValue == "all" {
		result, err = UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll(m)
	} else if *discValue == "icmp" {
		result, err = UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP(m)
	} else if *discValue == "tcp" {
		result, err = UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP(m)
	} else if *discValue == "udp" {
		result, err = UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP(m)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'protocol': %s", *discValue)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextSlice unmarshals a slice of NetworkACLRulePrototypeNetworkACLContext instances from the specified list of maps.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextSlice(s []interface{}) (slice []NetworkACLRulePrototypeNetworkACLContextIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRulePrototypeNetworkACLContext'")
			return
		}
		obj, e := UnmarshalNetworkACLRulePrototypeNetworkACLContext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextAsProperty unmarshals an instance of NetworkACLRulePrototypeNetworkACLContext that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextAsProperty(m map[string]interface{}, propertyName string) (result NetworkACLRulePrototypeNetworkACLContextIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRulePrototypeNetworkACLContext'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRulePrototypeNetworkACLContext(objMap)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextSliceAsProperty unmarshals a slice of NetworkACLRulePrototypeNetworkACLContext instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRulePrototypeNetworkACLContextIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRulePrototypeNetworkACLContext'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRulePrototypeNetworkACLContextSlice(vSlice)
	}
	return
}

// NetworkACLRuleReference : NetworkACLRuleReference struct
type NetworkACLRuleReference struct {
	// The URL for this rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this rule.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this rule.
	Name *string `json:"name" validate:"required"`
}

// NewNetworkACLRuleReference : Instantiate NetworkACLRuleReference (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRuleReference(href string, id string, name string) (model *NetworkACLRuleReference, err error) {
	model = &NetworkACLRuleReference{
		Href: core.StringPtr(href),
		ID:   core.StringPtr(id),
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalNetworkACLRuleReference constructs an instance of NetworkACLRuleReference from the specified map.
func UnmarshalNetworkACLRuleReference(m map[string]interface{}) (result *NetworkACLRuleReference, err error) {
	obj := new(NetworkACLRuleReference)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRuleReferenceSlice unmarshals a slice of NetworkACLRuleReference instances from the specified list of maps.
func UnmarshalNetworkACLRuleReferenceSlice(s []interface{}) (slice []NetworkACLRuleReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRuleReference'")
			return
		}
		obj, e := UnmarshalNetworkACLRuleReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRuleReferenceAsProperty unmarshals an instance of NetworkACLRuleReference that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleReferenceAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRuleReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRuleReference'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRuleReference(objMap)
	}
	return
}

// UnmarshalNetworkACLRuleReferenceSliceAsProperty unmarshals a slice of NetworkACLRuleReference instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRuleReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRuleReference'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRuleReferenceSlice(vSlice)
	}
	return
}

// NetworkInterface : NetworkInterface struct
type NetworkInterface struct {
	// The date and time that the network interface was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Array of references to floating IPs associated with this network interface.
	FloatingIps []FloatingIPReference `json:"floating_ips,omitempty"`

	// The URL for this network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network interface.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this network interface.
	Name *string `json:"name" validate:"required"`

	// The network interface port speed in Mbps.
	PortSpeed *int64 `json:"port_speed" validate:"required"`

	// The primary IPv4 address.
	PrimaryIpv4Address *string `json:"primary_ipv4_address" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`

	// Collection of security groups.
	SecurityGroups []SecurityGroupReference `json:"security_groups" validate:"required"`

	// The status of the network interface.
	Status *string `json:"status" validate:"required"`

	// The associated subnet.
	Subnet *SubnetReference `json:"subnet" validate:"required"`

	// The type of this network interface as it relates to an instance.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the NetworkInterface.ResourceType property.
// The type of resource referenced.
const (
	NetworkInterface_ResourceType_NetworkInterface = "network_interface"
)

// Constants associated with the NetworkInterface.Status property.
// The status of the network interface.
const (
	NetworkInterface_Status_Available = "available"
	NetworkInterface_Status_Failed    = "failed"
	NetworkInterface_Status_Pending   = "pending"
)

// Constants associated with the NetworkInterface.Type property.
// The type of this network interface as it relates to an instance.
const (
	NetworkInterface_Type_Primary   = "primary"
	NetworkInterface_Type_Secondary = "secondary"
)

// UnmarshalNetworkInterface constructs an instance of NetworkInterface from the specified map.
func UnmarshalNetworkInterface(m map[string]interface{}) (result *NetworkInterface, err error) {
	obj := new(NetworkInterface)
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.FloatingIps, err = UnmarshalFloatingIPReferenceSliceAsProperty(m, "floating_ips")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.PortSpeed, err = core.UnmarshalInt64(m, "port_speed")
	if err != nil {
		return
	}
	obj.PrimaryIpv4Address, err = core.UnmarshalString(m, "primary_ipv4_address")
	if err != nil {
		return
	}
	obj.ResourceType, err = core.UnmarshalString(m, "resource_type")
	if err != nil {
		return
	}
	obj.SecurityGroups, err = UnmarshalSecurityGroupReferenceSliceAsProperty(m, "security_groups")
	if err != nil {
		return
	}
	obj.Status, err = core.UnmarshalString(m, "status")
	if err != nil {
		return
	}
	obj.Subnet, err = UnmarshalSubnetReferenceAsProperty(m, "subnet")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkInterfaceSlice unmarshals a slice of NetworkInterface instances from the specified list of maps.
func UnmarshalNetworkInterfaceSlice(s []interface{}) (slice []NetworkInterface, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkInterface'")
			return
		}
		obj, e := UnmarshalNetworkInterface(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkInterfaceAsProperty unmarshals an instance of NetworkInterface that is stored as a property
// within the specified map.
func UnmarshalNetworkInterfaceAsProperty(m map[string]interface{}, propertyName string) (result *NetworkInterface, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkInterface'", propertyName)
			return
		}
		result, err = UnmarshalNetworkInterface(objMap)
	}
	return
}

// UnmarshalNetworkInterfaceSliceAsProperty unmarshals a slice of NetworkInterface instances that are stored as a property
// within the specified map.
func UnmarshalNetworkInterfaceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkInterface, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkInterface'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkInterfaceSlice(vSlice)
	}
	return
}

// NetworkInterfaceCollection : NetworkInterfaceCollection struct
type NetworkInterfaceCollection struct {
	// Collection of network interfaces.
	NetworkInterfaces []NetworkInterface `json:"network_interfaces" validate:"required"`
}

// UnmarshalNetworkInterfaceCollection constructs an instance of NetworkInterfaceCollection from the specified map.
func UnmarshalNetworkInterfaceCollection(m map[string]interface{}) (result *NetworkInterfaceCollection, err error) {
	obj := new(NetworkInterfaceCollection)
	obj.NetworkInterfaces, err = UnmarshalNetworkInterfaceSliceAsProperty(m, "network_interfaces")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkInterfaceCollectionSlice unmarshals a slice of NetworkInterfaceCollection instances from the specified list of maps.
func UnmarshalNetworkInterfaceCollectionSlice(s []interface{}) (slice []NetworkInterfaceCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkInterfaceCollection'")
			return
		}
		obj, e := UnmarshalNetworkInterfaceCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkInterfaceCollectionAsProperty unmarshals an instance of NetworkInterfaceCollection that is stored as a property
// within the specified map.
func UnmarshalNetworkInterfaceCollectionAsProperty(m map[string]interface{}, propertyName string) (result *NetworkInterfaceCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkInterfaceCollection'", propertyName)
			return
		}
		result, err = UnmarshalNetworkInterfaceCollection(objMap)
	}
	return
}

// UnmarshalNetworkInterfaceCollectionSliceAsProperty unmarshals a slice of NetworkInterfaceCollection instances that are stored as a property
// within the specified map.
func UnmarshalNetworkInterfaceCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkInterfaceCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkInterfaceCollection'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkInterfaceCollectionSlice(vSlice)
	}
	return
}

// NetworkInterfaceIdentity : Identifies a network interface by a unique property.
// Models which "extend" this model:
// - NetworkInterfaceIdentityByID
// - NetworkInterfaceIdentityByHref
type NetworkInterfaceIdentity struct {
	// The unique identifier for this network interface.
	ID *string `json:"id,omitempty"`

	// The URL for this network interface.
	Href *string `json:"href,omitempty"`
}

func (*NetworkInterfaceIdentity) isaNetworkInterfaceIdentity() bool {
	return true
}

type NetworkInterfaceIdentityIntf interface {
	isaNetworkInterfaceIdentity() bool
}

// UnmarshalNetworkInterfaceIdentity constructs an instance of NetworkInterfaceIdentity from the specified map.
func UnmarshalNetworkInterfaceIdentity(m map[string]interface{}) (result NetworkInterfaceIdentityIntf, err error) {
	obj := new(NetworkInterfaceIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkInterfaceIdentitySlice unmarshals a slice of NetworkInterfaceIdentity instances from the specified list of maps.
func UnmarshalNetworkInterfaceIdentitySlice(s []interface{}) (slice []NetworkInterfaceIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkInterfaceIdentity'")
			return
		}
		obj, e := UnmarshalNetworkInterfaceIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalNetworkInterfaceIdentityAsProperty unmarshals an instance of NetworkInterfaceIdentity that is stored as a property
// within the specified map.
func UnmarshalNetworkInterfaceIdentityAsProperty(m map[string]interface{}, propertyName string) (result NetworkInterfaceIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkInterfaceIdentity'", propertyName)
			return
		}
		result, err = UnmarshalNetworkInterfaceIdentity(objMap)
	}
	return
}

// UnmarshalNetworkInterfaceIdentitySliceAsProperty unmarshals a slice of NetworkInterfaceIdentity instances that are stored as a property
// within the specified map.
func UnmarshalNetworkInterfaceIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkInterfaceIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkInterfaceIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkInterfaceIdentitySlice(vSlice)
	}
	return
}

// NetworkInterfaceInstanceContextReference : NetworkInterfaceInstanceContextReference struct
type NetworkInterfaceInstanceContextReference struct {
	// The URL for this network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network interface.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this network interface.
	Name *string `json:"name" validate:"required"`

	// The primary IPv4 address.
	PrimaryIpv4Address *string `json:"primary_ipv4_address" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The associated subnet.
	Subnet *SubnetReference `json:"subnet" validate:"required"`
}

// Constants associated with the NetworkInterfaceInstanceContextReference.ResourceType property.
// The type of resource referenced.
const (
	NetworkInterfaceInstanceContextReference_ResourceType_NetworkInterface = "network_interface"
)

// UnmarshalNetworkInterfaceInstanceContextReference constructs an instance of NetworkInterfaceInstanceContextReference from the specified map.
func UnmarshalNetworkInterfaceInstanceContextReference(m map[string]interface{}) (result *NetworkInterfaceInstanceContextReference, err error) {
	obj := new(NetworkInterfaceInstanceContextReference)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.PrimaryIpv4Address, err = core.UnmarshalString(m, "primary_ipv4_address")
	if err != nil {
		return
	}
	obj.ResourceType, err = core.UnmarshalString(m, "resource_type")
	if err != nil {
		return
	}
	obj.Subnet, err = UnmarshalSubnetReferenceAsProperty(m, "subnet")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkInterfaceInstanceContextReferenceSlice unmarshals a slice of NetworkInterfaceInstanceContextReference instances from the specified list of maps.
func UnmarshalNetworkInterfaceInstanceContextReferenceSlice(s []interface{}) (slice []NetworkInterfaceInstanceContextReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkInterfaceInstanceContextReference'")
			return
		}
		obj, e := UnmarshalNetworkInterfaceInstanceContextReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkInterfaceInstanceContextReferenceAsProperty unmarshals an instance of NetworkInterfaceInstanceContextReference that is stored as a property
// within the specified map.
func UnmarshalNetworkInterfaceInstanceContextReferenceAsProperty(m map[string]interface{}, propertyName string) (result *NetworkInterfaceInstanceContextReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkInterfaceInstanceContextReference'", propertyName)
			return
		}
		result, err = UnmarshalNetworkInterfaceInstanceContextReference(objMap)
	}
	return
}

// UnmarshalNetworkInterfaceInstanceContextReferenceSliceAsProperty unmarshals a slice of NetworkInterfaceInstanceContextReference instances that are stored as a property
// within the specified map.
func UnmarshalNetworkInterfaceInstanceContextReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkInterfaceInstanceContextReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkInterfaceInstanceContextReference'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkInterfaceInstanceContextReferenceSlice(vSlice)
	}
	return
}

// NetworkInterfacePrototype : NetworkInterfacePrototype struct
type NetworkInterfacePrototype struct {
	// The user-defined name for this network interface. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The primary IPv4 address.
	PrimaryIpv4Address *string `json:"primary_ipv4_address,omitempty"`

	// Collection of security groups.
	SecurityGroups []SecurityGroupIdentityIntf `json:"security_groups,omitempty"`

	// The associated subnet.
	Subnet SubnetIdentityIntf `json:"subnet" validate:"required"`
}

// NewNetworkInterfacePrototype : Instantiate NetworkInterfacePrototype (Generic Model Constructor)
func (*VpcV1) NewNetworkInterfacePrototype(subnet SubnetIdentityIntf) (model *NetworkInterfacePrototype, err error) {
	model = &NetworkInterfacePrototype{
		Subnet: subnet,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalNetworkInterfacePrototype constructs an instance of NetworkInterfacePrototype from the specified map.
func UnmarshalNetworkInterfacePrototype(m map[string]interface{}) (result *NetworkInterfacePrototype, err error) {
	obj := new(NetworkInterfacePrototype)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.PrimaryIpv4Address, err = core.UnmarshalString(m, "primary_ipv4_address")
	if err != nil {
		return
	}
	obj.SecurityGroups, err = UnmarshalSecurityGroupIdentitySliceAsProperty(m, "security_groups")
	if err != nil {
		return
	}
	obj.Subnet, err = UnmarshalSubnetIdentityAsProperty(m, "subnet")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkInterfacePrototypeSlice unmarshals a slice of NetworkInterfacePrototype instances from the specified list of maps.
func UnmarshalNetworkInterfacePrototypeSlice(s []interface{}) (slice []NetworkInterfacePrototype, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkInterfacePrototype'")
			return
		}
		obj, e := UnmarshalNetworkInterfacePrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkInterfacePrototypeAsProperty unmarshals an instance of NetworkInterfacePrototype that is stored as a property
// within the specified map.
func UnmarshalNetworkInterfacePrototypeAsProperty(m map[string]interface{}, propertyName string) (result *NetworkInterfacePrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkInterfacePrototype'", propertyName)
			return
		}
		result, err = UnmarshalNetworkInterfacePrototype(objMap)
	}
	return
}

// UnmarshalNetworkInterfacePrototypeSliceAsProperty unmarshals a slice of NetworkInterfacePrototype instances that are stored as a property
// within the specified map.
func UnmarshalNetworkInterfacePrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkInterfacePrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkInterfacePrototype'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkInterfacePrototypeSlice(vSlice)
	}
	return
}

// NetworkInterfaceReference : NetworkInterfaceReference struct
type NetworkInterfaceReference struct {
	// The URL for this network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network interface.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this network interface.
	Name *string `json:"name" validate:"required"`

	// The primary IPv4 address.
	PrimaryIpv4Address *string `json:"primary_ipv4_address" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the NetworkInterfaceReference.ResourceType property.
// The type of resource referenced.
const (
	NetworkInterfaceReference_ResourceType_NetworkInterface = "network_interface"
)

// UnmarshalNetworkInterfaceReference constructs an instance of NetworkInterfaceReference from the specified map.
func UnmarshalNetworkInterfaceReference(m map[string]interface{}) (result *NetworkInterfaceReference, err error) {
	obj := new(NetworkInterfaceReference)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.PrimaryIpv4Address, err = core.UnmarshalString(m, "primary_ipv4_address")
	if err != nil {
		return
	}
	obj.ResourceType, err = core.UnmarshalString(m, "resource_type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkInterfaceReferenceSlice unmarshals a slice of NetworkInterfaceReference instances from the specified list of maps.
func UnmarshalNetworkInterfaceReferenceSlice(s []interface{}) (slice []NetworkInterfaceReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkInterfaceReference'")
			return
		}
		obj, e := UnmarshalNetworkInterfaceReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkInterfaceReferenceAsProperty unmarshals an instance of NetworkInterfaceReference that is stored as a property
// within the specified map.
func UnmarshalNetworkInterfaceReferenceAsProperty(m map[string]interface{}, propertyName string) (result *NetworkInterfaceReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkInterfaceReference'", propertyName)
			return
		}
		result, err = UnmarshalNetworkInterfaceReference(objMap)
	}
	return
}

// UnmarshalNetworkInterfaceReferenceSliceAsProperty unmarshals a slice of NetworkInterfaceReference instances that are stored as a property
// within the specified map.
func UnmarshalNetworkInterfaceReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkInterfaceReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkInterfaceReference'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkInterfaceReferenceSlice(vSlice)
	}
	return
}

// OperatingSystem : OperatingSystem struct
type OperatingSystem struct {
	// The operating system architecture.
	Architecture *string `json:"architecture" validate:"required"`

	// A unique, display-friendly name for the operating system.
	DisplayName *string `json:"display_name" validate:"required"`

	// The name of the software family this operating system belongs to.
	Family *string `json:"family" validate:"required"`

	// The URL for this operating system.
	Href *string `json:"href" validate:"required"`

	// The unique name of the operating system.
	Name *string `json:"name" validate:"required"`

	// The vendor of the operating system.
	Vendor *string `json:"vendor" validate:"required"`

	// The major release version of this operating system.
	Version *string `json:"version" validate:"required"`
}

// UnmarshalOperatingSystem constructs an instance of OperatingSystem from the specified map.
func UnmarshalOperatingSystem(m map[string]interface{}) (result *OperatingSystem, err error) {
	obj := new(OperatingSystem)
	obj.Architecture, err = core.UnmarshalString(m, "architecture")
	if err != nil {
		return
	}
	obj.DisplayName, err = core.UnmarshalString(m, "display_name")
	if err != nil {
		return
	}
	obj.Family, err = core.UnmarshalString(m, "family")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Vendor, err = core.UnmarshalString(m, "vendor")
	if err != nil {
		return
	}
	obj.Version, err = core.UnmarshalString(m, "version")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalOperatingSystemSlice unmarshals a slice of OperatingSystem instances from the specified list of maps.
func UnmarshalOperatingSystemSlice(s []interface{}) (slice []OperatingSystem, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'OperatingSystem'")
			return
		}
		obj, e := UnmarshalOperatingSystem(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalOperatingSystemAsProperty unmarshals an instance of OperatingSystem that is stored as a property
// within the specified map.
func UnmarshalOperatingSystemAsProperty(m map[string]interface{}, propertyName string) (result *OperatingSystem, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'OperatingSystem'", propertyName)
			return
		}
		result, err = UnmarshalOperatingSystem(objMap)
	}
	return
}

// UnmarshalOperatingSystemSliceAsProperty unmarshals a slice of OperatingSystem instances that are stored as a property
// within the specified map.
func UnmarshalOperatingSystemSliceAsProperty(m map[string]interface{}, propertyName string) (slice []OperatingSystem, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'OperatingSystem'", propertyName)
			return
		}
		slice, err = UnmarshalOperatingSystemSlice(vSlice)
	}
	return
}

// OperatingSystemCollection : OperatingSystemCollection struct
type OperatingSystemCollection struct {
	// A reference to the first page of resources.
	First *OperatingSystemCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *OperatingSystemCollectionNext `json:"next,omitempty"`

	// Collection of operating systems.
	OperatingSystems []OperatingSystem `json:"operating_systems" validate:"required"`
}

// UnmarshalOperatingSystemCollection constructs an instance of OperatingSystemCollection from the specified map.
func UnmarshalOperatingSystemCollection(m map[string]interface{}) (result *OperatingSystemCollection, err error) {
	obj := new(OperatingSystemCollection)
	obj.First, err = UnmarshalOperatingSystemCollectionFirstAsProperty(m, "first")
	if err != nil {
		return
	}
	obj.Limit, err = core.UnmarshalInt64(m, "limit")
	if err != nil {
		return
	}
	obj.Next, err = UnmarshalOperatingSystemCollectionNextAsProperty(m, "next")
	if err != nil {
		return
	}
	obj.OperatingSystems, err = UnmarshalOperatingSystemSliceAsProperty(m, "operating_systems")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalOperatingSystemCollectionSlice unmarshals a slice of OperatingSystemCollection instances from the specified list of maps.
func UnmarshalOperatingSystemCollectionSlice(s []interface{}) (slice []OperatingSystemCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'OperatingSystemCollection'")
			return
		}
		obj, e := UnmarshalOperatingSystemCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalOperatingSystemCollectionAsProperty unmarshals an instance of OperatingSystemCollection that is stored as a property
// within the specified map.
func UnmarshalOperatingSystemCollectionAsProperty(m map[string]interface{}, propertyName string) (result *OperatingSystemCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'OperatingSystemCollection'", propertyName)
			return
		}
		result, err = UnmarshalOperatingSystemCollection(objMap)
	}
	return
}

// UnmarshalOperatingSystemCollectionSliceAsProperty unmarshals a slice of OperatingSystemCollection instances that are stored as a property
// within the specified map.
func UnmarshalOperatingSystemCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []OperatingSystemCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'OperatingSystemCollection'", propertyName)
			return
		}
		slice, err = UnmarshalOperatingSystemCollectionSlice(vSlice)
	}
	return
}

// OperatingSystemCollectionFirst : A reference to the first page of resources.
type OperatingSystemCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalOperatingSystemCollectionFirst constructs an instance of OperatingSystemCollectionFirst from the specified map.
func UnmarshalOperatingSystemCollectionFirst(m map[string]interface{}) (result *OperatingSystemCollectionFirst, err error) {
	obj := new(OperatingSystemCollectionFirst)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalOperatingSystemCollectionFirstSlice unmarshals a slice of OperatingSystemCollectionFirst instances from the specified list of maps.
func UnmarshalOperatingSystemCollectionFirstSlice(s []interface{}) (slice []OperatingSystemCollectionFirst, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'OperatingSystemCollectionFirst'")
			return
		}
		obj, e := UnmarshalOperatingSystemCollectionFirst(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalOperatingSystemCollectionFirstAsProperty unmarshals an instance of OperatingSystemCollectionFirst that is stored as a property
// within the specified map.
func UnmarshalOperatingSystemCollectionFirstAsProperty(m map[string]interface{}, propertyName string) (result *OperatingSystemCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'OperatingSystemCollectionFirst'", propertyName)
			return
		}
		result, err = UnmarshalOperatingSystemCollectionFirst(objMap)
	}
	return
}

// UnmarshalOperatingSystemCollectionFirstSliceAsProperty unmarshals a slice of OperatingSystemCollectionFirst instances that are stored as a property
// within the specified map.
func UnmarshalOperatingSystemCollectionFirstSliceAsProperty(m map[string]interface{}, propertyName string) (slice []OperatingSystemCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'OperatingSystemCollectionFirst'", propertyName)
			return
		}
		slice, err = UnmarshalOperatingSystemCollectionFirstSlice(vSlice)
	}
	return
}

// OperatingSystemCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type OperatingSystemCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalOperatingSystemCollectionNext constructs an instance of OperatingSystemCollectionNext from the specified map.
func UnmarshalOperatingSystemCollectionNext(m map[string]interface{}) (result *OperatingSystemCollectionNext, err error) {
	obj := new(OperatingSystemCollectionNext)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalOperatingSystemCollectionNextSlice unmarshals a slice of OperatingSystemCollectionNext instances from the specified list of maps.
func UnmarshalOperatingSystemCollectionNextSlice(s []interface{}) (slice []OperatingSystemCollectionNext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'OperatingSystemCollectionNext'")
			return
		}
		obj, e := UnmarshalOperatingSystemCollectionNext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalOperatingSystemCollectionNextAsProperty unmarshals an instance of OperatingSystemCollectionNext that is stored as a property
// within the specified map.
func UnmarshalOperatingSystemCollectionNextAsProperty(m map[string]interface{}, propertyName string) (result *OperatingSystemCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'OperatingSystemCollectionNext'", propertyName)
			return
		}
		result, err = UnmarshalOperatingSystemCollectionNext(objMap)
	}
	return
}

// UnmarshalOperatingSystemCollectionNextSliceAsProperty unmarshals a slice of OperatingSystemCollectionNext instances that are stored as a property
// within the specified map.
func UnmarshalOperatingSystemCollectionNextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []OperatingSystemCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'OperatingSystemCollectionNext'", propertyName)
			return
		}
		slice, err = UnmarshalOperatingSystemCollectionNextSlice(vSlice)
	}
	return
}

// OperatingSystemIdentity : Identifies an operating system by a unique property.
// Models which "extend" this model:
// - OperatingSystemIdentityByName
// - OperatingSystemIdentityByHref
type OperatingSystemIdentity struct {
	// The unique name of the operating system.
	Name *string `json:"name,omitempty"`

	// The URL for this operating system.
	Href *string `json:"href,omitempty"`
}

func (*OperatingSystemIdentity) isaOperatingSystemIdentity() bool {
	return true
}

type OperatingSystemIdentityIntf interface {
	isaOperatingSystemIdentity() bool
}

// UnmarshalOperatingSystemIdentity constructs an instance of OperatingSystemIdentity from the specified map.
func UnmarshalOperatingSystemIdentity(m map[string]interface{}) (result OperatingSystemIdentityIntf, err error) {
	obj := new(OperatingSystemIdentity)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalOperatingSystemIdentitySlice unmarshals a slice of OperatingSystemIdentity instances from the specified list of maps.
func UnmarshalOperatingSystemIdentitySlice(s []interface{}) (slice []OperatingSystemIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'OperatingSystemIdentity'")
			return
		}
		obj, e := UnmarshalOperatingSystemIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalOperatingSystemIdentityAsProperty unmarshals an instance of OperatingSystemIdentity that is stored as a property
// within the specified map.
func UnmarshalOperatingSystemIdentityAsProperty(m map[string]interface{}, propertyName string) (result OperatingSystemIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'OperatingSystemIdentity'", propertyName)
			return
		}
		result, err = UnmarshalOperatingSystemIdentity(objMap)
	}
	return
}

// UnmarshalOperatingSystemIdentitySliceAsProperty unmarshals a slice of OperatingSystemIdentity instances that are stored as a property
// within the specified map.
func UnmarshalOperatingSystemIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []OperatingSystemIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'OperatingSystemIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalOperatingSystemIdentitySlice(vSlice)
	}
	return
}

// PublicGateway : PublicGateway struct
type PublicGateway struct {
	// The date and time that the public gateway was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this public gateway.
	Crn *string `json:"crn" validate:"required"`

	// Reference to the floating IP which is bound to this public gateway.
	FloatingIp *PublicGatewayFloatingIp `json:"floating_ip" validate:"required"`

	// The URL for this gateway.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this public gateway.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this public gateway.
	Name *string `json:"name" validate:"required"`

	// The resource group for this public gateway.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The status of the volume.
	Status *string `json:"status" validate:"required"`

	// The VPC this public gateway serves.
	Vpc *VPCReference `json:"vpc" validate:"required"`

	// The zone where this public gateway lives.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the PublicGateway.ResourceType property.
// The type of resource referenced.
const (
	PublicGateway_ResourceType_PublicGateway = "public_gateway"
)

// Constants associated with the PublicGateway.Status property.
// The status of the volume.
const (
	PublicGateway_Status_Available = "available"
	PublicGateway_Status_Deleting  = "deleting"
	PublicGateway_Status_Failed    = "failed"
	PublicGateway_Status_Pending   = "pending"
)

// UnmarshalPublicGateway constructs an instance of PublicGateway from the specified map.
func UnmarshalPublicGateway(m map[string]interface{}) (result *PublicGateway, err error) {
	obj := new(PublicGateway)
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.FloatingIp, err = UnmarshalPublicGatewayFloatingIpAsProperty(m, "floating_ip")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupReferenceAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.ResourceType, err = core.UnmarshalString(m, "resource_type")
	if err != nil {
		return
	}
	obj.Status, err = core.UnmarshalString(m, "status")
	if err != nil {
		return
	}
	obj.Vpc, err = UnmarshalVPCReferenceAsProperty(m, "vpc")
	if err != nil {
		return
	}
	obj.Zone, err = UnmarshalZoneReferenceAsProperty(m, "zone")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPublicGatewaySlice unmarshals a slice of PublicGateway instances from the specified list of maps.
func UnmarshalPublicGatewaySlice(s []interface{}) (slice []PublicGateway, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PublicGateway'")
			return
		}
		obj, e := UnmarshalPublicGateway(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalPublicGatewayAsProperty unmarshals an instance of PublicGateway that is stored as a property
// within the specified map.
func UnmarshalPublicGatewayAsProperty(m map[string]interface{}, propertyName string) (result *PublicGateway, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PublicGateway'", propertyName)
			return
		}
		result, err = UnmarshalPublicGateway(objMap)
	}
	return
}

// UnmarshalPublicGatewaySliceAsProperty unmarshals a slice of PublicGateway instances that are stored as a property
// within the specified map.
func UnmarshalPublicGatewaySliceAsProperty(m map[string]interface{}, propertyName string) (slice []PublicGateway, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PublicGateway'", propertyName)
			return
		}
		slice, err = UnmarshalPublicGatewaySlice(vSlice)
	}
	return
}

// PublicGatewayCollection : PublicGatewayCollection struct
type PublicGatewayCollection struct {
	// A reference to the first page of resources.
	First *PublicGatewayCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *PublicGatewayCollectionNext `json:"next,omitempty"`

	// Collection of public gateways.
	PublicGateways []PublicGateway `json:"public_gateways" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalPublicGatewayCollection constructs an instance of PublicGatewayCollection from the specified map.
func UnmarshalPublicGatewayCollection(m map[string]interface{}) (result *PublicGatewayCollection, err error) {
	obj := new(PublicGatewayCollection)
	obj.First, err = UnmarshalPublicGatewayCollectionFirstAsProperty(m, "first")
	if err != nil {
		return
	}
	obj.Limit, err = core.UnmarshalInt64(m, "limit")
	if err != nil {
		return
	}
	obj.Next, err = UnmarshalPublicGatewayCollectionNextAsProperty(m, "next")
	if err != nil {
		return
	}
	obj.PublicGateways, err = UnmarshalPublicGatewaySliceAsProperty(m, "public_gateways")
	if err != nil {
		return
	}
	obj.TotalCount, err = core.UnmarshalInt64(m, "total_count")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPublicGatewayCollectionSlice unmarshals a slice of PublicGatewayCollection instances from the specified list of maps.
func UnmarshalPublicGatewayCollectionSlice(s []interface{}) (slice []PublicGatewayCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PublicGatewayCollection'")
			return
		}
		obj, e := UnmarshalPublicGatewayCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalPublicGatewayCollectionAsProperty unmarshals an instance of PublicGatewayCollection that is stored as a property
// within the specified map.
func UnmarshalPublicGatewayCollectionAsProperty(m map[string]interface{}, propertyName string) (result *PublicGatewayCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PublicGatewayCollection'", propertyName)
			return
		}
		result, err = UnmarshalPublicGatewayCollection(objMap)
	}
	return
}

// UnmarshalPublicGatewayCollectionSliceAsProperty unmarshals a slice of PublicGatewayCollection instances that are stored as a property
// within the specified map.
func UnmarshalPublicGatewayCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []PublicGatewayCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PublicGatewayCollection'", propertyName)
			return
		}
		slice, err = UnmarshalPublicGatewayCollectionSlice(vSlice)
	}
	return
}

// PublicGatewayCollectionFirst : A reference to the first page of resources.
type PublicGatewayCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPublicGatewayCollectionFirst constructs an instance of PublicGatewayCollectionFirst from the specified map.
func UnmarshalPublicGatewayCollectionFirst(m map[string]interface{}) (result *PublicGatewayCollectionFirst, err error) {
	obj := new(PublicGatewayCollectionFirst)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPublicGatewayCollectionFirstSlice unmarshals a slice of PublicGatewayCollectionFirst instances from the specified list of maps.
func UnmarshalPublicGatewayCollectionFirstSlice(s []interface{}) (slice []PublicGatewayCollectionFirst, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PublicGatewayCollectionFirst'")
			return
		}
		obj, e := UnmarshalPublicGatewayCollectionFirst(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalPublicGatewayCollectionFirstAsProperty unmarshals an instance of PublicGatewayCollectionFirst that is stored as a property
// within the specified map.
func UnmarshalPublicGatewayCollectionFirstAsProperty(m map[string]interface{}, propertyName string) (result *PublicGatewayCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PublicGatewayCollectionFirst'", propertyName)
			return
		}
		result, err = UnmarshalPublicGatewayCollectionFirst(objMap)
	}
	return
}

// UnmarshalPublicGatewayCollectionFirstSliceAsProperty unmarshals a slice of PublicGatewayCollectionFirst instances that are stored as a property
// within the specified map.
func UnmarshalPublicGatewayCollectionFirstSliceAsProperty(m map[string]interface{}, propertyName string) (slice []PublicGatewayCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PublicGatewayCollectionFirst'", propertyName)
			return
		}
		slice, err = UnmarshalPublicGatewayCollectionFirstSlice(vSlice)
	}
	return
}

// PublicGatewayCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type PublicGatewayCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPublicGatewayCollectionNext constructs an instance of PublicGatewayCollectionNext from the specified map.
func UnmarshalPublicGatewayCollectionNext(m map[string]interface{}) (result *PublicGatewayCollectionNext, err error) {
	obj := new(PublicGatewayCollectionNext)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPublicGatewayCollectionNextSlice unmarshals a slice of PublicGatewayCollectionNext instances from the specified list of maps.
func UnmarshalPublicGatewayCollectionNextSlice(s []interface{}) (slice []PublicGatewayCollectionNext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PublicGatewayCollectionNext'")
			return
		}
		obj, e := UnmarshalPublicGatewayCollectionNext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalPublicGatewayCollectionNextAsProperty unmarshals an instance of PublicGatewayCollectionNext that is stored as a property
// within the specified map.
func UnmarshalPublicGatewayCollectionNextAsProperty(m map[string]interface{}, propertyName string) (result *PublicGatewayCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PublicGatewayCollectionNext'", propertyName)
			return
		}
		result, err = UnmarshalPublicGatewayCollectionNext(objMap)
	}
	return
}

// UnmarshalPublicGatewayCollectionNextSliceAsProperty unmarshals a slice of PublicGatewayCollectionNext instances that are stored as a property
// within the specified map.
func UnmarshalPublicGatewayCollectionNextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []PublicGatewayCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PublicGatewayCollectionNext'", propertyName)
			return
		}
		slice, err = UnmarshalPublicGatewayCollectionNextSlice(vSlice)
	}
	return
}

// PublicGatewayFloatingIp : Reference to the floating IP which is bound to this public gateway.
type PublicGatewayFloatingIp struct {
	// The globally unique IP address.
	Address *string `json:"address" validate:"required"`

	// The CRN for this floating IP.
	Crn *string `json:"crn" validate:"required"`

	// The URL for this floating IPs.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this floating IP.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this floating IP.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalPublicGatewayFloatingIp constructs an instance of PublicGatewayFloatingIp from the specified map.
func UnmarshalPublicGatewayFloatingIp(m map[string]interface{}) (result *PublicGatewayFloatingIp, err error) {
	obj := new(PublicGatewayFloatingIp)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPublicGatewayFloatingIpSlice unmarshals a slice of PublicGatewayFloatingIp instances from the specified list of maps.
func UnmarshalPublicGatewayFloatingIpSlice(s []interface{}) (slice []PublicGatewayFloatingIp, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PublicGatewayFloatingIp'")
			return
		}
		obj, e := UnmarshalPublicGatewayFloatingIp(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalPublicGatewayFloatingIpAsProperty unmarshals an instance of PublicGatewayFloatingIp that is stored as a property
// within the specified map.
func UnmarshalPublicGatewayFloatingIpAsProperty(m map[string]interface{}, propertyName string) (result *PublicGatewayFloatingIp, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PublicGatewayFloatingIp'", propertyName)
			return
		}
		result, err = UnmarshalPublicGatewayFloatingIp(objMap)
	}
	return
}

// UnmarshalPublicGatewayFloatingIpSliceAsProperty unmarshals a slice of PublicGatewayFloatingIp instances that are stored as a property
// within the specified map.
func UnmarshalPublicGatewayFloatingIpSliceAsProperty(m map[string]interface{}, propertyName string) (slice []PublicGatewayFloatingIp, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PublicGatewayFloatingIp'", propertyName)
			return
		}
		slice, err = UnmarshalPublicGatewayFloatingIpSlice(vSlice)
	}
	return
}

// PublicGatewayIdentity : Identifies a public gateway by a unique property.
// Models which "extend" this model:
// - PublicGatewayIdentityByID
// - PublicGatewayIdentityByCRN
// - PublicGatewayIdentityByHref
type PublicGatewayIdentity struct {
	// The unique identifier for this public gateway.
	ID *string `json:"id,omitempty"`

	// The CRN for this public gateway.
	Crn *string `json:"crn,omitempty"`

	// The URL for this gateway.
	Href *string `json:"href,omitempty"`
}

func (*PublicGatewayIdentity) isaPublicGatewayIdentity() bool {
	return true
}

type PublicGatewayIdentityIntf interface {
	isaPublicGatewayIdentity() bool
}

// UnmarshalPublicGatewayIdentity constructs an instance of PublicGatewayIdentity from the specified map.
func UnmarshalPublicGatewayIdentity(m map[string]interface{}) (result PublicGatewayIdentityIntf, err error) {
	obj := new(PublicGatewayIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPublicGatewayIdentitySlice unmarshals a slice of PublicGatewayIdentity instances from the specified list of maps.
func UnmarshalPublicGatewayIdentitySlice(s []interface{}) (slice []PublicGatewayIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PublicGatewayIdentity'")
			return
		}
		obj, e := UnmarshalPublicGatewayIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalPublicGatewayIdentityAsProperty unmarshals an instance of PublicGatewayIdentity that is stored as a property
// within the specified map.
func UnmarshalPublicGatewayIdentityAsProperty(m map[string]interface{}, propertyName string) (result PublicGatewayIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PublicGatewayIdentity'", propertyName)
			return
		}
		result, err = UnmarshalPublicGatewayIdentity(objMap)
	}
	return
}

// UnmarshalPublicGatewayIdentitySliceAsProperty unmarshals a slice of PublicGatewayIdentity instances that are stored as a property
// within the specified map.
func UnmarshalPublicGatewayIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []PublicGatewayIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PublicGatewayIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalPublicGatewayIdentitySlice(vSlice)
	}
	return
}

// PublicGatewayPrototypeFloatingIp : PublicGatewayPrototypeFloatingIp struct
// Models which "extend" this model:
// - PublicGatewayPrototypeFloatingIpFloatingIPIdentity
// - PublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext
type PublicGatewayPrototypeFloatingIp struct {
	// The unique identifier for this floating IP.
	ID *string `json:"id,omitempty"`

	// The CRN for this floating IP.
	Crn *string `json:"crn,omitempty"`

	// The URL for this floating IPs.
	Href *string `json:"href,omitempty"`

	// The globally unique IP address.
	Address *string `json:"address,omitempty"`

	// The unique user-defined name for this floating IP. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`
}

func (*PublicGatewayPrototypeFloatingIp) isaPublicGatewayPrototypeFloatingIp() bool {
	return true
}

type PublicGatewayPrototypeFloatingIpIntf interface {
	isaPublicGatewayPrototypeFloatingIp() bool
}

// UnmarshalPublicGatewayPrototypeFloatingIp constructs an instance of PublicGatewayPrototypeFloatingIp from the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIp(m map[string]interface{}) (result PublicGatewayPrototypeFloatingIpIntf, err error) {
	obj := new(PublicGatewayPrototypeFloatingIp)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupIdentityAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpSlice unmarshals a slice of PublicGatewayPrototypeFloatingIp instances from the specified list of maps.
func UnmarshalPublicGatewayPrototypeFloatingIpSlice(s []interface{}) (slice []PublicGatewayPrototypeFloatingIpIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PublicGatewayPrototypeFloatingIp'")
			return
		}
		obj, e := UnmarshalPublicGatewayPrototypeFloatingIp(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpAsProperty unmarshals an instance of PublicGatewayPrototypeFloatingIp that is stored as a property
// within the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpAsProperty(m map[string]interface{}, propertyName string) (result PublicGatewayPrototypeFloatingIpIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PublicGatewayPrototypeFloatingIp'", propertyName)
			return
		}
		result, err = UnmarshalPublicGatewayPrototypeFloatingIp(objMap)
	}
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpSliceAsProperty unmarshals a slice of PublicGatewayPrototypeFloatingIp instances that are stored as a property
// within the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpSliceAsProperty(m map[string]interface{}, propertyName string) (slice []PublicGatewayPrototypeFloatingIpIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PublicGatewayPrototypeFloatingIp'", propertyName)
			return
		}
		slice, err = UnmarshalPublicGatewayPrototypeFloatingIpSlice(vSlice)
	}
	return
}

// PublicGatewayReference : PublicGatewayReference struct
type PublicGatewayReference struct {
	// The CRN for this public gateway.
	Crn *string `json:"crn" validate:"required"`

	// The URL for this gateway.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this public gateway.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this public gateway.
	Name *string `json:"name" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the PublicGatewayReference.ResourceType property.
// The type of resource referenced.
const (
	PublicGatewayReference_ResourceType_PublicGateway = "public_gateway"
)

// UnmarshalPublicGatewayReference constructs an instance of PublicGatewayReference from the specified map.
func UnmarshalPublicGatewayReference(m map[string]interface{}) (result *PublicGatewayReference, err error) {
	obj := new(PublicGatewayReference)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.ResourceType, err = core.UnmarshalString(m, "resource_type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPublicGatewayReferenceSlice unmarshals a slice of PublicGatewayReference instances from the specified list of maps.
func UnmarshalPublicGatewayReferenceSlice(s []interface{}) (slice []PublicGatewayReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PublicGatewayReference'")
			return
		}
		obj, e := UnmarshalPublicGatewayReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalPublicGatewayReferenceAsProperty unmarshals an instance of PublicGatewayReference that is stored as a property
// within the specified map.
func UnmarshalPublicGatewayReferenceAsProperty(m map[string]interface{}, propertyName string) (result *PublicGatewayReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PublicGatewayReference'", propertyName)
			return
		}
		result, err = UnmarshalPublicGatewayReference(objMap)
	}
	return
}

// UnmarshalPublicGatewayReferenceSliceAsProperty unmarshals a slice of PublicGatewayReference instances that are stored as a property
// within the specified map.
func UnmarshalPublicGatewayReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []PublicGatewayReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PublicGatewayReference'", propertyName)
			return
		}
		slice, err = UnmarshalPublicGatewayReferenceSlice(vSlice)
	}
	return
}

// Region : Region struct
type Region struct {
	// The API endpoint for this region.
	Endpoint *string `json:"endpoint" validate:"required"`

	// The URL for this region.
	Href *string `json:"href" validate:"required"`

	// The name for this region.
	Name *string `json:"name" validate:"required"`

	// The availability status of this region.
	Status *string `json:"status" validate:"required"`
}

// Constants associated with the Region.Status property.
// The availability status of this region.
const (
	Region_Status_Available   = "available"
	Region_Status_Unavailable = "unavailable"
)

// UnmarshalRegion constructs an instance of Region from the specified map.
func UnmarshalRegion(m map[string]interface{}) (result *Region, err error) {
	obj := new(Region)
	obj.Endpoint, err = core.UnmarshalString(m, "endpoint")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Status, err = core.UnmarshalString(m, "status")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalRegionSlice unmarshals a slice of Region instances from the specified list of maps.
func UnmarshalRegionSlice(s []interface{}) (slice []Region, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Region'")
			return
		}
		obj, e := UnmarshalRegion(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalRegionAsProperty unmarshals an instance of Region that is stored as a property
// within the specified map.
func UnmarshalRegionAsProperty(m map[string]interface{}, propertyName string) (result *Region, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Region'", propertyName)
			return
		}
		result, err = UnmarshalRegion(objMap)
	}
	return
}

// UnmarshalRegionSliceAsProperty unmarshals a slice of Region instances that are stored as a property
// within the specified map.
func UnmarshalRegionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Region, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Region'", propertyName)
			return
		}
		slice, err = UnmarshalRegionSlice(vSlice)
	}
	return
}

// RegionCollection : RegionCollection struct
type RegionCollection struct {
	// Array of Region objects.
	Regions []Region `json:"regions" validate:"required"`
}

// UnmarshalRegionCollection constructs an instance of RegionCollection from the specified map.
func UnmarshalRegionCollection(m map[string]interface{}) (result *RegionCollection, err error) {
	obj := new(RegionCollection)
	obj.Regions, err = UnmarshalRegionSliceAsProperty(m, "regions")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalRegionCollectionSlice unmarshals a slice of RegionCollection instances from the specified list of maps.
func UnmarshalRegionCollectionSlice(s []interface{}) (slice []RegionCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'RegionCollection'")
			return
		}
		obj, e := UnmarshalRegionCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalRegionCollectionAsProperty unmarshals an instance of RegionCollection that is stored as a property
// within the specified map.
func UnmarshalRegionCollectionAsProperty(m map[string]interface{}, propertyName string) (result *RegionCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'RegionCollection'", propertyName)
			return
		}
		result, err = UnmarshalRegionCollection(objMap)
	}
	return
}

// UnmarshalRegionCollectionSliceAsProperty unmarshals a slice of RegionCollection instances that are stored as a property
// within the specified map.
func UnmarshalRegionCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []RegionCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'RegionCollection'", propertyName)
			return
		}
		slice, err = UnmarshalRegionCollectionSlice(vSlice)
	}
	return
}

// RegionReference : RegionReference struct
type RegionReference struct {
	// The URL for this region.
	Href *string `json:"href" validate:"required"`

	// The name for this region.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalRegionReference constructs an instance of RegionReference from the specified map.
func UnmarshalRegionReference(m map[string]interface{}) (result *RegionReference, err error) {
	obj := new(RegionReference)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalRegionReferenceSlice unmarshals a slice of RegionReference instances from the specified list of maps.
func UnmarshalRegionReferenceSlice(s []interface{}) (slice []RegionReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'RegionReference'")
			return
		}
		obj, e := UnmarshalRegionReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalRegionReferenceAsProperty unmarshals an instance of RegionReference that is stored as a property
// within the specified map.
func UnmarshalRegionReferenceAsProperty(m map[string]interface{}, propertyName string) (result *RegionReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'RegionReference'", propertyName)
			return
		}
		result, err = UnmarshalRegionReference(objMap)
	}
	return
}

// UnmarshalRegionReferenceSliceAsProperty unmarshals a slice of RegionReference instances that are stored as a property
// within the specified map.
func UnmarshalRegionReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []RegionReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'RegionReference'", propertyName)
			return
		}
		slice, err = UnmarshalRegionReferenceSlice(vSlice)
	}
	return
}

// ReleaseFloatingIpOptions : The ReleaseFloatingIp options.
type ReleaseFloatingIpOptions struct {
	// The floating IP identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReleaseFloatingIpOptions : Instantiate ReleaseFloatingIpOptions
func (*VpcV1) NewReleaseFloatingIpOptions(id string) *ReleaseFloatingIpOptions {
	return &ReleaseFloatingIpOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *ReleaseFloatingIpOptions) SetID(id string) *ReleaseFloatingIpOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ReleaseFloatingIpOptions) SetHeaders(param map[string]string) *ReleaseFloatingIpOptions {
	options.Headers = param
	return options
}

// ReserveFloatingIpOptions : The ReserveFloatingIp options.
type ReserveFloatingIpOptions struct {
	// The floating IP prototype object.
	FloatingIPPrototype FloatingIPPrototypeIntf `json:"FloatingIPPrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReserveFloatingIpOptions : Instantiate ReserveFloatingIpOptions
func (*VpcV1) NewReserveFloatingIpOptions(floatingIPPrototype FloatingIPPrototypeIntf) *ReserveFloatingIpOptions {
	return &ReserveFloatingIpOptions{
		FloatingIPPrototype: floatingIPPrototype,
	}
}

// SetFloatingIPPrototype : Allow user to set FloatingIPPrototype
func (options *ReserveFloatingIpOptions) SetFloatingIPPrototype(floatingIPPrototype FloatingIPPrototypeIntf) *ReserveFloatingIpOptions {
	options.FloatingIPPrototype = floatingIPPrototype
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ReserveFloatingIpOptions) SetHeaders(param map[string]string) *ReserveFloatingIpOptions {
	options.Headers = param
	return options
}

// ResourceGroupIdentity : The resource group to use. If unspecified, the account's [default resource
// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
// Models which "extend" this model:
// - ResourceGroupIdentityByID
type ResourceGroupIdentity struct {
	// The unique identifier for this resource group.
	ID *string `json:"id,omitempty"`
}

func (*ResourceGroupIdentity) isaResourceGroupIdentity() bool {
	return true
}

type ResourceGroupIdentityIntf interface {
	isaResourceGroupIdentity() bool
}

// UnmarshalResourceGroupIdentity constructs an instance of ResourceGroupIdentity from the specified map.
func UnmarshalResourceGroupIdentity(m map[string]interface{}) (result ResourceGroupIdentityIntf, err error) {
	obj := new(ResourceGroupIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalResourceGroupIdentitySlice unmarshals a slice of ResourceGroupIdentity instances from the specified list of maps.
func UnmarshalResourceGroupIdentitySlice(s []interface{}) (slice []ResourceGroupIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ResourceGroupIdentity'")
			return
		}
		obj, e := UnmarshalResourceGroupIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalResourceGroupIdentityAsProperty unmarshals an instance of ResourceGroupIdentity that is stored as a property
// within the specified map.
func UnmarshalResourceGroupIdentityAsProperty(m map[string]interface{}, propertyName string) (result ResourceGroupIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ResourceGroupIdentity'", propertyName)
			return
		}
		result, err = UnmarshalResourceGroupIdentity(objMap)
	}
	return
}

// UnmarshalResourceGroupIdentitySliceAsProperty unmarshals a slice of ResourceGroupIdentity instances that are stored as a property
// within the specified map.
func UnmarshalResourceGroupIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []ResourceGroupIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ResourceGroupIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalResourceGroupIdentitySlice(vSlice)
	}
	return
}

// ResourceGroupReference : ResourceGroupReference struct
type ResourceGroupReference struct {
	// The URL for this resource group.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this resource group.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this resource group.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalResourceGroupReference constructs an instance of ResourceGroupReference from the specified map.
func UnmarshalResourceGroupReference(m map[string]interface{}) (result *ResourceGroupReference, err error) {
	obj := new(ResourceGroupReference)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalResourceGroupReferenceSlice unmarshals a slice of ResourceGroupReference instances from the specified list of maps.
func UnmarshalResourceGroupReferenceSlice(s []interface{}) (slice []ResourceGroupReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ResourceGroupReference'")
			return
		}
		obj, e := UnmarshalResourceGroupReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalResourceGroupReferenceAsProperty unmarshals an instance of ResourceGroupReference that is stored as a property
// within the specified map.
func UnmarshalResourceGroupReferenceAsProperty(m map[string]interface{}, propertyName string) (result *ResourceGroupReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ResourceGroupReference'", propertyName)
			return
		}
		result, err = UnmarshalResourceGroupReference(objMap)
	}
	return
}

// UnmarshalResourceGroupReferenceSliceAsProperty unmarshals a slice of ResourceGroupReference instances that are stored as a property
// within the specified map.
func UnmarshalResourceGroupReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ResourceGroupReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ResourceGroupReference'", propertyName)
			return
		}
		slice, err = UnmarshalResourceGroupReferenceSlice(vSlice)
	}
	return
}

// Route : Route struct
type Route struct {
	// The date and time that the route was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination of the route.
	Destination *string `json:"destination" validate:"required"`

	// The URL for this route.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this route.
	ID *string `json:"id" validate:"required"`

	// The lifecycle state of the route.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The user-defined name for this route.
	Name *string `json:"name" validate:"required"`

	// The next hop that packets will be delivered to.
	NextHop RouteNextHopIntf `json:"next_hop" validate:"required"`

	// The zone the route applies to. (Traffic from subnets in this zone will be
	// subject to this route.).
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the Route.LifecycleState property.
// The lifecycle state of the route.
const (
	Route_LifecycleState_Deleted  = "deleted"
	Route_LifecycleState_Deleting = "deleting"
	Route_LifecycleState_Failed   = "failed"
	Route_LifecycleState_Pending  = "pending"
	Route_LifecycleState_Stable   = "stable"
	Route_LifecycleState_Updating = "updating"
	Route_LifecycleState_Waiting  = "waiting"
)

// UnmarshalRoute constructs an instance of Route from the specified map.
func UnmarshalRoute(m map[string]interface{}) (result *Route, err error) {
	obj := new(Route)
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Destination, err = core.UnmarshalString(m, "destination")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.LifecycleState, err = core.UnmarshalString(m, "lifecycle_state")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.NextHop, err = UnmarshalRouteNextHopAsProperty(m, "next_hop")
	if err != nil {
		return
	}
	obj.Zone, err = UnmarshalZoneReferenceAsProperty(m, "zone")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalRouteSlice unmarshals a slice of Route instances from the specified list of maps.
func UnmarshalRouteSlice(s []interface{}) (slice []Route, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Route'")
			return
		}
		obj, e := UnmarshalRoute(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalRouteAsProperty unmarshals an instance of Route that is stored as a property
// within the specified map.
func UnmarshalRouteAsProperty(m map[string]interface{}, propertyName string) (result *Route, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Route'", propertyName)
			return
		}
		result, err = UnmarshalRoute(objMap)
	}
	return
}

// UnmarshalRouteSliceAsProperty unmarshals a slice of Route instances that are stored as a property
// within the specified map.
func UnmarshalRouteSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Route, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Route'", propertyName)
			return
		}
		slice, err = UnmarshalRouteSlice(vSlice)
	}
	return
}

// RouteCollection : RouteCollection struct
type RouteCollection struct {
	// Collection of routes.
	Routes []Route `json:"routes" validate:"required"`
}

// UnmarshalRouteCollection constructs an instance of RouteCollection from the specified map.
func UnmarshalRouteCollection(m map[string]interface{}) (result *RouteCollection, err error) {
	obj := new(RouteCollection)
	obj.Routes, err = UnmarshalRouteSliceAsProperty(m, "routes")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalRouteCollectionSlice unmarshals a slice of RouteCollection instances from the specified list of maps.
func UnmarshalRouteCollectionSlice(s []interface{}) (slice []RouteCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'RouteCollection'")
			return
		}
		obj, e := UnmarshalRouteCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalRouteCollectionAsProperty unmarshals an instance of RouteCollection that is stored as a property
// within the specified map.
func UnmarshalRouteCollectionAsProperty(m map[string]interface{}, propertyName string) (result *RouteCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'RouteCollection'", propertyName)
			return
		}
		result, err = UnmarshalRouteCollection(objMap)
	}
	return
}

// UnmarshalRouteCollectionSliceAsProperty unmarshals a slice of RouteCollection instances that are stored as a property
// within the specified map.
func UnmarshalRouteCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []RouteCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'RouteCollection'", propertyName)
			return
		}
		slice, err = UnmarshalRouteCollectionSlice(vSlice)
	}
	return
}

// RouteNextHop : RouteNextHop struct
// Models which "extend" this model:
// - RouteNextHopIP
type RouteNextHop struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`
}

func (*RouteNextHop) isaRouteNextHop() bool {
	return true
}

type RouteNextHopIntf interface {
	isaRouteNextHop() bool
}

// UnmarshalRouteNextHop constructs an instance of RouteNextHop from the specified map.
func UnmarshalRouteNextHop(m map[string]interface{}) (result RouteNextHopIntf, err error) {
	obj := new(RouteNextHop)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalRouteNextHopSlice unmarshals a slice of RouteNextHop instances from the specified list of maps.
func UnmarshalRouteNextHopSlice(s []interface{}) (slice []RouteNextHopIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'RouteNextHop'")
			return
		}
		obj, e := UnmarshalRouteNextHop(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalRouteNextHopAsProperty unmarshals an instance of RouteNextHop that is stored as a property
// within the specified map.
func UnmarshalRouteNextHopAsProperty(m map[string]interface{}, propertyName string) (result RouteNextHopIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'RouteNextHop'", propertyName)
			return
		}
		result, err = UnmarshalRouteNextHop(objMap)
	}
	return
}

// UnmarshalRouteNextHopSliceAsProperty unmarshals a slice of RouteNextHop instances that are stored as a property
// within the specified map.
func UnmarshalRouteNextHopSliceAsProperty(m map[string]interface{}, propertyName string) (slice []RouteNextHopIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'RouteNextHop'", propertyName)
			return
		}
		slice, err = UnmarshalRouteNextHopSlice(vSlice)
	}
	return
}

// RouteNextHopPrototype : RouteNextHopPrototype struct
// Models which "extend" this model:
// - RouteNextHopPrototypeRouteNextHopIP
type RouteNextHopPrototype struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`
}

func (*RouteNextHopPrototype) isaRouteNextHopPrototype() bool {
	return true
}

type RouteNextHopPrototypeIntf interface {
	isaRouteNextHopPrototype() bool
}

// UnmarshalRouteNextHopPrototype constructs an instance of RouteNextHopPrototype from the specified map.
func UnmarshalRouteNextHopPrototype(m map[string]interface{}) (result RouteNextHopPrototypeIntf, err error) {
	obj := new(RouteNextHopPrototype)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalRouteNextHopPrototypeSlice unmarshals a slice of RouteNextHopPrototype instances from the specified list of maps.
func UnmarshalRouteNextHopPrototypeSlice(s []interface{}) (slice []RouteNextHopPrototypeIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'RouteNextHopPrototype'")
			return
		}
		obj, e := UnmarshalRouteNextHopPrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalRouteNextHopPrototypeAsProperty unmarshals an instance of RouteNextHopPrototype that is stored as a property
// within the specified map.
func UnmarshalRouteNextHopPrototypeAsProperty(m map[string]interface{}, propertyName string) (result RouteNextHopPrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'RouteNextHopPrototype'", propertyName)
			return
		}
		result, err = UnmarshalRouteNextHopPrototype(objMap)
	}
	return
}

// UnmarshalRouteNextHopPrototypeSliceAsProperty unmarshals a slice of RouteNextHopPrototype instances that are stored as a property
// within the specified map.
func UnmarshalRouteNextHopPrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []RouteNextHopPrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'RouteNextHopPrototype'", propertyName)
			return
		}
		slice, err = UnmarshalRouteNextHopPrototypeSlice(vSlice)
	}
	return
}

// SecurityGroup : SecurityGroup struct
type SecurityGroup struct {
	// The date and time that this security group was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The security group's CRN.
	Crn *string `json:"crn" validate:"required"`

	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name" validate:"required"`

	// Array of references to network interfaces.
	NetworkInterfaces []NetworkInterfaceReference `json:"network_interfaces" validate:"required"`

	// The resource group for this security group.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// Array of rules for this security group. If no rules exist, all traffic will be denied.
	Rules []SecurityGroupRuleIntf `json:"rules" validate:"required"`

	// The VPC this security group is a part of.
	Vpc *VPCReference `json:"vpc" validate:"required"`
}

// UnmarshalSecurityGroup constructs an instance of SecurityGroup from the specified map.
func UnmarshalSecurityGroup(m map[string]interface{}) (result *SecurityGroup, err error) {
	obj := new(SecurityGroup)
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.NetworkInterfaces, err = UnmarshalNetworkInterfaceReferenceSliceAsProperty(m, "network_interfaces")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupReferenceAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Rules, err = UnmarshalSecurityGroupRuleSliceAsProperty(m, "rules")
	if err != nil {
		return
	}
	obj.Vpc, err = UnmarshalVPCReferenceAsProperty(m, "vpc")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupSlice unmarshals a slice of SecurityGroup instances from the specified list of maps.
func UnmarshalSecurityGroupSlice(s []interface{}) (slice []SecurityGroup, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroup'")
			return
		}
		obj, e := UnmarshalSecurityGroup(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupAsProperty unmarshals an instance of SecurityGroup that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroup, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroup'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroup(objMap)
	}
	return
}

// UnmarshalSecurityGroupSliceAsProperty unmarshals a slice of SecurityGroup instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroup, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroup'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupSlice(vSlice)
	}
	return
}

// SecurityGroupCollection : SecurityGroupCollection struct
type SecurityGroupCollection struct {
	// A reference to the first page of resources.
	First *SecurityGroupCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *SecurityGroupCollectionNext `json:"next,omitempty"`

	// Collection of security groups.
	SecurityGroups []SecurityGroup `json:"security_groups" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalSecurityGroupCollection constructs an instance of SecurityGroupCollection from the specified map.
func UnmarshalSecurityGroupCollection(m map[string]interface{}) (result *SecurityGroupCollection, err error) {
	obj := new(SecurityGroupCollection)
	obj.First, err = UnmarshalSecurityGroupCollectionFirstAsProperty(m, "first")
	if err != nil {
		return
	}
	obj.Limit, err = core.UnmarshalInt64(m, "limit")
	if err != nil {
		return
	}
	obj.Next, err = UnmarshalSecurityGroupCollectionNextAsProperty(m, "next")
	if err != nil {
		return
	}
	obj.SecurityGroups, err = UnmarshalSecurityGroupSliceAsProperty(m, "security_groups")
	if err != nil {
		return
	}
	obj.TotalCount, err = core.UnmarshalInt64(m, "total_count")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupCollectionSlice unmarshals a slice of SecurityGroupCollection instances from the specified list of maps.
func UnmarshalSecurityGroupCollectionSlice(s []interface{}) (slice []SecurityGroupCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupCollection'")
			return
		}
		obj, e := UnmarshalSecurityGroupCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupCollectionAsProperty unmarshals an instance of SecurityGroupCollection that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupCollectionAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupCollection'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupCollection(objMap)
	}
	return
}

// UnmarshalSecurityGroupCollectionSliceAsProperty unmarshals a slice of SecurityGroupCollection instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupCollection'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupCollectionSlice(vSlice)
	}
	return
}

// SecurityGroupCollectionFirst : A reference to the first page of resources.
type SecurityGroupCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalSecurityGroupCollectionFirst constructs an instance of SecurityGroupCollectionFirst from the specified map.
func UnmarshalSecurityGroupCollectionFirst(m map[string]interface{}) (result *SecurityGroupCollectionFirst, err error) {
	obj := new(SecurityGroupCollectionFirst)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupCollectionFirstSlice unmarshals a slice of SecurityGroupCollectionFirst instances from the specified list of maps.
func UnmarshalSecurityGroupCollectionFirstSlice(s []interface{}) (slice []SecurityGroupCollectionFirst, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupCollectionFirst'")
			return
		}
		obj, e := UnmarshalSecurityGroupCollectionFirst(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupCollectionFirstAsProperty unmarshals an instance of SecurityGroupCollectionFirst that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupCollectionFirstAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupCollectionFirst'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupCollectionFirst(objMap)
	}
	return
}

// UnmarshalSecurityGroupCollectionFirstSliceAsProperty unmarshals a slice of SecurityGroupCollectionFirst instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupCollectionFirstSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupCollectionFirst'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupCollectionFirstSlice(vSlice)
	}
	return
}

// SecurityGroupCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type SecurityGroupCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalSecurityGroupCollectionNext constructs an instance of SecurityGroupCollectionNext from the specified map.
func UnmarshalSecurityGroupCollectionNext(m map[string]interface{}) (result *SecurityGroupCollectionNext, err error) {
	obj := new(SecurityGroupCollectionNext)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupCollectionNextSlice unmarshals a slice of SecurityGroupCollectionNext instances from the specified list of maps.
func UnmarshalSecurityGroupCollectionNextSlice(s []interface{}) (slice []SecurityGroupCollectionNext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupCollectionNext'")
			return
		}
		obj, e := UnmarshalSecurityGroupCollectionNext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupCollectionNextAsProperty unmarshals an instance of SecurityGroupCollectionNext that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupCollectionNextAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupCollectionNext'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupCollectionNext(objMap)
	}
	return
}

// UnmarshalSecurityGroupCollectionNextSliceAsProperty unmarshals a slice of SecurityGroupCollectionNext instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupCollectionNextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupCollectionNext'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupCollectionNextSlice(vSlice)
	}
	return
}

// SecurityGroupIdentity : Identifies a security group by a unique property.
// Models which "extend" this model:
// - SecurityGroupIdentityByID
// - SecurityGroupIdentityByCRN
// - SecurityGroupIdentityByHref
type SecurityGroupIdentity struct {
	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	Crn *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupIdentity) isaSecurityGroupIdentity() bool {
	return true
}

type SecurityGroupIdentityIntf interface {
	isaSecurityGroupIdentity() bool
}

// UnmarshalSecurityGroupIdentity constructs an instance of SecurityGroupIdentity from the specified map.
func UnmarshalSecurityGroupIdentity(m map[string]interface{}) (result SecurityGroupIdentityIntf, err error) {
	obj := new(SecurityGroupIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupIdentitySlice unmarshals a slice of SecurityGroupIdentity instances from the specified list of maps.
func UnmarshalSecurityGroupIdentitySlice(s []interface{}) (slice []SecurityGroupIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupIdentity'")
			return
		}
		obj, e := UnmarshalSecurityGroupIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalSecurityGroupIdentityAsProperty unmarshals an instance of SecurityGroupIdentity that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupIdentityAsProperty(m map[string]interface{}, propertyName string) (result SecurityGroupIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupIdentity'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupIdentity(objMap)
	}
	return
}

// UnmarshalSecurityGroupIdentitySliceAsProperty unmarshals a slice of SecurityGroupIdentity instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupIdentitySlice(vSlice)
	}
	return
}

// SecurityGroupReference : SecurityGroupReference struct
type SecurityGroupReference struct {
	// The security group's CRN.
	Crn *string `json:"crn" validate:"required"`

	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalSecurityGroupReference constructs an instance of SecurityGroupReference from the specified map.
func UnmarshalSecurityGroupReference(m map[string]interface{}) (result *SecurityGroupReference, err error) {
	obj := new(SecurityGroupReference)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupReferenceSlice unmarshals a slice of SecurityGroupReference instances from the specified list of maps.
func UnmarshalSecurityGroupReferenceSlice(s []interface{}) (slice []SecurityGroupReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupReference'")
			return
		}
		obj, e := UnmarshalSecurityGroupReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupReferenceAsProperty unmarshals an instance of SecurityGroupReference that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupReferenceAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupReference'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupReference(objMap)
	}
	return
}

// UnmarshalSecurityGroupReferenceSliceAsProperty unmarshals a slice of SecurityGroupReference instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupReference'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupReferenceSlice(vSlice)
	}
	return
}

// SecurityGroupRule : SecurityGroupRule struct
// Models which "extend" this model:
// - SecurityGroupRuleProtocolAll
// - SecurityGroupRuleProtocolICMP
// - SecurityGroupRuleProtocolTCPUDP
type SecurityGroupRule struct {
	// The direction of traffic to enforce, either `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this security group rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group rule.
	ID *string `json:"id" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
	// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
	// interfaces) in that group matching this IP version.
	IpVersion *string `json:"ip_version,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The IP addresses or security groups from which this rule allows traffic (or to which,
	// for outbound rules). Can be specified as an IP address, a CIDR block, or a security
	// group. A CIDR block of `0.0.0.0/0` allows traffic from any source (or to any source,
	// for outbound rules).
	Remote SecurityGroupRuleRemoteIntf `json:"remote" validate:"required"`

	// The ICMP traffic code to allow.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow.
	Type *int64 `json:"type,omitempty"`

	// The inclusive upper bound of TCP/UDP port range.
	PortMax *int64 `json:"port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP port range.
	PortMin *int64 `json:"port_min,omitempty"`
}

// Constants associated with the SecurityGroupRule.Direction property.
// The direction of traffic to enforce, either `inbound` or `outbound`.
const (
	SecurityGroupRule_Direction_Inbound  = "inbound"
	SecurityGroupRule_Direction_Outbound = "outbound"
)

// Constants associated with the SecurityGroupRule.IpVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
// interfaces) in that group matching this IP version.
const (
	SecurityGroupRule_IpVersion_Ipv4 = "ipv4"
)

// Constants associated with the SecurityGroupRule.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRule_Protocol_All  = "all"
	SecurityGroupRule_Protocol_Icmp = "icmp"
	SecurityGroupRule_Protocol_Tcp  = "tcp"
	SecurityGroupRule_Protocol_Udp  = "udp"
)

func (*SecurityGroupRule) isaSecurityGroupRule() bool {
	return true
}

type SecurityGroupRuleIntf interface {
	isaSecurityGroupRule() bool
}

// UnmarshalSecurityGroupRule constructs an instance of SecurityGroupRule from the specified map.
func UnmarshalSecurityGroupRule(m map[string]interface{}) (result SecurityGroupRuleIntf, err error) {
	discValue, err := core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	if discValue == nil {
		err = fmt.Errorf("discriminator property 'protocol' not found in JSON object")
		return
	}
	if *discValue == "all" {
		result, err = UnmarshalSecurityGroupRuleProtocolAll(m)
	} else if *discValue == "icmp" {
		result, err = UnmarshalSecurityGroupRuleProtocolICMP(m)
	} else if *discValue == "tcp" {
		result, err = UnmarshalSecurityGroupRuleProtocolTCPUDP(m)
	} else if *discValue == "udp" {
		result, err = UnmarshalSecurityGroupRuleProtocolTCPUDP(m)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'protocol': %s", *discValue)
	}
	return
}

// UnmarshalSecurityGroupRuleSlice unmarshals a slice of SecurityGroupRule instances from the specified list of maps.
func UnmarshalSecurityGroupRuleSlice(s []interface{}) (slice []SecurityGroupRuleIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRule'")
			return
		}
		obj, e := UnmarshalSecurityGroupRule(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalSecurityGroupRuleAsProperty unmarshals an instance of SecurityGroupRule that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRuleAsProperty(m map[string]interface{}, propertyName string) (result SecurityGroupRuleIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRule'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRule(objMap)
	}
	return
}

// UnmarshalSecurityGroupRuleSliceAsProperty unmarshals a slice of SecurityGroupRule instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRuleSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRuleIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRule'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRuleSlice(vSlice)
	}
	return
}

// SecurityGroupRuleCollection : Collection of rules in a security group.
type SecurityGroupRuleCollection struct {
	// Array of rules.
	Rules []SecurityGroupRuleIntf `json:"rules" validate:"required"`
}

// UnmarshalSecurityGroupRuleCollection constructs an instance of SecurityGroupRuleCollection from the specified map.
func UnmarshalSecurityGroupRuleCollection(m map[string]interface{}) (result *SecurityGroupRuleCollection, err error) {
	obj := new(SecurityGroupRuleCollection)
	obj.Rules, err = UnmarshalSecurityGroupRuleSliceAsProperty(m, "rules")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRuleCollectionSlice unmarshals a slice of SecurityGroupRuleCollection instances from the specified list of maps.
func UnmarshalSecurityGroupRuleCollectionSlice(s []interface{}) (slice []SecurityGroupRuleCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRuleCollection'")
			return
		}
		obj, e := UnmarshalSecurityGroupRuleCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRuleCollectionAsProperty unmarshals an instance of SecurityGroupRuleCollection that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRuleCollectionAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRuleCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRuleCollection'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRuleCollection(objMap)
	}
	return
}

// UnmarshalSecurityGroupRuleCollectionSliceAsProperty unmarshals a slice of SecurityGroupRuleCollection instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRuleCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRuleCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRuleCollection'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRuleCollectionSlice(vSlice)
	}
	return
}

// SecurityGroupRulePatchRemote : The IP addresses or security groups from which this rule will allow traffic (or to which, for outbound rules). Can be
// specified as an IP address, a CIDR block, or a security group. A CIDR block of `0.0.0.0/0` will allow traffic from
// any source (or to any source, for outbound rules).
// Models which "extend" this model:
// - SecurityGroupRulePatchRemoteIP
// - SecurityGroupRulePatchRemoteCIDR
// - SecurityGroupRulePatchRemoteSecurityGroupIdentity
type SecurityGroupRulePatchRemote struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CidrBlock *string `json:"cidr_block,omitempty"`

	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	Crn *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupRulePatchRemote) isaSecurityGroupRulePatchRemote() bool {
	return true
}

type SecurityGroupRulePatchRemoteIntf interface {
	isaSecurityGroupRulePatchRemote() bool
}

// UnmarshalSecurityGroupRulePatchRemote constructs an instance of SecurityGroupRulePatchRemote from the specified map.
func UnmarshalSecurityGroupRulePatchRemote(m map[string]interface{}) (result SecurityGroupRulePatchRemoteIntf, err error) {
	obj := new(SecurityGroupRulePatchRemote)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	obj.CidrBlock, err = core.UnmarshalString(m, "cidr_block")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePatchRemoteSlice unmarshals a slice of SecurityGroupRulePatchRemote instances from the specified list of maps.
func UnmarshalSecurityGroupRulePatchRemoteSlice(s []interface{}) (slice []SecurityGroupRulePatchRemoteIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePatchRemote'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePatchRemote(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalSecurityGroupRulePatchRemoteAsProperty unmarshals an instance of SecurityGroupRulePatchRemote that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePatchRemoteAsProperty(m map[string]interface{}, propertyName string) (result SecurityGroupRulePatchRemoteIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePatchRemote'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePatchRemote(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePatchRemoteSliceAsProperty unmarshals a slice of SecurityGroupRulePatchRemote instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePatchRemoteSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePatchRemoteIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePatchRemote'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePatchRemoteSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototype : SecurityGroupRulePrototype struct
// Models which "extend" this model:
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP
type SecurityGroupRulePrototype struct {
	// The direction of traffic to enforce, either `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
	// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
	// interfaces) in that group matching this IP version.
	IpVersion *string `json:"ip_version,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The IP addresses or security groups from which this rule will allow traffic (or to
	// which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
	// security group. If omitted, a CIDR block of `0.0.0.0/0` will be used to allow traffic
	// from any source (or to any source, for outbound rules).
	Remote SecurityGroupRulePrototypeRemoteIntf `json:"remote,omitempty"`

	// The ICMP traffic code to allow.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow.
	Type *int64 `json:"type,omitempty"`

	// The inclusive upper bound of TCP/UDP port range.
	PortMax *int64 `json:"port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP port range.
	PortMin *int64 `json:"port_min,omitempty"`
}

// Constants associated with the SecurityGroupRulePrototype.Direction property.
// The direction of traffic to enforce, either `inbound` or `outbound`.
const (
	SecurityGroupRulePrototype_Direction_Inbound  = "inbound"
	SecurityGroupRulePrototype_Direction_Outbound = "outbound"
)

// Constants associated with the SecurityGroupRulePrototype.IpVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
// interfaces) in that group matching this IP version.
const (
	SecurityGroupRulePrototype_IpVersion_Ipv4 = "ipv4"
)

// Constants associated with the SecurityGroupRulePrototype.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRulePrototype_Protocol_All  = "all"
	SecurityGroupRulePrototype_Protocol_Icmp = "icmp"
	SecurityGroupRulePrototype_Protocol_Tcp  = "tcp"
	SecurityGroupRulePrototype_Protocol_Udp  = "udp"
)

func (*SecurityGroupRulePrototype) isaSecurityGroupRulePrototype() bool {
	return true
}

type SecurityGroupRulePrototypeIntf interface {
	isaSecurityGroupRulePrototype() bool
}

// UnmarshalSecurityGroupRulePrototype constructs an instance of SecurityGroupRulePrototype from the specified map.
func UnmarshalSecurityGroupRulePrototype(m map[string]interface{}) (result SecurityGroupRulePrototypeIntf, err error) {
	discValue, err := core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	if discValue == nil {
		err = fmt.Errorf("discriminator property 'protocol' not found in JSON object")
		return
	}
	if *discValue == "all" {
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAll(m)
	} else if *discValue == "icmp" {
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP(m)
	} else if *discValue == "tcp" {
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP(m)
	} else if *discValue == "udp" {
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP(m)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'protocol': %s", *discValue)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSlice unmarshals a slice of SecurityGroupRulePrototype instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSlice(s []interface{}) (slice []SecurityGroupRulePrototypeIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototype'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeAsProperty unmarshals an instance of SecurityGroupRulePrototype that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeAsProperty(m map[string]interface{}, propertyName string) (result SecurityGroupRulePrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototype'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototype(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSliceAsProperty unmarshals a slice of SecurityGroupRulePrototype instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototype'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeRemote : The IP addresses or security groups from which this rule will allow traffic (or to which, for outbound rules). Can be
// specified as an IP address, a CIDR block, or a security group. If omitted, a CIDR block of `0.0.0.0/0` will be used
// to allow traffic from any source (or to any source, for outbound rules).
// Models which "extend" this model:
// - SecurityGroupRulePrototypeRemoteIP
// - SecurityGroupRulePrototypeRemoteCIDR
// - SecurityGroupRulePrototypeRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeRemote struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CidrBlock *string `json:"cidr_block,omitempty"`

	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	Crn *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupRulePrototypeRemote) isaSecurityGroupRulePrototypeRemote() bool {
	return true
}

type SecurityGroupRulePrototypeRemoteIntf interface {
	isaSecurityGroupRulePrototypeRemote() bool
}

// UnmarshalSecurityGroupRulePrototypeRemote constructs an instance of SecurityGroupRulePrototypeRemote from the specified map.
func UnmarshalSecurityGroupRulePrototypeRemote(m map[string]interface{}) (result SecurityGroupRulePrototypeRemoteIntf, err error) {
	obj := new(SecurityGroupRulePrototypeRemote)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	obj.CidrBlock, err = core.UnmarshalString(m, "cidr_block")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteSlice unmarshals a slice of SecurityGroupRulePrototypeRemote instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeRemoteSlice(s []interface{}) (slice []SecurityGroupRulePrototypeRemoteIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeRemote'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeRemote(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteAsProperty unmarshals an instance of SecurityGroupRulePrototypeRemote that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteAsProperty(m map[string]interface{}, propertyName string) (result SecurityGroupRulePrototypeRemoteIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeRemote'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeRemote(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeRemote instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeRemoteIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeRemote'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeRemoteSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote : The IP addresses or security groups from which this rule will allow traffic (or to which, for outbound rules). Can be
// specified as an IP address, a CIDR block, or a security group. If omitted, a CIDR block of `0.0.0.0/0` will be used
// to allow traffic from any source (or to any source, for outbound rules).
// Models which "extend" this model:
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CidrBlock *string `json:"cidr_block,omitempty"`

	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	Crn *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote() bool {
	return true
}

type SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIntf interface {
	isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote() bool
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote(m map[string]interface{}) (result SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIntf, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	obj.CidrBlock, err = core.UnmarshalString(m, "cidr_block")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteAsProperty(m map[string]interface{}, propertyName string) (result SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote : The IP addresses or security groups from which this rule will allow traffic (or to which, for outbound rules). Can be
// specified as an IP address, a CIDR block, or a security group. If omitted, a CIDR block of `0.0.0.0/0` will be used
// to allow traffic from any source (or to any source, for outbound rules).
// Models which "extend" this model:
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CidrBlock *string `json:"cidr_block,omitempty"`

	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	Crn *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote() bool {
	return true
}

type SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIntf interface {
	isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote() bool
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote(m map[string]interface{}) (result SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIntf, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	obj.CidrBlock, err = core.UnmarshalString(m, "cidr_block")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteAsProperty(m map[string]interface{}, propertyName string) (result SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote : The IP addresses or security groups from which this rule will allow traffic (or to which, for outbound rules). Can be
// specified as an IP address, a CIDR block, or a security group. If omitted, a CIDR block of `0.0.0.0/0` will be used
// to allow traffic from any source (or to any source, for outbound rules).
// Models which "extend" this model:
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CidrBlock *string `json:"cidr_block,omitempty"`

	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	Crn *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote() bool {
	return true
}

type SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIntf interface {
	isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote() bool
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote(m map[string]interface{}) (result SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIntf, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	obj.CidrBlock, err = core.UnmarshalString(m, "cidr_block")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteAsProperty(m map[string]interface{}, propertyName string) (result SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSlice(vSlice)
	}
	return
}

// SecurityGroupRuleRemote : The IP addresses or security groups from which this rule allows traffic (or to which, for outbound rules). Can be
// specified as an IP address, a CIDR block, or a security group. A CIDR block of `0.0.0.0/0` allows traffic from any
// source (or to any source, for outbound rules).
// Models which "extend" this model:
// - SecurityGroupRuleRemoteIP
// - SecurityGroupRuleRemoteCIDR
// - SecurityGroupRuleRemoteSecurityGroupReference
type SecurityGroupRuleRemote struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CidrBlock *string `json:"cidr_block,omitempty"`

	// The security group's CRN.
	Crn *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name,omitempty"`
}

func (*SecurityGroupRuleRemote) isaSecurityGroupRuleRemote() bool {
	return true
}

type SecurityGroupRuleRemoteIntf interface {
	isaSecurityGroupRuleRemote() bool
}

// UnmarshalSecurityGroupRuleRemote constructs an instance of SecurityGroupRuleRemote from the specified map.
func UnmarshalSecurityGroupRuleRemote(m map[string]interface{}) (result SecurityGroupRuleRemoteIntf, err error) {
	obj := new(SecurityGroupRuleRemote)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	obj.CidrBlock, err = core.UnmarshalString(m, "cidr_block")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRuleRemoteSlice unmarshals a slice of SecurityGroupRuleRemote instances from the specified list of maps.
func UnmarshalSecurityGroupRuleRemoteSlice(s []interface{}) (slice []SecurityGroupRuleRemoteIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRuleRemote'")
			return
		}
		obj, e := UnmarshalSecurityGroupRuleRemote(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalSecurityGroupRuleRemoteAsProperty unmarshals an instance of SecurityGroupRuleRemote that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRuleRemoteAsProperty(m map[string]interface{}, propertyName string) (result SecurityGroupRuleRemoteIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRuleRemote'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRuleRemote(objMap)
	}
	return
}

// UnmarshalSecurityGroupRuleRemoteSliceAsProperty unmarshals a slice of SecurityGroupRuleRemote instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRuleRemoteSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRuleRemoteIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRuleRemote'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRuleRemoteSlice(vSlice)
	}
	return
}

// SetSubnetNetworkAclBindingOptions : The SetSubnetNetworkAclBinding options.
type SetSubnetNetworkAclBindingOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required"`

	// The network ACL identity.
	NetworkACLIdentity NetworkACLIdentityIntf `json:"NetworkACLIdentity" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewSetSubnetNetworkAclBindingOptions : Instantiate SetSubnetNetworkAclBindingOptions
func (*VpcV1) NewSetSubnetNetworkAclBindingOptions(id string, networkACLIdentity NetworkACLIdentityIntf) *SetSubnetNetworkAclBindingOptions {
	return &SetSubnetNetworkAclBindingOptions{
		ID:                 core.StringPtr(id),
		NetworkACLIdentity: networkACLIdentity,
	}
}

// SetID : Allow user to set ID
func (options *SetSubnetNetworkAclBindingOptions) SetID(id string) *SetSubnetNetworkAclBindingOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetNetworkACLIdentity : Allow user to set NetworkACLIdentity
func (options *SetSubnetNetworkAclBindingOptions) SetNetworkACLIdentity(networkACLIdentity NetworkACLIdentityIntf) *SetSubnetNetworkAclBindingOptions {
	options.NetworkACLIdentity = networkACLIdentity
	return options
}

// SetHeaders : Allow user to set Headers
func (options *SetSubnetNetworkAclBindingOptions) SetHeaders(param map[string]string) *SetSubnetNetworkAclBindingOptions {
	options.Headers = param
	return options
}

// SetSubnetPublicGatewayBindingOptions : The SetSubnetPublicGatewayBinding options.
type SetSubnetPublicGatewayBindingOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required"`

	// The public gateway identity.
	PublicGatewayIdentity PublicGatewayIdentityIntf `json:"PublicGatewayIdentity" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewSetSubnetPublicGatewayBindingOptions : Instantiate SetSubnetPublicGatewayBindingOptions
func (*VpcV1) NewSetSubnetPublicGatewayBindingOptions(id string, publicGatewayIdentity PublicGatewayIdentityIntf) *SetSubnetPublicGatewayBindingOptions {
	return &SetSubnetPublicGatewayBindingOptions{
		ID:                    core.StringPtr(id),
		PublicGatewayIdentity: publicGatewayIdentity,
	}
}

// SetID : Allow user to set ID
func (options *SetSubnetPublicGatewayBindingOptions) SetID(id string) *SetSubnetPublicGatewayBindingOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetPublicGatewayIdentity : Allow user to set PublicGatewayIdentity
func (options *SetSubnetPublicGatewayBindingOptions) SetPublicGatewayIdentity(publicGatewayIdentity PublicGatewayIdentityIntf) *SetSubnetPublicGatewayBindingOptions {
	options.PublicGatewayIdentity = publicGatewayIdentity
	return options
}

// SetHeaders : Allow user to set Headers
func (options *SetSubnetPublicGatewayBindingOptions) SetHeaders(param map[string]string) *SetSubnetPublicGatewayBindingOptions {
	options.Headers = param
	return options
}

// SetVpnGatewayConnectionLocalCidrOptions : The SetVpnGatewayConnectionLocalCidr options.
type SetVpnGatewayConnectionLocalCidrOptions struct {
	// The VPN gateway identifier.
	VpnGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// The prefix address part of the CIDR.
	PrefixAddress *string `json:"prefix_address" validate:"required"`

	// The prefix length part of the CIDR.
	PrefixLength *string `json:"prefix_length" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewSetVpnGatewayConnectionLocalCidrOptions : Instantiate SetVpnGatewayConnectionLocalCidrOptions
func (*VpcV1) NewSetVpnGatewayConnectionLocalCidrOptions(vpnGatewayID string, id string, prefixAddress string, prefixLength string) *SetVpnGatewayConnectionLocalCidrOptions {
	return &SetVpnGatewayConnectionLocalCidrOptions{
		VpnGatewayID:  core.StringPtr(vpnGatewayID),
		ID:            core.StringPtr(id),
		PrefixAddress: core.StringPtr(prefixAddress),
		PrefixLength:  core.StringPtr(prefixLength),
	}
}

// SetVpnGatewayID : Allow user to set VpnGatewayID
func (options *SetVpnGatewayConnectionLocalCidrOptions) SetVpnGatewayID(vpnGatewayID string) *SetVpnGatewayConnectionLocalCidrOptions {
	options.VpnGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *SetVpnGatewayConnectionLocalCidrOptions) SetID(id string) *SetVpnGatewayConnectionLocalCidrOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetPrefixAddress : Allow user to set PrefixAddress
func (options *SetVpnGatewayConnectionLocalCidrOptions) SetPrefixAddress(prefixAddress string) *SetVpnGatewayConnectionLocalCidrOptions {
	options.PrefixAddress = core.StringPtr(prefixAddress)
	return options
}

// SetPrefixLength : Allow user to set PrefixLength
func (options *SetVpnGatewayConnectionLocalCidrOptions) SetPrefixLength(prefixLength string) *SetVpnGatewayConnectionLocalCidrOptions {
	options.PrefixLength = core.StringPtr(prefixLength)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *SetVpnGatewayConnectionLocalCidrOptions) SetHeaders(param map[string]string) *SetVpnGatewayConnectionLocalCidrOptions {
	options.Headers = param
	return options
}

// SetVpnGatewayConnectionPeerCidrOptions : The SetVpnGatewayConnectionPeerCidr options.
type SetVpnGatewayConnectionPeerCidrOptions struct {
	// The VPN gateway identifier.
	VpnGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// The prefix address part of the CIDR.
	PrefixAddress *string `json:"prefix_address" validate:"required"`

	// The prefix length part of the CIDR.
	PrefixLength *string `json:"prefix_length" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewSetVpnGatewayConnectionPeerCidrOptions : Instantiate SetVpnGatewayConnectionPeerCidrOptions
func (*VpcV1) NewSetVpnGatewayConnectionPeerCidrOptions(vpnGatewayID string, id string, prefixAddress string, prefixLength string) *SetVpnGatewayConnectionPeerCidrOptions {
	return &SetVpnGatewayConnectionPeerCidrOptions{
		VpnGatewayID:  core.StringPtr(vpnGatewayID),
		ID:            core.StringPtr(id),
		PrefixAddress: core.StringPtr(prefixAddress),
		PrefixLength:  core.StringPtr(prefixLength),
	}
}

// SetVpnGatewayID : Allow user to set VpnGatewayID
func (options *SetVpnGatewayConnectionPeerCidrOptions) SetVpnGatewayID(vpnGatewayID string) *SetVpnGatewayConnectionPeerCidrOptions {
	options.VpnGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *SetVpnGatewayConnectionPeerCidrOptions) SetID(id string) *SetVpnGatewayConnectionPeerCidrOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetPrefixAddress : Allow user to set PrefixAddress
func (options *SetVpnGatewayConnectionPeerCidrOptions) SetPrefixAddress(prefixAddress string) *SetVpnGatewayConnectionPeerCidrOptions {
	options.PrefixAddress = core.StringPtr(prefixAddress)
	return options
}

// SetPrefixLength : Allow user to set PrefixLength
func (options *SetVpnGatewayConnectionPeerCidrOptions) SetPrefixLength(prefixLength string) *SetVpnGatewayConnectionPeerCidrOptions {
	options.PrefixLength = core.StringPtr(prefixLength)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *SetVpnGatewayConnectionPeerCidrOptions) SetHeaders(param map[string]string) *SetVpnGatewayConnectionPeerCidrOptions {
	options.Headers = param
	return options
}

// Subnet : Subnet struct
type Subnet struct {
	// The number of IPv4 addresses in this subnet that are not in-use, and have not been reserved by the user or the
	// provider.
	AvailableIpv4AddressCount *int64 `json:"available_ipv4_address_count" validate:"required"`

	// The date and time that the subnet was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this subnet.
	Crn *string `json:"crn" validate:"required"`

	// The URL for this subnet.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this subnet.
	ID *string `json:"id" validate:"required"`

	// The IP version(s) supported by this subnet.
	IpVersion *string `json:"ip_version" validate:"required"`

	// The IPv4 range of the subnet, expressed in CIDR format.
	Ipv4CidrBlock *string `json:"ipv4_cidr_block,omitempty"`

	// The user-defined name for this subnet.
	Name *string `json:"name" validate:"required"`

	// The network ACL for this subnet.
	NetworkAcl *NetworkACLReference `json:"network_acl" validate:"required"`

	// The public gateway to handle internet bound traffic for this subnet.
	PublicGateway *PublicGatewayReference `json:"public_gateway,omitempty"`

	// The resource group for this subnet.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The status of the subnet.
	Status *string `json:"status" validate:"required"`

	// The total number of IPv4 addresses in this subnet.
	//
	// Note: This is calculated as 2<sup>(32 âˆ’ prefix length)</sup>. For example, the prefix length `/24` gives:<br>
	// 2<sup>(32 âˆ’ 24)</sup> = 2<sup>8</sup> = 256 addresses.
	TotalIpv4AddressCount *int64 `json:"total_ipv4_address_count" validate:"required"`

	// The VPC this subnet is a part of.
	Vpc *VPCReference `json:"vpc" validate:"required"`

	// The zone this subnet resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the Subnet.IpVersion property.
// The IP version(s) supported by this subnet.
const (
	Subnet_IpVersion_Both = "both"
	Subnet_IpVersion_Ipv4 = "ipv4"
	Subnet_IpVersion_Ipv6 = "ipv6"
)

// Constants associated with the Subnet.Status property.
// The status of the subnet.
const (
	Subnet_Status_Available = "available"
	Subnet_Status_Deleting  = "deleting"
	Subnet_Status_Failed    = "failed"
	Subnet_Status_Pending   = "pending"
)

// UnmarshalSubnet constructs an instance of Subnet from the specified map.
func UnmarshalSubnet(m map[string]interface{}) (result *Subnet, err error) {
	obj := new(Subnet)
	obj.AvailableIpv4AddressCount, err = core.UnmarshalInt64(m, "available_ipv4_address_count")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Ipv4CidrBlock, err = core.UnmarshalString(m, "ipv4_cidr_block")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.NetworkAcl, err = UnmarshalNetworkACLReferenceAsProperty(m, "network_acl")
	if err != nil {
		return
	}
	obj.PublicGateway, err = UnmarshalPublicGatewayReferenceAsProperty(m, "public_gateway")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupReferenceAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Status, err = core.UnmarshalString(m, "status")
	if err != nil {
		return
	}
	obj.TotalIpv4AddressCount, err = core.UnmarshalInt64(m, "total_ipv4_address_count")
	if err != nil {
		return
	}
	obj.Vpc, err = UnmarshalVPCReferenceAsProperty(m, "vpc")
	if err != nil {
		return
	}
	obj.Zone, err = UnmarshalZoneReferenceAsProperty(m, "zone")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSubnetSlice unmarshals a slice of Subnet instances from the specified list of maps.
func UnmarshalSubnetSlice(s []interface{}) (slice []Subnet, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Subnet'")
			return
		}
		obj, e := UnmarshalSubnet(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSubnetAsProperty unmarshals an instance of Subnet that is stored as a property
// within the specified map.
func UnmarshalSubnetAsProperty(m map[string]interface{}, propertyName string) (result *Subnet, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Subnet'", propertyName)
			return
		}
		result, err = UnmarshalSubnet(objMap)
	}
	return
}

// UnmarshalSubnetSliceAsProperty unmarshals a slice of Subnet instances that are stored as a property
// within the specified map.
func UnmarshalSubnetSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Subnet, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Subnet'", propertyName)
			return
		}
		slice, err = UnmarshalSubnetSlice(vSlice)
	}
	return
}

// SubnetCollection : SubnetCollection struct
type SubnetCollection struct {
	// A reference to the first page of resources.
	First *SubnetCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *SubnetCollectionNext `json:"next,omitempty"`

	// Collection of subnets.
	Subnets []Subnet `json:"subnets" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalSubnetCollection constructs an instance of SubnetCollection from the specified map.
func UnmarshalSubnetCollection(m map[string]interface{}) (result *SubnetCollection, err error) {
	obj := new(SubnetCollection)
	obj.First, err = UnmarshalSubnetCollectionFirstAsProperty(m, "first")
	if err != nil {
		return
	}
	obj.Limit, err = core.UnmarshalInt64(m, "limit")
	if err != nil {
		return
	}
	obj.Next, err = UnmarshalSubnetCollectionNextAsProperty(m, "next")
	if err != nil {
		return
	}
	obj.Subnets, err = UnmarshalSubnetSliceAsProperty(m, "subnets")
	if err != nil {
		return
	}
	obj.TotalCount, err = core.UnmarshalInt64(m, "total_count")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSubnetCollectionSlice unmarshals a slice of SubnetCollection instances from the specified list of maps.
func UnmarshalSubnetCollectionSlice(s []interface{}) (slice []SubnetCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SubnetCollection'")
			return
		}
		obj, e := UnmarshalSubnetCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSubnetCollectionAsProperty unmarshals an instance of SubnetCollection that is stored as a property
// within the specified map.
func UnmarshalSubnetCollectionAsProperty(m map[string]interface{}, propertyName string) (result *SubnetCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SubnetCollection'", propertyName)
			return
		}
		result, err = UnmarshalSubnetCollection(objMap)
	}
	return
}

// UnmarshalSubnetCollectionSliceAsProperty unmarshals a slice of SubnetCollection instances that are stored as a property
// within the specified map.
func UnmarshalSubnetCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SubnetCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SubnetCollection'", propertyName)
			return
		}
		slice, err = UnmarshalSubnetCollectionSlice(vSlice)
	}
	return
}

// SubnetCollectionFirst : A reference to the first page of resources.
type SubnetCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalSubnetCollectionFirst constructs an instance of SubnetCollectionFirst from the specified map.
func UnmarshalSubnetCollectionFirst(m map[string]interface{}) (result *SubnetCollectionFirst, err error) {
	obj := new(SubnetCollectionFirst)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSubnetCollectionFirstSlice unmarshals a slice of SubnetCollectionFirst instances from the specified list of maps.
func UnmarshalSubnetCollectionFirstSlice(s []interface{}) (slice []SubnetCollectionFirst, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SubnetCollectionFirst'")
			return
		}
		obj, e := UnmarshalSubnetCollectionFirst(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSubnetCollectionFirstAsProperty unmarshals an instance of SubnetCollectionFirst that is stored as a property
// within the specified map.
func UnmarshalSubnetCollectionFirstAsProperty(m map[string]interface{}, propertyName string) (result *SubnetCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SubnetCollectionFirst'", propertyName)
			return
		}
		result, err = UnmarshalSubnetCollectionFirst(objMap)
	}
	return
}

// UnmarshalSubnetCollectionFirstSliceAsProperty unmarshals a slice of SubnetCollectionFirst instances that are stored as a property
// within the specified map.
func UnmarshalSubnetCollectionFirstSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SubnetCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SubnetCollectionFirst'", propertyName)
			return
		}
		slice, err = UnmarshalSubnetCollectionFirstSlice(vSlice)
	}
	return
}

// SubnetCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type SubnetCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalSubnetCollectionNext constructs an instance of SubnetCollectionNext from the specified map.
func UnmarshalSubnetCollectionNext(m map[string]interface{}) (result *SubnetCollectionNext, err error) {
	obj := new(SubnetCollectionNext)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSubnetCollectionNextSlice unmarshals a slice of SubnetCollectionNext instances from the specified list of maps.
func UnmarshalSubnetCollectionNextSlice(s []interface{}) (slice []SubnetCollectionNext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SubnetCollectionNext'")
			return
		}
		obj, e := UnmarshalSubnetCollectionNext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSubnetCollectionNextAsProperty unmarshals an instance of SubnetCollectionNext that is stored as a property
// within the specified map.
func UnmarshalSubnetCollectionNextAsProperty(m map[string]interface{}, propertyName string) (result *SubnetCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SubnetCollectionNext'", propertyName)
			return
		}
		result, err = UnmarshalSubnetCollectionNext(objMap)
	}
	return
}

// UnmarshalSubnetCollectionNextSliceAsProperty unmarshals a slice of SubnetCollectionNext instances that are stored as a property
// within the specified map.
func UnmarshalSubnetCollectionNextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SubnetCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SubnetCollectionNext'", propertyName)
			return
		}
		slice, err = UnmarshalSubnetCollectionNextSlice(vSlice)
	}
	return
}

// SubnetIdentity : Identifies a subnet by a unique property.
// Models which "extend" this model:
// - SubnetIdentityByID
// - SubnetIdentityByCRN
// - SubnetIdentityByHref
type SubnetIdentity struct {
	// The unique identifier for this subnet.
	ID *string `json:"id,omitempty"`

	// The CRN for this subnet.
	Crn *string `json:"crn,omitempty"`

	// The URL for this subnet.
	Href *string `json:"href,omitempty"`
}

func (*SubnetIdentity) isaSubnetIdentity() bool {
	return true
}

type SubnetIdentityIntf interface {
	isaSubnetIdentity() bool
}

// UnmarshalSubnetIdentity constructs an instance of SubnetIdentity from the specified map.
func UnmarshalSubnetIdentity(m map[string]interface{}) (result SubnetIdentityIntf, err error) {
	obj := new(SubnetIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSubnetIdentitySlice unmarshals a slice of SubnetIdentity instances from the specified list of maps.
func UnmarshalSubnetIdentitySlice(s []interface{}) (slice []SubnetIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SubnetIdentity'")
			return
		}
		obj, e := UnmarshalSubnetIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalSubnetIdentityAsProperty unmarshals an instance of SubnetIdentity that is stored as a property
// within the specified map.
func UnmarshalSubnetIdentityAsProperty(m map[string]interface{}, propertyName string) (result SubnetIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SubnetIdentity'", propertyName)
			return
		}
		result, err = UnmarshalSubnetIdentity(objMap)
	}
	return
}

// UnmarshalSubnetIdentitySliceAsProperty unmarshals a slice of SubnetIdentity instances that are stored as a property
// within the specified map.
func UnmarshalSubnetIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []SubnetIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SubnetIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalSubnetIdentitySlice(vSlice)
	}
	return
}

// SubnetPrototype : SubnetPrototype struct
// Models which "extend" this model:
// - SubnetPrototypeSubnetByTotalCount
// - SubnetPrototypeSubnetByCIDR
type SubnetPrototype struct {
	// The IP version(s) supported by this subnet; if unspecified, `ipv4` is used.
	IpVersion *string `json:"ip_version,omitempty"`

	// The user-defined name for this subnet. Names must be unique within the VPC the subnet resides in. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The network ACL to use for this subnet.
	NetworkAcl NetworkACLIdentityIntf `json:"network_acl,omitempty"`

	// The public gateway to handle internet bound traffic for this subnet.
	PublicGateway PublicGatewayIdentityIntf `json:"public_gateway,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The VPC the subnet is to be a part of.
	Vpc VPCIdentityIntf `json:"vpc" validate:"required"`

	// The total number of IPv4 addresses required. Must be a power of 2. The VPC must have a default address prefix in the
	// specified zone, and that prefix must have a free CIDR range with at least this number of addresses.
	TotalIpv4AddressCount *int64 `json:"total_ipv4_address_count,omitempty"`

	// The zone the subnet is to reside in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`

	// The IPv4 range of the subnet, expressed in CIDR format. The prefix length of the subnet's CIDR must be between 8 and
	// 29. The IPv4 range of the subnet's CIDR must fall within an existing address prefix in the VPC. The subnet will be
	// created in the zone of the address prefix that contains the IPv4 CIDR. If zone is specified, it must match the zone
	// of the address prefix that contains the subnet's IPv4 CIDR.
	Ipv4CidrBlock *string `json:"ipv4_cidr_block,omitempty"`
}

// Constants associated with the SubnetPrototype.IpVersion property.
// The IP version(s) supported by this subnet; if unspecified, `ipv4` is used.
const (
	SubnetPrototype_IpVersion_Both = "both"
	SubnetPrototype_IpVersion_Ipv4 = "ipv4"
	SubnetPrototype_IpVersion_Ipv6 = "ipv6"
)

func (*SubnetPrototype) isaSubnetPrototype() bool {
	return true
}

type SubnetPrototypeIntf interface {
	isaSubnetPrototype() bool
}

// UnmarshalSubnetPrototype constructs an instance of SubnetPrototype from the specified map.
func UnmarshalSubnetPrototype(m map[string]interface{}) (result SubnetPrototypeIntf, err error) {
	obj := new(SubnetPrototype)
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.NetworkAcl, err = UnmarshalNetworkACLIdentityAsProperty(m, "network_acl")
	if err != nil {
		return
	}
	obj.PublicGateway, err = UnmarshalPublicGatewayIdentityAsProperty(m, "public_gateway")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupIdentityAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Vpc, err = UnmarshalVPCIdentityAsProperty(m, "vpc")
	if err != nil {
		return
	}
	obj.TotalIpv4AddressCount, err = core.UnmarshalInt64(m, "total_ipv4_address_count")
	if err != nil {
		return
	}
	obj.Zone, err = UnmarshalZoneIdentityAsProperty(m, "zone")
	if err != nil {
		return
	}
	obj.Ipv4CidrBlock, err = core.UnmarshalString(m, "ipv4_cidr_block")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSubnetPrototypeSlice unmarshals a slice of SubnetPrototype instances from the specified list of maps.
func UnmarshalSubnetPrototypeSlice(s []interface{}) (slice []SubnetPrototypeIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SubnetPrototype'")
			return
		}
		obj, e := UnmarshalSubnetPrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalSubnetPrototypeAsProperty unmarshals an instance of SubnetPrototype that is stored as a property
// within the specified map.
func UnmarshalSubnetPrototypeAsProperty(m map[string]interface{}, propertyName string) (result SubnetPrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SubnetPrototype'", propertyName)
			return
		}
		result, err = UnmarshalSubnetPrototype(objMap)
	}
	return
}

// UnmarshalSubnetPrototypeSliceAsProperty unmarshals a slice of SubnetPrototype instances that are stored as a property
// within the specified map.
func UnmarshalSubnetPrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SubnetPrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SubnetPrototype'", propertyName)
			return
		}
		slice, err = UnmarshalSubnetPrototypeSlice(vSlice)
	}
	return
}

// SubnetReference : SubnetReference struct
type SubnetReference struct {
	// The CRN for this subnet.
	Crn *string `json:"crn" validate:"required"`

	// The URL for this subnet.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this subnet.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this subnet.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalSubnetReference constructs an instance of SubnetReference from the specified map.
func UnmarshalSubnetReference(m map[string]interface{}) (result *SubnetReference, err error) {
	obj := new(SubnetReference)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSubnetReferenceSlice unmarshals a slice of SubnetReference instances from the specified list of maps.
func UnmarshalSubnetReferenceSlice(s []interface{}) (slice []SubnetReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SubnetReference'")
			return
		}
		obj, e := UnmarshalSubnetReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSubnetReferenceAsProperty unmarshals an instance of SubnetReference that is stored as a property
// within the specified map.
func UnmarshalSubnetReferenceAsProperty(m map[string]interface{}, propertyName string) (result *SubnetReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SubnetReference'", propertyName)
			return
		}
		result, err = UnmarshalSubnetReference(objMap)
	}
	return
}

// UnmarshalSubnetReferenceSliceAsProperty unmarshals a slice of SubnetReference instances that are stored as a property
// within the specified map.
func UnmarshalSubnetReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SubnetReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SubnetReference'", propertyName)
			return
		}
		slice, err = UnmarshalSubnetReferenceSlice(vSlice)
	}
	return
}

// UpdateFloatingIpOptions : The UpdateFloatingIp options.
type UpdateFloatingIpOptions struct {
	// The floating IP identifier.
	ID *string `json:"id" validate:"required"`

	// The unique user-defined name for this floating IP.
	Name *string `json:"name,omitempty"`

	// A new target to bind this floating IP with, replacing any existing binding.
	// For this request to succeed, the existing floating IP must not be required by another
	// resource, such as a public gateway.
	Target NetworkInterfaceIdentityIntf `json:"target,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateFloatingIpOptions : Instantiate UpdateFloatingIpOptions
func (*VpcV1) NewUpdateFloatingIpOptions(id string) *UpdateFloatingIpOptions {
	return &UpdateFloatingIpOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateFloatingIpOptions) SetID(id string) *UpdateFloatingIpOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateFloatingIpOptions) SetName(name string) *UpdateFloatingIpOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetTarget : Allow user to set Target
func (options *UpdateFloatingIpOptions) SetTarget(target NetworkInterfaceIdentityIntf) *UpdateFloatingIpOptions {
	options.Target = target
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateFloatingIpOptions) SetHeaders(param map[string]string) *UpdateFloatingIpOptions {
	options.Headers = param
	return options
}

// UpdateIkePolicyOptions : The UpdateIkePolicy options.
type UpdateIkePolicyOptions struct {
	// The IKE policy identifier.
	ID *string `json:"id" validate:"required"`

	// The authentication algorithm.
	AuthenticationAlgorithm *string `json:"authentication_algorithm,omitempty"`

	// The Diffie-Hellman group.
	DhGroup *int64 `json:"dh_group,omitempty"`

	// The encryption algorithm.
	EncryptionAlgorithm *string `json:"encryption_algorithm,omitempty"`

	// The IKE protocol version.
	IkeVersion *int64 `json:"ike_version,omitempty"`

	// The key lifetime in seconds.
	KeyLifetime *int64 `json:"key_lifetime,omitempty"`

	// The user-defined name for this IKE policy.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateIkePolicyOptions.AuthenticationAlgorithm property.
// The authentication algorithm.
const (
	UpdateIkePolicyOptions_AuthenticationAlgorithm_Md5    = "md5"
	UpdateIkePolicyOptions_AuthenticationAlgorithm_Sha1   = "sha1"
	UpdateIkePolicyOptions_AuthenticationAlgorithm_Sha256 = "sha256"
)

// Constants associated with the UpdateIkePolicyOptions.EncryptionAlgorithm property.
// The encryption algorithm.
const (
	UpdateIkePolicyOptions_EncryptionAlgorithm_Aes128    = "aes128"
	UpdateIkePolicyOptions_EncryptionAlgorithm_Aes256    = "aes256"
	UpdateIkePolicyOptions_EncryptionAlgorithm_TripleDes = "triple_des"
)

// NewUpdateIkePolicyOptions : Instantiate UpdateIkePolicyOptions
func (*VpcV1) NewUpdateIkePolicyOptions(id string) *UpdateIkePolicyOptions {
	return &UpdateIkePolicyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateIkePolicyOptions) SetID(id string) *UpdateIkePolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetAuthenticationAlgorithm : Allow user to set AuthenticationAlgorithm
func (options *UpdateIkePolicyOptions) SetAuthenticationAlgorithm(authenticationAlgorithm string) *UpdateIkePolicyOptions {
	options.AuthenticationAlgorithm = core.StringPtr(authenticationAlgorithm)
	return options
}

// SetDhGroup : Allow user to set DhGroup
func (options *UpdateIkePolicyOptions) SetDhGroup(dhGroup int64) *UpdateIkePolicyOptions {
	options.DhGroup = core.Int64Ptr(dhGroup)
	return options
}

// SetEncryptionAlgorithm : Allow user to set EncryptionAlgorithm
func (options *UpdateIkePolicyOptions) SetEncryptionAlgorithm(encryptionAlgorithm string) *UpdateIkePolicyOptions {
	options.EncryptionAlgorithm = core.StringPtr(encryptionAlgorithm)
	return options
}

// SetIkeVersion : Allow user to set IkeVersion
func (options *UpdateIkePolicyOptions) SetIkeVersion(ikeVersion int64) *UpdateIkePolicyOptions {
	options.IkeVersion = core.Int64Ptr(ikeVersion)
	return options
}

// SetKeyLifetime : Allow user to set KeyLifetime
func (options *UpdateIkePolicyOptions) SetKeyLifetime(keyLifetime int64) *UpdateIkePolicyOptions {
	options.KeyLifetime = core.Int64Ptr(keyLifetime)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateIkePolicyOptions) SetName(name string) *UpdateIkePolicyOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateIkePolicyOptions) SetHeaders(param map[string]string) *UpdateIkePolicyOptions {
	options.Headers = param
	return options
}

// UpdateImageOptions : The UpdateImage options.
type UpdateImageOptions struct {
	// The image identifier.
	ID *string `json:"id" validate:"required"`

	// The unique user-defined name for this image. Names starting with "ibm-" are not allowed.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateImageOptions : Instantiate UpdateImageOptions
func (*VpcV1) NewUpdateImageOptions(id string) *UpdateImageOptions {
	return &UpdateImageOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateImageOptions) SetID(id string) *UpdateImageOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateImageOptions) SetName(name string) *UpdateImageOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateImageOptions) SetHeaders(param map[string]string) *UpdateImageOptions {
	options.Headers = param
	return options
}

// UpdateInstanceOptions : The UpdateInstance options.
type UpdateInstanceOptions struct {
	// The instance identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this virtual server instance (and default system hostname).
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateInstanceOptions : Instantiate UpdateInstanceOptions
func (*VpcV1) NewUpdateInstanceOptions(id string) *UpdateInstanceOptions {
	return &UpdateInstanceOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateInstanceOptions) SetID(id string) *UpdateInstanceOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateInstanceOptions) SetName(name string) *UpdateInstanceOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateInstanceOptions) SetHeaders(param map[string]string) *UpdateInstanceOptions {
	options.Headers = param
	return options
}

// UpdateIpsecPolicyOptions : The UpdateIpsecPolicy options.
type UpdateIpsecPolicyOptions struct {
	// The IPsec policy identifier.
	ID *string `json:"id" validate:"required"`

	// The authentication algorithm.
	AuthenticationAlgorithm *string `json:"authentication_algorithm,omitempty"`

	// The encryption algorithm.
	EncryptionAlgorithm *string `json:"encryption_algorithm,omitempty"`

	// The key lifetime in seconds.
	KeyLifetime *int64 `json:"key_lifetime,omitempty"`

	// The user-defined name for this IPsec policy.
	Name *string `json:"name,omitempty"`

	// Perfect Forward Secrecy.
	Pfs *string `json:"pfs,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateIpsecPolicyOptions.AuthenticationAlgorithm property.
// The authentication algorithm.
const (
	UpdateIpsecPolicyOptions_AuthenticationAlgorithm_Md5    = "md5"
	UpdateIpsecPolicyOptions_AuthenticationAlgorithm_Sha1   = "sha1"
	UpdateIpsecPolicyOptions_AuthenticationAlgorithm_Sha256 = "sha256"
)

// Constants associated with the UpdateIpsecPolicyOptions.EncryptionAlgorithm property.
// The encryption algorithm.
const (
	UpdateIpsecPolicyOptions_EncryptionAlgorithm_Aes128    = "aes128"
	UpdateIpsecPolicyOptions_EncryptionAlgorithm_Aes256    = "aes256"
	UpdateIpsecPolicyOptions_EncryptionAlgorithm_TripleDes = "triple_des"
)

// Constants associated with the UpdateIpsecPolicyOptions.Pfs property.
// Perfect Forward Secrecy.
const (
	UpdateIpsecPolicyOptions_Pfs_Disabled = "disabled"
	UpdateIpsecPolicyOptions_Pfs_Group14  = "group_14"
	UpdateIpsecPolicyOptions_Pfs_Group2   = "group_2"
	UpdateIpsecPolicyOptions_Pfs_Group5   = "group_5"
)

// NewUpdateIpsecPolicyOptions : Instantiate UpdateIpsecPolicyOptions
func (*VpcV1) NewUpdateIpsecPolicyOptions(id string) *UpdateIpsecPolicyOptions {
	return &UpdateIpsecPolicyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateIpsecPolicyOptions) SetID(id string) *UpdateIpsecPolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetAuthenticationAlgorithm : Allow user to set AuthenticationAlgorithm
func (options *UpdateIpsecPolicyOptions) SetAuthenticationAlgorithm(authenticationAlgorithm string) *UpdateIpsecPolicyOptions {
	options.AuthenticationAlgorithm = core.StringPtr(authenticationAlgorithm)
	return options
}

// SetEncryptionAlgorithm : Allow user to set EncryptionAlgorithm
func (options *UpdateIpsecPolicyOptions) SetEncryptionAlgorithm(encryptionAlgorithm string) *UpdateIpsecPolicyOptions {
	options.EncryptionAlgorithm = core.StringPtr(encryptionAlgorithm)
	return options
}

// SetKeyLifetime : Allow user to set KeyLifetime
func (options *UpdateIpsecPolicyOptions) SetKeyLifetime(keyLifetime int64) *UpdateIpsecPolicyOptions {
	options.KeyLifetime = core.Int64Ptr(keyLifetime)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateIpsecPolicyOptions) SetName(name string) *UpdateIpsecPolicyOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetPfs : Allow user to set Pfs
func (options *UpdateIpsecPolicyOptions) SetPfs(pfs string) *UpdateIpsecPolicyOptions {
	options.Pfs = core.StringPtr(pfs)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateIpsecPolicyOptions) SetHeaders(param map[string]string) *UpdateIpsecPolicyOptions {
	options.Headers = param
	return options
}

// UpdateKeyOptions : The UpdateKey options.
type UpdateKeyOptions struct {
	// The key identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this key.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateKeyOptions : Instantiate UpdateKeyOptions
func (*VpcV1) NewUpdateKeyOptions(id string) *UpdateKeyOptions {
	return &UpdateKeyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateKeyOptions) SetID(id string) *UpdateKeyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateKeyOptions) SetName(name string) *UpdateKeyOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateKeyOptions) SetHeaders(param map[string]string) *UpdateKeyOptions {
	options.Headers = param
	return options
}

// UpdateLoadBalancerListenerOptions : The UpdateLoadBalancerListener options.
type UpdateLoadBalancerListenerOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ID *string `json:"id" validate:"required"`

	// The certificate instance used for SSL termination. It is applicable only to `https`
	// protocol.
	CertificateInstance CertificateInstanceIdentityIntf `json:"certificate_instance,omitempty"`

	// The connection limit of the listener.
	ConnectionLimit *int64 `json:"connection_limit,omitempty"`

	// The default pool associated with the listener.
	DefaultPool LoadBalancerPoolIdentityIntf `json:"default_pool,omitempty"`

	// The listener port number.
	Port *int64 `json:"port,omitempty"`

	// The listener protocol.
	Protocol *string `json:"protocol,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateLoadBalancerListenerOptions.Protocol property.
// The listener protocol.
const (
	UpdateLoadBalancerListenerOptions_Protocol_Http  = "http"
	UpdateLoadBalancerListenerOptions_Protocol_Https = "https"
	UpdateLoadBalancerListenerOptions_Protocol_Tcp   = "tcp"
)

// NewUpdateLoadBalancerListenerOptions : Instantiate UpdateLoadBalancerListenerOptions
func (*VpcV1) NewUpdateLoadBalancerListenerOptions(loadBalancerID string, id string) *UpdateLoadBalancerListenerOptions {
	return &UpdateLoadBalancerListenerOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *UpdateLoadBalancerListenerOptions) SetLoadBalancerID(loadBalancerID string) *UpdateLoadBalancerListenerOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateLoadBalancerListenerOptions) SetID(id string) *UpdateLoadBalancerListenerOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetCertificateInstance : Allow user to set CertificateInstance
func (options *UpdateLoadBalancerListenerOptions) SetCertificateInstance(certificateInstance CertificateInstanceIdentityIntf) *UpdateLoadBalancerListenerOptions {
	options.CertificateInstance = certificateInstance
	return options
}

// SetConnectionLimit : Allow user to set ConnectionLimit
func (options *UpdateLoadBalancerListenerOptions) SetConnectionLimit(connectionLimit int64) *UpdateLoadBalancerListenerOptions {
	options.ConnectionLimit = core.Int64Ptr(connectionLimit)
	return options
}

// SetDefaultPool : Allow user to set DefaultPool
func (options *UpdateLoadBalancerListenerOptions) SetDefaultPool(defaultPool LoadBalancerPoolIdentityIntf) *UpdateLoadBalancerListenerOptions {
	options.DefaultPool = defaultPool
	return options
}

// SetPort : Allow user to set Port
func (options *UpdateLoadBalancerListenerOptions) SetPort(port int64) *UpdateLoadBalancerListenerOptions {
	options.Port = core.Int64Ptr(port)
	return options
}

// SetProtocol : Allow user to set Protocol
func (options *UpdateLoadBalancerListenerOptions) SetProtocol(protocol string) *UpdateLoadBalancerListenerOptions {
	options.Protocol = core.StringPtr(protocol)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoadBalancerListenerOptions) SetHeaders(param map[string]string) *UpdateLoadBalancerListenerOptions {
	options.Headers = param
	return options
}

// UpdateLoadBalancerListenerPolicyOptions : The UpdateLoadBalancerListenerPolicy options.
type UpdateLoadBalancerListenerPolicyOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// The policy identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this policy. Names must be unique within the load balancer listener the policy resides in.
	Name *string `json:"name,omitempty"`

	// Priority of the policy. Lower value indicates higher priority.
	Priority *int64 `json:"priority,omitempty"`

	// When `action` is `forward`, `LoadBalancerPoolIdentity` specifies which pool the load
	// balancer forwards the traffic to. When `action` is `redirect`,
	// `LoadBalancerListenerPolicyRedirectURLPatch` specifies the url and http
	// status code used in the redirect response.
	Target LoadBalancerListenerPolicyPatchTargetIntf `json:"target,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateLoadBalancerListenerPolicyOptions : Instantiate UpdateLoadBalancerListenerPolicyOptions
func (*VpcV1) NewUpdateLoadBalancerListenerPolicyOptions(loadBalancerID string, listenerID string, id string) *UpdateLoadBalancerListenerPolicyOptions {
	return &UpdateLoadBalancerListenerPolicyOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *UpdateLoadBalancerListenerPolicyOptions) SetLoadBalancerID(loadBalancerID string) *UpdateLoadBalancerListenerPolicyOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *UpdateLoadBalancerListenerPolicyOptions) SetListenerID(listenerID string) *UpdateLoadBalancerListenerPolicyOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateLoadBalancerListenerPolicyOptions) SetID(id string) *UpdateLoadBalancerListenerPolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateLoadBalancerListenerPolicyOptions) SetName(name string) *UpdateLoadBalancerListenerPolicyOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetPriority : Allow user to set Priority
func (options *UpdateLoadBalancerListenerPolicyOptions) SetPriority(priority int64) *UpdateLoadBalancerListenerPolicyOptions {
	options.Priority = core.Int64Ptr(priority)
	return options
}

// SetTarget : Allow user to set Target
func (options *UpdateLoadBalancerListenerPolicyOptions) SetTarget(target LoadBalancerListenerPolicyPatchTargetIntf) *UpdateLoadBalancerListenerPolicyOptions {
	options.Target = target
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoadBalancerListenerPolicyOptions) SetHeaders(param map[string]string) *UpdateLoadBalancerListenerPolicyOptions {
	options.Headers = param
	return options
}

// UpdateLoadBalancerListenerPolicyRuleOptions : The UpdateLoadBalancerListenerPolicyRule options.
type UpdateLoadBalancerListenerPolicyRuleOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// The policy identifier.
	PolicyID *string `json:"policy_id" validate:"required"`

	// The rule identifier.
	ID *string `json:"id" validate:"required"`

	// The condition of the rule.
	Condition *string `json:"condition,omitempty"`

	// HTTP header field. This is only applicable to "header" rule type.
	Field *string `json:"field,omitempty"`

	// The type of the rule.
	Type *string `json:"type,omitempty"`

	// Value to be matched for rule condition.
	Value *string `json:"value,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateLoadBalancerListenerPolicyRuleOptions.Condition property.
// The condition of the rule.
const (
	UpdateLoadBalancerListenerPolicyRuleOptions_Condition_Contains     = "contains"
	UpdateLoadBalancerListenerPolicyRuleOptions_Condition_Equals       = "equals"
	UpdateLoadBalancerListenerPolicyRuleOptions_Condition_MatchesRegex = "matches_regex"
)

// Constants associated with the UpdateLoadBalancerListenerPolicyRuleOptions.Type property.
// The type of the rule.
const (
	UpdateLoadBalancerListenerPolicyRuleOptions_Type_Header   = "header"
	UpdateLoadBalancerListenerPolicyRuleOptions_Type_Hostname = "hostname"
	UpdateLoadBalancerListenerPolicyRuleOptions_Type_Path     = "path"
)

// NewUpdateLoadBalancerListenerPolicyRuleOptions : Instantiate UpdateLoadBalancerListenerPolicyRuleOptions
func (*VpcV1) NewUpdateLoadBalancerListenerPolicyRuleOptions(loadBalancerID string, listenerID string, policyID string, id string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	return &UpdateLoadBalancerListenerPolicyRuleOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		PolicyID:       core.StringPtr(policyID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *UpdateLoadBalancerListenerPolicyRuleOptions) SetLoadBalancerID(loadBalancerID string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *UpdateLoadBalancerListenerPolicyRuleOptions) SetListenerID(listenerID string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetPolicyID : Allow user to set PolicyID
func (options *UpdateLoadBalancerListenerPolicyRuleOptions) SetPolicyID(policyID string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	options.PolicyID = core.StringPtr(policyID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateLoadBalancerListenerPolicyRuleOptions) SetID(id string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetCondition : Allow user to set Condition
func (options *UpdateLoadBalancerListenerPolicyRuleOptions) SetCondition(condition string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	options.Condition = core.StringPtr(condition)
	return options
}

// SetField : Allow user to set Field
func (options *UpdateLoadBalancerListenerPolicyRuleOptions) SetField(field string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	options.Field = core.StringPtr(field)
	return options
}

// SetType : Allow user to set Type
func (options *UpdateLoadBalancerListenerPolicyRuleOptions) SetType(typeVar string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetValue : Allow user to set Value
func (options *UpdateLoadBalancerListenerPolicyRuleOptions) SetValue(value string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	options.Value = core.StringPtr(value)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoadBalancerListenerPolicyRuleOptions) SetHeaders(param map[string]string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	options.Headers = param
	return options
}

// UpdateLoadBalancerOptions : The UpdateLoadBalancer options.
type UpdateLoadBalancerOptions struct {
	// The load balancer identifier.
	ID *string `json:"id" validate:"required"`

	// The unique user-defined name for this load balancer.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateLoadBalancerOptions : Instantiate UpdateLoadBalancerOptions
func (*VpcV1) NewUpdateLoadBalancerOptions(id string) *UpdateLoadBalancerOptions {
	return &UpdateLoadBalancerOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateLoadBalancerOptions) SetID(id string) *UpdateLoadBalancerOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateLoadBalancerOptions) SetName(name string) *UpdateLoadBalancerOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoadBalancerOptions) SetHeaders(param map[string]string) *UpdateLoadBalancerOptions {
	options.Headers = param
	return options
}

// UpdateLoadBalancerPoolMemberOptions : The UpdateLoadBalancerPoolMember options.
type UpdateLoadBalancerPoolMemberOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The pool identifier.
	PoolID *string `json:"pool_id" validate:"required"`

	// The member identifier.
	ID *string `json:"id" validate:"required"`

	// The port number of the application running in the server member.
	Port *int64 `json:"port,omitempty"`

	// The pool member target.
	Target LoadBalancerPoolMemberTargetPrototypeIntf `json:"target,omitempty"`

	// Weight of the server member. This takes effect only when the load balancing algorithm of its belonging pool is
	// `weighted_round_robin`.
	Weight *int64 `json:"weight,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateLoadBalancerPoolMemberOptions : Instantiate UpdateLoadBalancerPoolMemberOptions
func (*VpcV1) NewUpdateLoadBalancerPoolMemberOptions(loadBalancerID string, poolID string, id string) *UpdateLoadBalancerPoolMemberOptions {
	return &UpdateLoadBalancerPoolMemberOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		PoolID:         core.StringPtr(poolID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *UpdateLoadBalancerPoolMemberOptions) SetLoadBalancerID(loadBalancerID string) *UpdateLoadBalancerPoolMemberOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetPoolID : Allow user to set PoolID
func (options *UpdateLoadBalancerPoolMemberOptions) SetPoolID(poolID string) *UpdateLoadBalancerPoolMemberOptions {
	options.PoolID = core.StringPtr(poolID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateLoadBalancerPoolMemberOptions) SetID(id string) *UpdateLoadBalancerPoolMemberOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetPort : Allow user to set Port
func (options *UpdateLoadBalancerPoolMemberOptions) SetPort(port int64) *UpdateLoadBalancerPoolMemberOptions {
	options.Port = core.Int64Ptr(port)
	return options
}

// SetTarget : Allow user to set Target
func (options *UpdateLoadBalancerPoolMemberOptions) SetTarget(target LoadBalancerPoolMemberTargetPrototypeIntf) *UpdateLoadBalancerPoolMemberOptions {
	options.Target = target
	return options
}

// SetWeight : Allow user to set Weight
func (options *UpdateLoadBalancerPoolMemberOptions) SetWeight(weight int64) *UpdateLoadBalancerPoolMemberOptions {
	options.Weight = core.Int64Ptr(weight)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoadBalancerPoolMemberOptions) SetHeaders(param map[string]string) *UpdateLoadBalancerPoolMemberOptions {
	options.Headers = param
	return options
}

// UpdateLoadBalancerPoolMembersOptions : The UpdateLoadBalancerPoolMembers options.
type UpdateLoadBalancerPoolMembersOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The pool identifier.
	PoolID *string `json:"pool_id" validate:"required"`

	// Array of pool member prototype objects.
	Members []LoadBalancerPoolMemberPrototype `json:"members" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateLoadBalancerPoolMembersOptions : Instantiate UpdateLoadBalancerPoolMembersOptions
func (*VpcV1) NewUpdateLoadBalancerPoolMembersOptions(loadBalancerID string, poolID string, members []LoadBalancerPoolMemberPrototype) *UpdateLoadBalancerPoolMembersOptions {
	return &UpdateLoadBalancerPoolMembersOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		PoolID:         core.StringPtr(poolID),
		Members:        members,
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *UpdateLoadBalancerPoolMembersOptions) SetLoadBalancerID(loadBalancerID string) *UpdateLoadBalancerPoolMembersOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetPoolID : Allow user to set PoolID
func (options *UpdateLoadBalancerPoolMembersOptions) SetPoolID(poolID string) *UpdateLoadBalancerPoolMembersOptions {
	options.PoolID = core.StringPtr(poolID)
	return options
}

// SetMembers : Allow user to set Members
func (options *UpdateLoadBalancerPoolMembersOptions) SetMembers(members []LoadBalancerPoolMemberPrototype) *UpdateLoadBalancerPoolMembersOptions {
	options.Members = members
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoadBalancerPoolMembersOptions) SetHeaders(param map[string]string) *UpdateLoadBalancerPoolMembersOptions {
	options.Headers = param
	return options
}

// UpdateLoadBalancerPoolOptions : The UpdateLoadBalancerPool options.
type UpdateLoadBalancerPoolOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The pool identifier.
	ID *string `json:"id" validate:"required"`

	// The load balancing algorithm.
	Algorithm *string `json:"algorithm,omitempty"`

	// The health monitor of this pool.
	HealthMonitor *LoadBalancerPoolHealthMonitorPatch `json:"health_monitor,omitempty"`

	// The user-defined name for this load balancer pool.
	Name *string `json:"name,omitempty"`

	// The pool protocol.
	Protocol *string `json:"protocol,omitempty"`

	// The session persistence of this pool.
	SessionPersistence *LoadBalancerPoolSessionPersistencePatch `json:"session_persistence,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateLoadBalancerPoolOptions.Algorithm property.
// The load balancing algorithm.
const (
	UpdateLoadBalancerPoolOptions_Algorithm_LeastConnections   = "least_connections"
	UpdateLoadBalancerPoolOptions_Algorithm_RoundRobin         = "round_robin"
	UpdateLoadBalancerPoolOptions_Algorithm_WeightedRoundRobin = "weighted_round_robin"
)

// Constants associated with the UpdateLoadBalancerPoolOptions.Protocol property.
// The pool protocol.
const (
	UpdateLoadBalancerPoolOptions_Protocol_Http = "http"
	UpdateLoadBalancerPoolOptions_Protocol_Tcp  = "tcp"
)

// NewUpdateLoadBalancerPoolOptions : Instantiate UpdateLoadBalancerPoolOptions
func (*VpcV1) NewUpdateLoadBalancerPoolOptions(loadBalancerID string, id string) *UpdateLoadBalancerPoolOptions {
	return &UpdateLoadBalancerPoolOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *UpdateLoadBalancerPoolOptions) SetLoadBalancerID(loadBalancerID string) *UpdateLoadBalancerPoolOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateLoadBalancerPoolOptions) SetID(id string) *UpdateLoadBalancerPoolOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetAlgorithm : Allow user to set Algorithm
func (options *UpdateLoadBalancerPoolOptions) SetAlgorithm(algorithm string) *UpdateLoadBalancerPoolOptions {
	options.Algorithm = core.StringPtr(algorithm)
	return options
}

// SetHealthMonitor : Allow user to set HealthMonitor
func (options *UpdateLoadBalancerPoolOptions) SetHealthMonitor(healthMonitor *LoadBalancerPoolHealthMonitorPatch) *UpdateLoadBalancerPoolOptions {
	options.HealthMonitor = healthMonitor
	return options
}

// SetName : Allow user to set Name
func (options *UpdateLoadBalancerPoolOptions) SetName(name string) *UpdateLoadBalancerPoolOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetProtocol : Allow user to set Protocol
func (options *UpdateLoadBalancerPoolOptions) SetProtocol(protocol string) *UpdateLoadBalancerPoolOptions {
	options.Protocol = core.StringPtr(protocol)
	return options
}

// SetSessionPersistence : Allow user to set SessionPersistence
func (options *UpdateLoadBalancerPoolOptions) SetSessionPersistence(sessionPersistence *LoadBalancerPoolSessionPersistencePatch) *UpdateLoadBalancerPoolOptions {
	options.SessionPersistence = sessionPersistence
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoadBalancerPoolOptions) SetHeaders(param map[string]string) *UpdateLoadBalancerPoolOptions {
	options.Headers = param
	return options
}

// UpdateNetworkAclOptions : The UpdateNetworkAcl options.
type UpdateNetworkAclOptions struct {
	// The network ACL identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this network ACL. Names must be unique within the VPC the Network ACL resides in.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateNetworkAclOptions : Instantiate UpdateNetworkAclOptions
func (*VpcV1) NewUpdateNetworkAclOptions(id string) *UpdateNetworkAclOptions {
	return &UpdateNetworkAclOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateNetworkAclOptions) SetID(id string) *UpdateNetworkAclOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateNetworkAclOptions) SetName(name string) *UpdateNetworkAclOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateNetworkAclOptions) SetHeaders(param map[string]string) *UpdateNetworkAclOptions {
	options.Headers = param
	return options
}

// UpdateNetworkAclRuleOptions : The UpdateNetworkAclRule options.
type UpdateNetworkAclRuleOptions struct {
	// The network ACL identifier.
	NetworkAclID *string `json:"network_acl_id" validate:"required"`

	// The rule identifier.
	ID *string `json:"id" validate:"required"`

	// Whether to allow or deny matching traffic.
	Action *string `json:"action,omitempty"`

	// The rule to move this rule immediately before. Specify `null` to move this rule after
	// all existing rules.
	Before NetworkACLRulePatchBeforeIntf `json:"before,omitempty"`

	// The ICMP traffic code to allow.
	Code *int64 `json:"code,omitempty"`

	// The destination IP address or CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination,omitempty"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction,omitempty"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in.
	Name *string `json:"name,omitempty"`

	// The source IP address or CIDR block.  The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`

	// The ICMP traffic type to allow.
	Type *int64 `json:"type,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateNetworkAclRuleOptions.Action property.
// Whether to allow or deny matching traffic.
const (
	UpdateNetworkAclRuleOptions_Action_Allow = "allow"
	UpdateNetworkAclRuleOptions_Action_Deny  = "deny"
)

// Constants associated with the UpdateNetworkAclRuleOptions.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	UpdateNetworkAclRuleOptions_Direction_Inbound  = "inbound"
	UpdateNetworkAclRuleOptions_Direction_Outbound = "outbound"
)

// NewUpdateNetworkAclRuleOptions : Instantiate UpdateNetworkAclRuleOptions
func (*VpcV1) NewUpdateNetworkAclRuleOptions(networkAclID string, id string) *UpdateNetworkAclRuleOptions {
	return &UpdateNetworkAclRuleOptions{
		NetworkAclID: core.StringPtr(networkAclID),
		ID:           core.StringPtr(id),
	}
}

// SetNetworkAclID : Allow user to set NetworkAclID
func (options *UpdateNetworkAclRuleOptions) SetNetworkAclID(networkAclID string) *UpdateNetworkAclRuleOptions {
	options.NetworkAclID = core.StringPtr(networkAclID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateNetworkAclRuleOptions) SetID(id string) *UpdateNetworkAclRuleOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetAction : Allow user to set Action
func (options *UpdateNetworkAclRuleOptions) SetAction(action string) *UpdateNetworkAclRuleOptions {
	options.Action = core.StringPtr(action)
	return options
}

// SetBefore : Allow user to set Before
func (options *UpdateNetworkAclRuleOptions) SetBefore(before NetworkACLRulePatchBeforeIntf) *UpdateNetworkAclRuleOptions {
	options.Before = before
	return options
}

// SetCode : Allow user to set Code
func (options *UpdateNetworkAclRuleOptions) SetCode(code int64) *UpdateNetworkAclRuleOptions {
	options.Code = core.Int64Ptr(code)
	return options
}

// SetDestination : Allow user to set Destination
func (options *UpdateNetworkAclRuleOptions) SetDestination(destination string) *UpdateNetworkAclRuleOptions {
	options.Destination = core.StringPtr(destination)
	return options
}

// SetDestinationPortMax : Allow user to set DestinationPortMax
func (options *UpdateNetworkAclRuleOptions) SetDestinationPortMax(destinationPortMax int64) *UpdateNetworkAclRuleOptions {
	options.DestinationPortMax = core.Int64Ptr(destinationPortMax)
	return options
}

// SetDestinationPortMin : Allow user to set DestinationPortMin
func (options *UpdateNetworkAclRuleOptions) SetDestinationPortMin(destinationPortMin int64) *UpdateNetworkAclRuleOptions {
	options.DestinationPortMin = core.Int64Ptr(destinationPortMin)
	return options
}

// SetDirection : Allow user to set Direction
func (options *UpdateNetworkAclRuleOptions) SetDirection(direction string) *UpdateNetworkAclRuleOptions {
	options.Direction = core.StringPtr(direction)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateNetworkAclRuleOptions) SetName(name string) *UpdateNetworkAclRuleOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetSource : Allow user to set Source
func (options *UpdateNetworkAclRuleOptions) SetSource(source string) *UpdateNetworkAclRuleOptions {
	options.Source = core.StringPtr(source)
	return options
}

// SetSourcePortMax : Allow user to set SourcePortMax
func (options *UpdateNetworkAclRuleOptions) SetSourcePortMax(sourcePortMax int64) *UpdateNetworkAclRuleOptions {
	options.SourcePortMax = core.Int64Ptr(sourcePortMax)
	return options
}

// SetSourcePortMin : Allow user to set SourcePortMin
func (options *UpdateNetworkAclRuleOptions) SetSourcePortMin(sourcePortMin int64) *UpdateNetworkAclRuleOptions {
	options.SourcePortMin = core.Int64Ptr(sourcePortMin)
	return options
}

// SetType : Allow user to set Type
func (options *UpdateNetworkAclRuleOptions) SetType(typeVar int64) *UpdateNetworkAclRuleOptions {
	options.Type = core.Int64Ptr(typeVar)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateNetworkAclRuleOptions) SetHeaders(param map[string]string) *UpdateNetworkAclRuleOptions {
	options.Headers = param
	return options
}

// UpdateNetworkInterfaceOptions : The UpdateNetworkInterface options.
type UpdateNetworkInterfaceOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The network interface identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this network interface.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateNetworkInterfaceOptions : Instantiate UpdateNetworkInterfaceOptions
func (*VpcV1) NewUpdateNetworkInterfaceOptions(instanceID string, id string) *UpdateNetworkInterfaceOptions {
	return &UpdateNetworkInterfaceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *UpdateNetworkInterfaceOptions) SetInstanceID(instanceID string) *UpdateNetworkInterfaceOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateNetworkInterfaceOptions) SetID(id string) *UpdateNetworkInterfaceOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateNetworkInterfaceOptions) SetName(name string) *UpdateNetworkInterfaceOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateNetworkInterfaceOptions) SetHeaders(param map[string]string) *UpdateNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// UpdatePublicGatewayOptions : The UpdatePublicGateway options.
type UpdatePublicGatewayOptions struct {
	// The public gateway identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this public gateway. Names must be unique within the VPC the public gateway resides in.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdatePublicGatewayOptions : Instantiate UpdatePublicGatewayOptions
func (*VpcV1) NewUpdatePublicGatewayOptions(id string) *UpdatePublicGatewayOptions {
	return &UpdatePublicGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdatePublicGatewayOptions) SetID(id string) *UpdatePublicGatewayOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdatePublicGatewayOptions) SetName(name string) *UpdatePublicGatewayOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdatePublicGatewayOptions) SetHeaders(param map[string]string) *UpdatePublicGatewayOptions {
	options.Headers = param
	return options
}

// UpdateSecurityGroupOptions : The UpdateSecurityGroup options.
type UpdateSecurityGroupOptions struct {
	// The security group identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSecurityGroupOptions : Instantiate UpdateSecurityGroupOptions
func (*VpcV1) NewUpdateSecurityGroupOptions(id string) *UpdateSecurityGroupOptions {
	return &UpdateSecurityGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateSecurityGroupOptions) SetID(id string) *UpdateSecurityGroupOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateSecurityGroupOptions) SetName(name string) *UpdateSecurityGroupOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSecurityGroupOptions) SetHeaders(param map[string]string) *UpdateSecurityGroupOptions {
	options.Headers = param
	return options
}

// UpdateSecurityGroupRuleOptions : The UpdateSecurityGroupRule options.
type UpdateSecurityGroupRuleOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required"`

	// The rule identifier.
	ID *string `json:"id" validate:"required"`

	// The ICMP traffic code to allow.
	Code *int64 `json:"code,omitempty"`

	// The direction of traffic to enforce, either `inbound` or `outbound`.
	Direction *string `json:"direction,omitempty"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
	// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
	// interfaces) in that group matching this IP version.
	IpVersion *string `json:"ip_version,omitempty"`

	// The inclusive upper bound of TCP/UDP port range.
	PortMax *int64 `json:"port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP port range.
	PortMin *int64 `json:"port_min,omitempty"`

	// The IP addresses or security groups from which this rule will allow traffic (or to
	// which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
	// security group. A CIDR block of `0.0.0.0/0` will allow traffic from any source (or to
	// any source, for outbound rules).
	Remote SecurityGroupRulePatchRemoteIntf `json:"remote,omitempty"`

	// The ICMP traffic type to allow.
	Type *int64 `json:"type,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateSecurityGroupRuleOptions.Direction property.
// The direction of traffic to enforce, either `inbound` or `outbound`.
const (
	UpdateSecurityGroupRuleOptions_Direction_Inbound  = "inbound"
	UpdateSecurityGroupRuleOptions_Direction_Outbound = "outbound"
)

// Constants associated with the UpdateSecurityGroupRuleOptions.IpVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
// interfaces) in that group matching this IP version.
const (
	UpdateSecurityGroupRuleOptions_IpVersion_Ipv4 = "ipv4"
)

// NewUpdateSecurityGroupRuleOptions : Instantiate UpdateSecurityGroupRuleOptions
func (*VpcV1) NewUpdateSecurityGroupRuleOptions(securityGroupID string, id string) *UpdateSecurityGroupRuleOptions {
	return &UpdateSecurityGroupRuleOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (options *UpdateSecurityGroupRuleOptions) SetSecurityGroupID(securityGroupID string) *UpdateSecurityGroupRuleOptions {
	options.SecurityGroupID = core.StringPtr(securityGroupID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateSecurityGroupRuleOptions) SetID(id string) *UpdateSecurityGroupRuleOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetCode : Allow user to set Code
func (options *UpdateSecurityGroupRuleOptions) SetCode(code int64) *UpdateSecurityGroupRuleOptions {
	options.Code = core.Int64Ptr(code)
	return options
}

// SetDirection : Allow user to set Direction
func (options *UpdateSecurityGroupRuleOptions) SetDirection(direction string) *UpdateSecurityGroupRuleOptions {
	options.Direction = core.StringPtr(direction)
	return options
}

// SetIpVersion : Allow user to set IpVersion
func (options *UpdateSecurityGroupRuleOptions) SetIpVersion(ipVersion string) *UpdateSecurityGroupRuleOptions {
	options.IpVersion = core.StringPtr(ipVersion)
	return options
}

// SetPortMax : Allow user to set PortMax
func (options *UpdateSecurityGroupRuleOptions) SetPortMax(portMax int64) *UpdateSecurityGroupRuleOptions {
	options.PortMax = core.Int64Ptr(portMax)
	return options
}

// SetPortMin : Allow user to set PortMin
func (options *UpdateSecurityGroupRuleOptions) SetPortMin(portMin int64) *UpdateSecurityGroupRuleOptions {
	options.PortMin = core.Int64Ptr(portMin)
	return options
}

// SetRemote : Allow user to set Remote
func (options *UpdateSecurityGroupRuleOptions) SetRemote(remote SecurityGroupRulePatchRemoteIntf) *UpdateSecurityGroupRuleOptions {
	options.Remote = remote
	return options
}

// SetType : Allow user to set Type
func (options *UpdateSecurityGroupRuleOptions) SetType(typeVar int64) *UpdateSecurityGroupRuleOptions {
	options.Type = core.Int64Ptr(typeVar)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSecurityGroupRuleOptions) SetHeaders(param map[string]string) *UpdateSecurityGroupRuleOptions {
	options.Headers = param
	return options
}

// UpdateSubnetOptions : The UpdateSubnet options.
type UpdateSubnetOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this subnet. Names must be unique within the VPC the subnet resides in.
	Name *string `json:"name,omitempty"`

	// The network ACL to use for this subnet.
	NetworkAcl NetworkACLIdentityIntf `json:"network_acl,omitempty"`

	// The public gateway to handle internet bound traffic for this subnet.
	PublicGateway PublicGatewayIdentityIntf `json:"public_gateway,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSubnetOptions : Instantiate UpdateSubnetOptions
func (*VpcV1) NewUpdateSubnetOptions(id string) *UpdateSubnetOptions {
	return &UpdateSubnetOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateSubnetOptions) SetID(id string) *UpdateSubnetOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateSubnetOptions) SetName(name string) *UpdateSubnetOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetNetworkAcl : Allow user to set NetworkAcl
func (options *UpdateSubnetOptions) SetNetworkAcl(networkAcl NetworkACLIdentityIntf) *UpdateSubnetOptions {
	options.NetworkAcl = networkAcl
	return options
}

// SetPublicGateway : Allow user to set PublicGateway
func (options *UpdateSubnetOptions) SetPublicGateway(publicGateway PublicGatewayIdentityIntf) *UpdateSubnetOptions {
	options.PublicGateway = publicGateway
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSubnetOptions) SetHeaders(param map[string]string) *UpdateSubnetOptions {
	options.Headers = param
	return options
}

// UpdateVolumeAttachmentOptions : The UpdateVolumeAttachment options.
type UpdateVolumeAttachmentOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The volume attachment identifier.
	ID *string `json:"id" validate:"required"`

	// If set to true, when deleting the instance the volume will also be deleted.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete,omitempty"`

	// The user-defined name for this volume attachment.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVolumeAttachmentOptions : Instantiate UpdateVolumeAttachmentOptions
func (*VpcV1) NewUpdateVolumeAttachmentOptions(instanceID string, id string) *UpdateVolumeAttachmentOptions {
	return &UpdateVolumeAttachmentOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *UpdateVolumeAttachmentOptions) SetInstanceID(instanceID string) *UpdateVolumeAttachmentOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateVolumeAttachmentOptions) SetID(id string) *UpdateVolumeAttachmentOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetDeleteVolumeOnInstanceDelete : Allow user to set DeleteVolumeOnInstanceDelete
func (options *UpdateVolumeAttachmentOptions) SetDeleteVolumeOnInstanceDelete(deleteVolumeOnInstanceDelete bool) *UpdateVolumeAttachmentOptions {
	options.DeleteVolumeOnInstanceDelete = core.BoolPtr(deleteVolumeOnInstanceDelete)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateVolumeAttachmentOptions) SetName(name string) *UpdateVolumeAttachmentOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVolumeAttachmentOptions) SetHeaders(param map[string]string) *UpdateVolumeAttachmentOptions {
	options.Headers = param
	return options
}

// UpdateVolumeOptions : The UpdateVolume options.
type UpdateVolumeOptions struct {
	// The volume identifier.
	ID *string `json:"id" validate:"required"`

	// The unique user-defined name for this volume.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVolumeOptions : Instantiate UpdateVolumeOptions
func (*VpcV1) NewUpdateVolumeOptions(id string) *UpdateVolumeOptions {
	return &UpdateVolumeOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateVolumeOptions) SetID(id string) *UpdateVolumeOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateVolumeOptions) SetName(name string) *UpdateVolumeOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVolumeOptions) SetHeaders(param map[string]string) *UpdateVolumeOptions {
	options.Headers = param
	return options
}

// UpdateVpcAddressPrefixOptions : The UpdateVpcAddressPrefix options.
type UpdateVpcAddressPrefixOptions struct {
	// The VPC identifier.
	VpcID *string `json:"vpc_id" validate:"required"`

	// The prefix identifier.
	ID *string `json:"id" validate:"required"`

	// Indicates whether this is the default prefix for this zone in this VPC. Updating to true makes this prefix the
	// default prefix for this zone in this VPC, provided the VPC currently has no default address prefix for this zone.
	// Updating to false removes the default prefix for this zone in this VPC.
	IsDefault *bool `json:"is_default,omitempty"`

	// The user-defined name for this address prefix. Names must be unique within the VPC the address prefix resides in.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVpcAddressPrefixOptions : Instantiate UpdateVpcAddressPrefixOptions
func (*VpcV1) NewUpdateVpcAddressPrefixOptions(vpcID string, id string) *UpdateVpcAddressPrefixOptions {
	return &UpdateVpcAddressPrefixOptions{
		VpcID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVpcID : Allow user to set VpcID
func (options *UpdateVpcAddressPrefixOptions) SetVpcID(vpcID string) *UpdateVpcAddressPrefixOptions {
	options.VpcID = core.StringPtr(vpcID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateVpcAddressPrefixOptions) SetID(id string) *UpdateVpcAddressPrefixOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetIsDefault : Allow user to set IsDefault
func (options *UpdateVpcAddressPrefixOptions) SetIsDefault(isDefault bool) *UpdateVpcAddressPrefixOptions {
	options.IsDefault = core.BoolPtr(isDefault)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateVpcAddressPrefixOptions) SetName(name string) *UpdateVpcAddressPrefixOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVpcAddressPrefixOptions) SetHeaders(param map[string]string) *UpdateVpcAddressPrefixOptions {
	options.Headers = param
	return options
}

// UpdateVpcOptions : The UpdateVpc options.
type UpdateVpcOptions struct {
	// The VPC identifier.
	ID *string `json:"id" validate:"required"`

	// The unique user-defined name for this VPC.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVpcOptions : Instantiate UpdateVpcOptions
func (*VpcV1) NewUpdateVpcOptions(id string) *UpdateVpcOptions {
	return &UpdateVpcOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateVpcOptions) SetID(id string) *UpdateVpcOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateVpcOptions) SetName(name string) *UpdateVpcOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVpcOptions) SetHeaders(param map[string]string) *UpdateVpcOptions {
	options.Headers = param
	return options
}

// UpdateVpcRouteOptions : The UpdateVpcRoute options.
type UpdateVpcRouteOptions struct {
	// The VPC identifier.
	VpcID *string `json:"vpc_id" validate:"required"`

	// The route identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this route. Names must be unique within the VPC routing table the route resides in.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVpcRouteOptions : Instantiate UpdateVpcRouteOptions
func (*VpcV1) NewUpdateVpcRouteOptions(vpcID string, id string) *UpdateVpcRouteOptions {
	return &UpdateVpcRouteOptions{
		VpcID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVpcID : Allow user to set VpcID
func (options *UpdateVpcRouteOptions) SetVpcID(vpcID string) *UpdateVpcRouteOptions {
	options.VpcID = core.StringPtr(vpcID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateVpcRouteOptions) SetID(id string) *UpdateVpcRouteOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateVpcRouteOptions) SetName(name string) *UpdateVpcRouteOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVpcRouteOptions) SetHeaders(param map[string]string) *UpdateVpcRouteOptions {
	options.Headers = param
	return options
}

// UpdateVpnGatewayConnectionOptions : The UpdateVpnGatewayConnection options.
type UpdateVpnGatewayConnectionOptions struct {
	// The VPN gateway identifier.
	VpnGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// If set to false, the VPN connection is shut down.
	AdminStateUp *bool `json:"admin_state_up,omitempty"`

	// The Dead Peer Detection settings.
	DeadPeerDetection *VPNGatewayConnectionDPDPrototype `json:"dead_peer_detection,omitempty"`

	// Optional IKE policy configuration. The absence of a policy indicates autonegotiation.
	IkePolicy IKEPolicyIdentityIntf `json:"ike_policy,omitempty"`

	// Optional IPsec policy configuration. The absence of a policy indicates
	// autonegotiation.
	IpsecPolicy IPsecPolicyIdentityIntf `json:"ipsec_policy,omitempty"`

	// The user-defined name for this VPN connection.
	Name *string `json:"name,omitempty"`

	// The IP address of the peer VPN gateway.
	PeerAddress *string `json:"peer_address,omitempty"`

	// The preshared key.
	Psk *string `json:"psk,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVpnGatewayConnectionOptions : Instantiate UpdateVpnGatewayConnectionOptions
func (*VpcV1) NewUpdateVpnGatewayConnectionOptions(vpnGatewayID string, id string) *UpdateVpnGatewayConnectionOptions {
	return &UpdateVpnGatewayConnectionOptions{
		VpnGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
	}
}

// SetVpnGatewayID : Allow user to set VpnGatewayID
func (options *UpdateVpnGatewayConnectionOptions) SetVpnGatewayID(vpnGatewayID string) *UpdateVpnGatewayConnectionOptions {
	options.VpnGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateVpnGatewayConnectionOptions) SetID(id string) *UpdateVpnGatewayConnectionOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetAdminStateUp : Allow user to set AdminStateUp
func (options *UpdateVpnGatewayConnectionOptions) SetAdminStateUp(adminStateUp bool) *UpdateVpnGatewayConnectionOptions {
	options.AdminStateUp = core.BoolPtr(adminStateUp)
	return options
}

// SetDeadPeerDetection : Allow user to set DeadPeerDetection
func (options *UpdateVpnGatewayConnectionOptions) SetDeadPeerDetection(deadPeerDetection *VPNGatewayConnectionDPDPrototype) *UpdateVpnGatewayConnectionOptions {
	options.DeadPeerDetection = deadPeerDetection
	return options
}

// SetIkePolicy : Allow user to set IkePolicy
func (options *UpdateVpnGatewayConnectionOptions) SetIkePolicy(ikePolicy IKEPolicyIdentityIntf) *UpdateVpnGatewayConnectionOptions {
	options.IkePolicy = ikePolicy
	return options
}

// SetIpsecPolicy : Allow user to set IpsecPolicy
func (options *UpdateVpnGatewayConnectionOptions) SetIpsecPolicy(ipsecPolicy IPsecPolicyIdentityIntf) *UpdateVpnGatewayConnectionOptions {
	options.IpsecPolicy = ipsecPolicy
	return options
}

// SetName : Allow user to set Name
func (options *UpdateVpnGatewayConnectionOptions) SetName(name string) *UpdateVpnGatewayConnectionOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetPeerAddress : Allow user to set PeerAddress
func (options *UpdateVpnGatewayConnectionOptions) SetPeerAddress(peerAddress string) *UpdateVpnGatewayConnectionOptions {
	options.PeerAddress = core.StringPtr(peerAddress)
	return options
}

// SetPsk : Allow user to set Psk
func (options *UpdateVpnGatewayConnectionOptions) SetPsk(psk string) *UpdateVpnGatewayConnectionOptions {
	options.Psk = core.StringPtr(psk)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVpnGatewayConnectionOptions) SetHeaders(param map[string]string) *UpdateVpnGatewayConnectionOptions {
	options.Headers = param
	return options
}

// UpdateVpnGatewayOptions : The UpdateVpnGateway options.
type UpdateVpnGatewayOptions struct {
	// The VPN gateway identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this VPN gateway.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVpnGatewayOptions : Instantiate UpdateVpnGatewayOptions
func (*VpcV1) NewUpdateVpnGatewayOptions(id string) *UpdateVpnGatewayOptions {
	return &UpdateVpnGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateVpnGatewayOptions) SetID(id string) *UpdateVpnGatewayOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateVpnGatewayOptions) SetName(name string) *UpdateVpnGatewayOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVpnGatewayOptions) SetHeaders(param map[string]string) *UpdateVpnGatewayOptions {
	options.Headers = param
	return options
}

// VPC : VPC struct
type VPC struct {
	// Indicates whether this VPC is connected to Classic Infrastructure. If true, this VPC's resources have private
	// network connectivity to the account's Classic Infrastructure resources. Only one VPC, per region, may be connected
	// in this way. This value is set at creation and subsequently immutable.
	ClassicAccess *bool `json:"classic_access" validate:"required"`

	// The date and time that the VPC was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this VPC.
	Crn *string `json:"crn" validate:"required"`

	// Array of CSE ([Cloud Service Endpoint](https://cloud.ibm.com/docs/resources?topic=resources-service-endpoints))
	// source IP addresses for the VPC. The VPC will have one CSE source IP address per zone.
	CseSourceIps []VPCCSESourceIP `json:"cse_source_ips,omitempty"`

	// The default network ACL to use for subnets created in this VPC.
	DefaultNetworkAcl *NetworkACLReference `json:"default_network_acl" validate:"required"`

	// The default security group to use for network interfaces created in this VPC.
	DefaultSecurityGroup *SecurityGroupReference `json:"default_security_group" validate:"required"`

	// The URL for this VPC.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPC.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this VPC.
	Name *string `json:"name" validate:"required"`

	// The resource group for this VPC.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The status of this VPC.
	Status *string `json:"status" validate:"required"`
}

// Constants associated with the VPC.Status property.
// The status of this VPC.
const (
	VPC_Status_Available = "available"
	VPC_Status_Deleting  = "deleting"
	VPC_Status_Failed    = "failed"
	VPC_Status_Pending   = "pending"
)

// UnmarshalVPC constructs an instance of VPC from the specified map.
func UnmarshalVPC(m map[string]interface{}) (result *VPC, err error) {
	obj := new(VPC)
	obj.ClassicAccess, err = core.UnmarshalBool(m, "classic_access")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.CseSourceIps, err = UnmarshalVPCCSESourceIPSliceAsProperty(m, "cse_source_ips")
	if err != nil {
		return
	}
	obj.DefaultNetworkAcl, err = UnmarshalNetworkACLReferenceAsProperty(m, "default_network_acl")
	if err != nil {
		return
	}
	obj.DefaultSecurityGroup, err = UnmarshalSecurityGroupReferenceAsProperty(m, "default_security_group")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupReferenceAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Status, err = core.UnmarshalString(m, "status")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPCSlice unmarshals a slice of VPC instances from the specified list of maps.
func UnmarshalVPCSlice(s []interface{}) (slice []VPC, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPC'")
			return
		}
		obj, e := UnmarshalVPC(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPCAsProperty unmarshals an instance of VPC that is stored as a property
// within the specified map.
func UnmarshalVPCAsProperty(m map[string]interface{}, propertyName string) (result *VPC, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPC'", propertyName)
			return
		}
		result, err = UnmarshalVPC(objMap)
	}
	return
}

// UnmarshalVPCSliceAsProperty unmarshals a slice of VPC instances that are stored as a property
// within the specified map.
func UnmarshalVPCSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPC, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPC'", propertyName)
			return
		}
		slice, err = UnmarshalVPCSlice(vSlice)
	}
	return
}

// VPCCSESourceIP : VPCCSESourceIP struct
type VPCCSESourceIP struct {
	// The Cloud Service Endpoint source IP address for this zone.
	Ip *IP `json:"ip" validate:"required"`

	// The zone this Cloud Service Endpoint source IP belongs to.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// UnmarshalVPCCSESourceIP constructs an instance of VPCCSESourceIP from the specified map.
func UnmarshalVPCCSESourceIP(m map[string]interface{}) (result *VPCCSESourceIP, err error) {
	obj := new(VPCCSESourceIP)
	obj.Ip, err = UnmarshalIPAsProperty(m, "ip")
	if err != nil {
		return
	}
	obj.Zone, err = UnmarshalZoneReferenceAsProperty(m, "zone")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPCCSESourceIPSlice unmarshals a slice of VPCCSESourceIP instances from the specified list of maps.
func UnmarshalVPCCSESourceIPSlice(s []interface{}) (slice []VPCCSESourceIP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPCCSESourceIP'")
			return
		}
		obj, e := UnmarshalVPCCSESourceIP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPCCSESourceIPAsProperty unmarshals an instance of VPCCSESourceIP that is stored as a property
// within the specified map.
func UnmarshalVPCCSESourceIPAsProperty(m map[string]interface{}, propertyName string) (result *VPCCSESourceIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPCCSESourceIP'", propertyName)
			return
		}
		result, err = UnmarshalVPCCSESourceIP(objMap)
	}
	return
}

// UnmarshalVPCCSESourceIPSliceAsProperty unmarshals a slice of VPCCSESourceIP instances that are stored as a property
// within the specified map.
func UnmarshalVPCCSESourceIPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPCCSESourceIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPCCSESourceIP'", propertyName)
			return
		}
		slice, err = UnmarshalVPCCSESourceIPSlice(vSlice)
	}
	return
}

// VPCCollection : VPCCollection struct
type VPCCollection struct {
	// A reference to the first page of resources.
	First *VPCCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *VPCCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Collection of VPCs.
	Vpcs []VPC `json:"vpcs" validate:"required"`
}

// UnmarshalVPCCollection constructs an instance of VPCCollection from the specified map.
func UnmarshalVPCCollection(m map[string]interface{}) (result *VPCCollection, err error) {
	obj := new(VPCCollection)
	obj.First, err = UnmarshalVPCCollectionFirstAsProperty(m, "first")
	if err != nil {
		return
	}
	obj.Limit, err = core.UnmarshalInt64(m, "limit")
	if err != nil {
		return
	}
	obj.Next, err = UnmarshalVPCCollectionNextAsProperty(m, "next")
	if err != nil {
		return
	}
	obj.TotalCount, err = core.UnmarshalInt64(m, "total_count")
	if err != nil {
		return
	}
	obj.Vpcs, err = UnmarshalVPCSliceAsProperty(m, "vpcs")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPCCollectionSlice unmarshals a slice of VPCCollection instances from the specified list of maps.
func UnmarshalVPCCollectionSlice(s []interface{}) (slice []VPCCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPCCollection'")
			return
		}
		obj, e := UnmarshalVPCCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPCCollectionAsProperty unmarshals an instance of VPCCollection that is stored as a property
// within the specified map.
func UnmarshalVPCCollectionAsProperty(m map[string]interface{}, propertyName string) (result *VPCCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPCCollection'", propertyName)
			return
		}
		result, err = UnmarshalVPCCollection(objMap)
	}
	return
}

// UnmarshalVPCCollectionSliceAsProperty unmarshals a slice of VPCCollection instances that are stored as a property
// within the specified map.
func UnmarshalVPCCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPCCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPCCollection'", propertyName)
			return
		}
		slice, err = UnmarshalVPCCollectionSlice(vSlice)
	}
	return
}

// VPCCollectionFirst : A reference to the first page of resources.
type VPCCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVPCCollectionFirst constructs an instance of VPCCollectionFirst from the specified map.
func UnmarshalVPCCollectionFirst(m map[string]interface{}) (result *VPCCollectionFirst, err error) {
	obj := new(VPCCollectionFirst)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPCCollectionFirstSlice unmarshals a slice of VPCCollectionFirst instances from the specified list of maps.
func UnmarshalVPCCollectionFirstSlice(s []interface{}) (slice []VPCCollectionFirst, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPCCollectionFirst'")
			return
		}
		obj, e := UnmarshalVPCCollectionFirst(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPCCollectionFirstAsProperty unmarshals an instance of VPCCollectionFirst that is stored as a property
// within the specified map.
func UnmarshalVPCCollectionFirstAsProperty(m map[string]interface{}, propertyName string) (result *VPCCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPCCollectionFirst'", propertyName)
			return
		}
		result, err = UnmarshalVPCCollectionFirst(objMap)
	}
	return
}

// UnmarshalVPCCollectionFirstSliceAsProperty unmarshals a slice of VPCCollectionFirst instances that are stored as a property
// within the specified map.
func UnmarshalVPCCollectionFirstSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPCCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPCCollectionFirst'", propertyName)
			return
		}
		slice, err = UnmarshalVPCCollectionFirstSlice(vSlice)
	}
	return
}

// VPCCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type VPCCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVPCCollectionNext constructs an instance of VPCCollectionNext from the specified map.
func UnmarshalVPCCollectionNext(m map[string]interface{}) (result *VPCCollectionNext, err error) {
	obj := new(VPCCollectionNext)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPCCollectionNextSlice unmarshals a slice of VPCCollectionNext instances from the specified list of maps.
func UnmarshalVPCCollectionNextSlice(s []interface{}) (slice []VPCCollectionNext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPCCollectionNext'")
			return
		}
		obj, e := UnmarshalVPCCollectionNext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPCCollectionNextAsProperty unmarshals an instance of VPCCollectionNext that is stored as a property
// within the specified map.
func UnmarshalVPCCollectionNextAsProperty(m map[string]interface{}, propertyName string) (result *VPCCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPCCollectionNext'", propertyName)
			return
		}
		result, err = UnmarshalVPCCollectionNext(objMap)
	}
	return
}

// UnmarshalVPCCollectionNextSliceAsProperty unmarshals a slice of VPCCollectionNext instances that are stored as a property
// within the specified map.
func UnmarshalVPCCollectionNextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPCCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPCCollectionNext'", propertyName)
			return
		}
		slice, err = UnmarshalVPCCollectionNextSlice(vSlice)
	}
	return
}

// VPCIdentity : Identifies a VPC by a unique property.
// Models which "extend" this model:
// - VPCIdentityByID
// - VPCIdentityByCRN
// - VPCIdentityByHref
type VPCIdentity struct {
	// The unique identifier for this VPC.
	ID *string `json:"id,omitempty"`

	// The CRN for this VPC.
	Crn *string `json:"crn,omitempty"`

	// The URL for this VPC.
	Href *string `json:"href,omitempty"`
}

func (*VPCIdentity) isaVPCIdentity() bool {
	return true
}

type VPCIdentityIntf interface {
	isaVPCIdentity() bool
}

// UnmarshalVPCIdentity constructs an instance of VPCIdentity from the specified map.
func UnmarshalVPCIdentity(m map[string]interface{}) (result VPCIdentityIntf, err error) {
	obj := new(VPCIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPCIdentitySlice unmarshals a slice of VPCIdentity instances from the specified list of maps.
func UnmarshalVPCIdentitySlice(s []interface{}) (slice []VPCIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPCIdentity'")
			return
		}
		obj, e := UnmarshalVPCIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalVPCIdentityAsProperty unmarshals an instance of VPCIdentity that is stored as a property
// within the specified map.
func UnmarshalVPCIdentityAsProperty(m map[string]interface{}, propertyName string) (result VPCIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPCIdentity'", propertyName)
			return
		}
		result, err = UnmarshalVPCIdentity(objMap)
	}
	return
}

// UnmarshalVPCIdentitySliceAsProperty unmarshals a slice of VPCIdentity instances that are stored as a property
// within the specified map.
func UnmarshalVPCIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPCIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPCIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalVPCIdentitySlice(vSlice)
	}
	return
}

// VPCReference : VPCReference struct
type VPCReference struct {
	// The CRN for this VPC.
	Crn *string `json:"crn" validate:"required"`

	// The URL for this VPC.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPC.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this VPC.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalVPCReference constructs an instance of VPCReference from the specified map.
func UnmarshalVPCReference(m map[string]interface{}) (result *VPCReference, err error) {
	obj := new(VPCReference)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPCReferenceSlice unmarshals a slice of VPCReference instances from the specified list of maps.
func UnmarshalVPCReferenceSlice(s []interface{}) (slice []VPCReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPCReference'")
			return
		}
		obj, e := UnmarshalVPCReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPCReferenceAsProperty unmarshals an instance of VPCReference that is stored as a property
// within the specified map.
func UnmarshalVPCReferenceAsProperty(m map[string]interface{}, propertyName string) (result *VPCReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPCReference'", propertyName)
			return
		}
		result, err = UnmarshalVPCReference(objMap)
	}
	return
}

// UnmarshalVPCReferenceSliceAsProperty unmarshals a slice of VPCReference instances that are stored as a property
// within the specified map.
func UnmarshalVPCReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPCReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPCReference'", propertyName)
			return
		}
		slice, err = UnmarshalVPCReferenceSlice(vSlice)
	}
	return
}

// VPNGateway : VPNGateway struct
type VPNGateway struct {
	// Collection of references to VPN connections.
	Connections []VPNGatewayConnectionReference `json:"connections" validate:"required"`

	// The date and time that this VPN gateway was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The VPN gateway's CRN.
	Crn *string `json:"crn" validate:"required"`

	// The VPN gateway's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN gateway.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this VPN gateway.
	Name *string `json:"name" validate:"required"`

	// The public IP address assigned to this VPN gateway.
	PublicIp *VPNGatewayPublicIp `json:"public_ip" validate:"required"`

	// The resource group for this VPN gateway.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The status of the VPN gateway.
	Status *string `json:"status" validate:"required"`

	Subnet *SubnetReference `json:"subnet" validate:"required"`
}

// Constants associated with the VPNGateway.Status property.
// The status of the VPN gateway.
const (
	VPNGateway_Status_Available = "available"
	VPNGateway_Status_Deleting  = "deleting"
	VPNGateway_Status_Failed    = "failed"
	VPNGateway_Status_Pending   = "pending"
)

// UnmarshalVPNGateway constructs an instance of VPNGateway from the specified map.
func UnmarshalVPNGateway(m map[string]interface{}) (result *VPNGateway, err error) {
	obj := new(VPNGateway)
	obj.Connections, err = UnmarshalVPNGatewayConnectionReferenceSliceAsProperty(m, "connections")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.PublicIp, err = UnmarshalVPNGatewayPublicIpAsProperty(m, "public_ip")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupReferenceAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Status, err = core.UnmarshalString(m, "status")
	if err != nil {
		return
	}
	obj.Subnet, err = UnmarshalSubnetReferenceAsProperty(m, "subnet")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPNGatewaySlice unmarshals a slice of VPNGateway instances from the specified list of maps.
func UnmarshalVPNGatewaySlice(s []interface{}) (slice []VPNGateway, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPNGateway'")
			return
		}
		obj, e := UnmarshalVPNGateway(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPNGatewayAsProperty unmarshals an instance of VPNGateway that is stored as a property
// within the specified map.
func UnmarshalVPNGatewayAsProperty(m map[string]interface{}, propertyName string) (result *VPNGateway, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPNGateway'", propertyName)
			return
		}
		result, err = UnmarshalVPNGateway(objMap)
	}
	return
}

// UnmarshalVPNGatewaySliceAsProperty unmarshals a slice of VPNGateway instances that are stored as a property
// within the specified map.
func UnmarshalVPNGatewaySliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPNGateway, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPNGateway'", propertyName)
			return
		}
		slice, err = UnmarshalVPNGatewaySlice(vSlice)
	}
	return
}

// VPNGatewayCollection : VPNGatewayCollection struct
type VPNGatewayCollection struct {
	// A reference to the first page of resources.
	First *VPNGatewayCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *VPNGatewayCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Collection of VPN gateways.
	VpnGateways []VPNGateway `json:"vpn_gateways" validate:"required"`
}

// UnmarshalVPNGatewayCollection constructs an instance of VPNGatewayCollection from the specified map.
func UnmarshalVPNGatewayCollection(m map[string]interface{}) (result *VPNGatewayCollection, err error) {
	obj := new(VPNGatewayCollection)
	obj.First, err = UnmarshalVPNGatewayCollectionFirstAsProperty(m, "first")
	if err != nil {
		return
	}
	obj.Limit, err = core.UnmarshalInt64(m, "limit")
	if err != nil {
		return
	}
	obj.Next, err = UnmarshalVPNGatewayCollectionNextAsProperty(m, "next")
	if err != nil {
		return
	}
	obj.TotalCount, err = core.UnmarshalInt64(m, "total_count")
	if err != nil {
		return
	}
	obj.VpnGateways, err = UnmarshalVPNGatewaySliceAsProperty(m, "vpn_gateways")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPNGatewayCollectionSlice unmarshals a slice of VPNGatewayCollection instances from the specified list of maps.
func UnmarshalVPNGatewayCollectionSlice(s []interface{}) (slice []VPNGatewayCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPNGatewayCollection'")
			return
		}
		obj, e := UnmarshalVPNGatewayCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPNGatewayCollectionAsProperty unmarshals an instance of VPNGatewayCollection that is stored as a property
// within the specified map.
func UnmarshalVPNGatewayCollectionAsProperty(m map[string]interface{}, propertyName string) (result *VPNGatewayCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPNGatewayCollection'", propertyName)
			return
		}
		result, err = UnmarshalVPNGatewayCollection(objMap)
	}
	return
}

// UnmarshalVPNGatewayCollectionSliceAsProperty unmarshals a slice of VPNGatewayCollection instances that are stored as a property
// within the specified map.
func UnmarshalVPNGatewayCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPNGatewayCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPNGatewayCollection'", propertyName)
			return
		}
		slice, err = UnmarshalVPNGatewayCollectionSlice(vSlice)
	}
	return
}

// VPNGatewayCollectionFirst : A reference to the first page of resources.
type VPNGatewayCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVPNGatewayCollectionFirst constructs an instance of VPNGatewayCollectionFirst from the specified map.
func UnmarshalVPNGatewayCollectionFirst(m map[string]interface{}) (result *VPNGatewayCollectionFirst, err error) {
	obj := new(VPNGatewayCollectionFirst)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPNGatewayCollectionFirstSlice unmarshals a slice of VPNGatewayCollectionFirst instances from the specified list of maps.
func UnmarshalVPNGatewayCollectionFirstSlice(s []interface{}) (slice []VPNGatewayCollectionFirst, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPNGatewayCollectionFirst'")
			return
		}
		obj, e := UnmarshalVPNGatewayCollectionFirst(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPNGatewayCollectionFirstAsProperty unmarshals an instance of VPNGatewayCollectionFirst that is stored as a property
// within the specified map.
func UnmarshalVPNGatewayCollectionFirstAsProperty(m map[string]interface{}, propertyName string) (result *VPNGatewayCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPNGatewayCollectionFirst'", propertyName)
			return
		}
		result, err = UnmarshalVPNGatewayCollectionFirst(objMap)
	}
	return
}

// UnmarshalVPNGatewayCollectionFirstSliceAsProperty unmarshals a slice of VPNGatewayCollectionFirst instances that are stored as a property
// within the specified map.
func UnmarshalVPNGatewayCollectionFirstSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPNGatewayCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPNGatewayCollectionFirst'", propertyName)
			return
		}
		slice, err = UnmarshalVPNGatewayCollectionFirstSlice(vSlice)
	}
	return
}

// VPNGatewayCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type VPNGatewayCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVPNGatewayCollectionNext constructs an instance of VPNGatewayCollectionNext from the specified map.
func UnmarshalVPNGatewayCollectionNext(m map[string]interface{}) (result *VPNGatewayCollectionNext, err error) {
	obj := new(VPNGatewayCollectionNext)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPNGatewayCollectionNextSlice unmarshals a slice of VPNGatewayCollectionNext instances from the specified list of maps.
func UnmarshalVPNGatewayCollectionNextSlice(s []interface{}) (slice []VPNGatewayCollectionNext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPNGatewayCollectionNext'")
			return
		}
		obj, e := UnmarshalVPNGatewayCollectionNext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPNGatewayCollectionNextAsProperty unmarshals an instance of VPNGatewayCollectionNext that is stored as a property
// within the specified map.
func UnmarshalVPNGatewayCollectionNextAsProperty(m map[string]interface{}, propertyName string) (result *VPNGatewayCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPNGatewayCollectionNext'", propertyName)
			return
		}
		result, err = UnmarshalVPNGatewayCollectionNext(objMap)
	}
	return
}

// UnmarshalVPNGatewayCollectionNextSliceAsProperty unmarshals a slice of VPNGatewayCollectionNext instances that are stored as a property
// within the specified map.
func UnmarshalVPNGatewayCollectionNextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPNGatewayCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPNGatewayCollectionNext'", propertyName)
			return
		}
		slice, err = UnmarshalVPNGatewayCollectionNextSlice(vSlice)
	}
	return
}

// VPNGatewayConnection : VPNGatewayConnection struct
type VPNGatewayConnection struct {
	// If set to false, the VPN connection is shut down.
	AdminStateUp *bool `json:"admin_state_up" validate:"required"`

	// The authentication mode. Only `psk` is currently supported.
	AuthenticationMode *string `json:"authentication_mode" validate:"required"`

	// The date and time that this VPN connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The Dead Peer Detection settings.
	DeadPeerDetection *VPNGatewayConnectionDPD `json:"dead_peer_detection" validate:"required"`

	// The VPN connection's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN connection.
	ID *string `json:"id" validate:"required"`

	// Optional IKE policy configuration. The absence of a policy indicates autonegotiation.
	IkePolicy IKEPolicyIdentityIntf `json:"ike_policy,omitempty"`

	// Optional IPsec policy configuration. The absence of a policy indicates
	// autonegotiation.
	IpsecPolicy IPsecPolicyIdentityIntf `json:"ipsec_policy,omitempty"`

	// A collection of local CIDRs for this resource.
	LocalCidrs []string `json:"local_cidrs" validate:"required"`

	// The user-defined name for this VPN connection.
	Name *string `json:"name" validate:"required"`

	// The IP address of the peer VPN gateway.
	PeerAddress *string `json:"peer_address" validate:"required"`

	// A collection of peer CIDRs for this resource.
	PeerCidrs []string `json:"peer_cidrs" validate:"required"`

	// The preshared key.
	Psk *string `json:"psk" validate:"required"`

	// The routing mode. Only `policy` is currently supported.
	RouteMode *string `json:"route_mode" validate:"required"`

	// The status of a VPN connection.
	Status *string `json:"status" validate:"required"`
}

// Constants associated with the VPNGatewayConnection.AuthenticationMode property.
// The authentication mode. Only `psk` is currently supported.
const (
	VPNGatewayConnection_AuthenticationMode_Psk = "psk"
)

// Constants associated with the VPNGatewayConnection.RouteMode property.
// The routing mode. Only `policy` is currently supported.
const (
	VPNGatewayConnection_RouteMode_Policy = "policy"
)

// Constants associated with the VPNGatewayConnection.Status property.
// The status of a VPN connection.
const (
	VPNGatewayConnection_Status_Down = "down"
	VPNGatewayConnection_Status_Up   = "up"
)

// UnmarshalVPNGatewayConnection constructs an instance of VPNGatewayConnection from the specified map.
func UnmarshalVPNGatewayConnection(m map[string]interface{}) (result *VPNGatewayConnection, err error) {
	obj := new(VPNGatewayConnection)
	obj.AdminStateUp, err = core.UnmarshalBool(m, "admin_state_up")
	if err != nil {
		return
	}
	obj.AuthenticationMode, err = core.UnmarshalString(m, "authentication_mode")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.DeadPeerDetection, err = UnmarshalVPNGatewayConnectionDPDAsProperty(m, "dead_peer_detection")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IkePolicy, err = UnmarshalIKEPolicyIdentityAsProperty(m, "ike_policy")
	if err != nil {
		return
	}
	obj.IpsecPolicy, err = UnmarshalIPsecPolicyIdentityAsProperty(m, "ipsec_policy")
	if err != nil {
		return
	}
	obj.LocalCidrs, err = core.UnmarshalStringSlice(m, "local_cidrs")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.PeerAddress, err = core.UnmarshalString(m, "peer_address")
	if err != nil {
		return
	}
	obj.PeerCidrs, err = core.UnmarshalStringSlice(m, "peer_cidrs")
	if err != nil {
		return
	}
	obj.Psk, err = core.UnmarshalString(m, "psk")
	if err != nil {
		return
	}
	obj.RouteMode, err = core.UnmarshalString(m, "route_mode")
	if err != nil {
		return
	}
	obj.Status, err = core.UnmarshalString(m, "status")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPNGatewayConnectionSlice unmarshals a slice of VPNGatewayConnection instances from the specified list of maps.
func UnmarshalVPNGatewayConnectionSlice(s []interface{}) (slice []VPNGatewayConnection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPNGatewayConnection'")
			return
		}
		obj, e := UnmarshalVPNGatewayConnection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPNGatewayConnectionAsProperty unmarshals an instance of VPNGatewayConnection that is stored as a property
// within the specified map.
func UnmarshalVPNGatewayConnectionAsProperty(m map[string]interface{}, propertyName string) (result *VPNGatewayConnection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPNGatewayConnection'", propertyName)
			return
		}
		result, err = UnmarshalVPNGatewayConnection(objMap)
	}
	return
}

// UnmarshalVPNGatewayConnectionSliceAsProperty unmarshals a slice of VPNGatewayConnection instances that are stored as a property
// within the specified map.
func UnmarshalVPNGatewayConnectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPNGatewayConnection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPNGatewayConnection'", propertyName)
			return
		}
		slice, err = UnmarshalVPNGatewayConnectionSlice(vSlice)
	}
	return
}

// VPNGatewayConnectionCollection : Collection of VPN connections in a VPN gateway.
type VPNGatewayConnectionCollection struct {
	// Array of VPN connections.
	Connections []VPNGatewayConnection `json:"connections" validate:"required"`
}

// UnmarshalVPNGatewayConnectionCollection constructs an instance of VPNGatewayConnectionCollection from the specified map.
func UnmarshalVPNGatewayConnectionCollection(m map[string]interface{}) (result *VPNGatewayConnectionCollection, err error) {
	obj := new(VPNGatewayConnectionCollection)
	obj.Connections, err = UnmarshalVPNGatewayConnectionSliceAsProperty(m, "connections")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPNGatewayConnectionCollectionSlice unmarshals a slice of VPNGatewayConnectionCollection instances from the specified list of maps.
func UnmarshalVPNGatewayConnectionCollectionSlice(s []interface{}) (slice []VPNGatewayConnectionCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPNGatewayConnectionCollection'")
			return
		}
		obj, e := UnmarshalVPNGatewayConnectionCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPNGatewayConnectionCollectionAsProperty unmarshals an instance of VPNGatewayConnectionCollection that is stored as a property
// within the specified map.
func UnmarshalVPNGatewayConnectionCollectionAsProperty(m map[string]interface{}, propertyName string) (result *VPNGatewayConnectionCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPNGatewayConnectionCollection'", propertyName)
			return
		}
		result, err = UnmarshalVPNGatewayConnectionCollection(objMap)
	}
	return
}

// UnmarshalVPNGatewayConnectionCollectionSliceAsProperty unmarshals a slice of VPNGatewayConnectionCollection instances that are stored as a property
// within the specified map.
func UnmarshalVPNGatewayConnectionCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPNGatewayConnectionCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPNGatewayConnectionCollection'", propertyName)
			return
		}
		slice, err = UnmarshalVPNGatewayConnectionCollectionSlice(vSlice)
	}
	return
}

// VPNGatewayConnectionDPD : The Dead Peer Detection settings.
type VPNGatewayConnectionDPD struct {
	// Dead Peer Detection actions.
	Action *string `json:"action" validate:"required"`

	// Dead Peer Detection interval in seconds.
	Interval *int64 `json:"interval" validate:"required"`

	// Dead Peer Detection timeout in seconds. Must be at least the interval.
	Timeout *int64 `json:"timeout" validate:"required"`
}

// Constants associated with the VPNGatewayConnectionDPD.Action property.
// Dead Peer Detection actions.
const (
	VPNGatewayConnectionDPD_Action_Clear   = "clear"
	VPNGatewayConnectionDPD_Action_Hold    = "hold"
	VPNGatewayConnectionDPD_Action_None    = "none"
	VPNGatewayConnectionDPD_Action_Restart = "restart"
)

// UnmarshalVPNGatewayConnectionDPD constructs an instance of VPNGatewayConnectionDPD from the specified map.
func UnmarshalVPNGatewayConnectionDPD(m map[string]interface{}) (result *VPNGatewayConnectionDPD, err error) {
	obj := new(VPNGatewayConnectionDPD)
	obj.Action, err = core.UnmarshalString(m, "action")
	if err != nil {
		return
	}
	obj.Interval, err = core.UnmarshalInt64(m, "interval")
	if err != nil {
		return
	}
	obj.Timeout, err = core.UnmarshalInt64(m, "timeout")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPNGatewayConnectionDPDSlice unmarshals a slice of VPNGatewayConnectionDPD instances from the specified list of maps.
func UnmarshalVPNGatewayConnectionDPDSlice(s []interface{}) (slice []VPNGatewayConnectionDPD, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPNGatewayConnectionDPD'")
			return
		}
		obj, e := UnmarshalVPNGatewayConnectionDPD(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPNGatewayConnectionDPDAsProperty unmarshals an instance of VPNGatewayConnectionDPD that is stored as a property
// within the specified map.
func UnmarshalVPNGatewayConnectionDPDAsProperty(m map[string]interface{}, propertyName string) (result *VPNGatewayConnectionDPD, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPNGatewayConnectionDPD'", propertyName)
			return
		}
		result, err = UnmarshalVPNGatewayConnectionDPD(objMap)
	}
	return
}

// UnmarshalVPNGatewayConnectionDPDSliceAsProperty unmarshals a slice of VPNGatewayConnectionDPD instances that are stored as a property
// within the specified map.
func UnmarshalVPNGatewayConnectionDPDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPNGatewayConnectionDPD, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPNGatewayConnectionDPD'", propertyName)
			return
		}
		slice, err = UnmarshalVPNGatewayConnectionDPDSlice(vSlice)
	}
	return
}

// VPNGatewayConnectionDPDPrototype : The Dead Peer Detection settings.
type VPNGatewayConnectionDPDPrototype struct {
	// Dead Peer Detection actions.
	Action *string `json:"action,omitempty"`

	// Dead Peer Detection interval in seconds.
	Interval *int64 `json:"interval,omitempty"`

	// Dead Peer Detection timeout in seconds. Must be at least the interval.
	Timeout *int64 `json:"timeout,omitempty"`
}

// Constants associated with the VPNGatewayConnectionDPDPrototype.Action property.
// Dead Peer Detection actions.
const (
	VPNGatewayConnectionDPDPrototype_Action_Clear   = "clear"
	VPNGatewayConnectionDPDPrototype_Action_Hold    = "hold"
	VPNGatewayConnectionDPDPrototype_Action_None    = "none"
	VPNGatewayConnectionDPDPrototype_Action_Restart = "restart"
)

// UnmarshalVPNGatewayConnectionDPDPrototype constructs an instance of VPNGatewayConnectionDPDPrototype from the specified map.
func UnmarshalVPNGatewayConnectionDPDPrototype(m map[string]interface{}) (result *VPNGatewayConnectionDPDPrototype, err error) {
	obj := new(VPNGatewayConnectionDPDPrototype)
	obj.Action, err = core.UnmarshalString(m, "action")
	if err != nil {
		return
	}
	obj.Interval, err = core.UnmarshalInt64(m, "interval")
	if err != nil {
		return
	}
	obj.Timeout, err = core.UnmarshalInt64(m, "timeout")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPNGatewayConnectionDPDPrototypeSlice unmarshals a slice of VPNGatewayConnectionDPDPrototype instances from the specified list of maps.
func UnmarshalVPNGatewayConnectionDPDPrototypeSlice(s []interface{}) (slice []VPNGatewayConnectionDPDPrototype, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPNGatewayConnectionDPDPrototype'")
			return
		}
		obj, e := UnmarshalVPNGatewayConnectionDPDPrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPNGatewayConnectionDPDPrototypeAsProperty unmarshals an instance of VPNGatewayConnectionDPDPrototype that is stored as a property
// within the specified map.
func UnmarshalVPNGatewayConnectionDPDPrototypeAsProperty(m map[string]interface{}, propertyName string) (result *VPNGatewayConnectionDPDPrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPNGatewayConnectionDPDPrototype'", propertyName)
			return
		}
		result, err = UnmarshalVPNGatewayConnectionDPDPrototype(objMap)
	}
	return
}

// UnmarshalVPNGatewayConnectionDPDPrototypeSliceAsProperty unmarshals a slice of VPNGatewayConnectionDPDPrototype instances that are stored as a property
// within the specified map.
func UnmarshalVPNGatewayConnectionDPDPrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPNGatewayConnectionDPDPrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPNGatewayConnectionDPDPrototype'", propertyName)
			return
		}
		slice, err = UnmarshalVPNGatewayConnectionDPDPrototypeSlice(vSlice)
	}
	return
}

// VPNGatewayConnectionLocalCIDRs : VPNGatewayConnectionLocalCIDRs struct
type VPNGatewayConnectionLocalCIDRs struct {
	// A collection of local CIDRs for this resource.
	LocalCidrs []string `json:"local_cidrs,omitempty"`
}

// UnmarshalVPNGatewayConnectionLocalCIDRs constructs an instance of VPNGatewayConnectionLocalCIDRs from the specified map.
func UnmarshalVPNGatewayConnectionLocalCIDRs(m map[string]interface{}) (result *VPNGatewayConnectionLocalCIDRs, err error) {
	obj := new(VPNGatewayConnectionLocalCIDRs)
	obj.LocalCidrs, err = core.UnmarshalStringSlice(m, "local_cidrs")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPNGatewayConnectionLocalCIDRsSlice unmarshals a slice of VPNGatewayConnectionLocalCIDRs instances from the specified list of maps.
func UnmarshalVPNGatewayConnectionLocalCIDRsSlice(s []interface{}) (slice []VPNGatewayConnectionLocalCIDRs, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPNGatewayConnectionLocalCIDRs'")
			return
		}
		obj, e := UnmarshalVPNGatewayConnectionLocalCIDRs(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPNGatewayConnectionLocalCIDRsAsProperty unmarshals an instance of VPNGatewayConnectionLocalCIDRs that is stored as a property
// within the specified map.
func UnmarshalVPNGatewayConnectionLocalCIDRsAsProperty(m map[string]interface{}, propertyName string) (result *VPNGatewayConnectionLocalCIDRs, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPNGatewayConnectionLocalCIDRs'", propertyName)
			return
		}
		result, err = UnmarshalVPNGatewayConnectionLocalCIDRs(objMap)
	}
	return
}

// UnmarshalVPNGatewayConnectionLocalCIDRsSliceAsProperty unmarshals a slice of VPNGatewayConnectionLocalCIDRs instances that are stored as a property
// within the specified map.
func UnmarshalVPNGatewayConnectionLocalCIDRsSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPNGatewayConnectionLocalCIDRs, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPNGatewayConnectionLocalCIDRs'", propertyName)
			return
		}
		slice, err = UnmarshalVPNGatewayConnectionLocalCIDRsSlice(vSlice)
	}
	return
}

// VPNGatewayConnectionPeerCIDRs : VPNGatewayConnectionPeerCIDRs struct
type VPNGatewayConnectionPeerCIDRs struct {
	// A collection of peer CIDRs for this resource.
	PeerCidrs []string `json:"peer_cidrs,omitempty"`
}

// UnmarshalVPNGatewayConnectionPeerCIDRs constructs an instance of VPNGatewayConnectionPeerCIDRs from the specified map.
func UnmarshalVPNGatewayConnectionPeerCIDRs(m map[string]interface{}) (result *VPNGatewayConnectionPeerCIDRs, err error) {
	obj := new(VPNGatewayConnectionPeerCIDRs)
	obj.PeerCidrs, err = core.UnmarshalStringSlice(m, "peer_cidrs")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPNGatewayConnectionPeerCIDRsSlice unmarshals a slice of VPNGatewayConnectionPeerCIDRs instances from the specified list of maps.
func UnmarshalVPNGatewayConnectionPeerCIDRsSlice(s []interface{}) (slice []VPNGatewayConnectionPeerCIDRs, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPNGatewayConnectionPeerCIDRs'")
			return
		}
		obj, e := UnmarshalVPNGatewayConnectionPeerCIDRs(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPNGatewayConnectionPeerCIDRsAsProperty unmarshals an instance of VPNGatewayConnectionPeerCIDRs that is stored as a property
// within the specified map.
func UnmarshalVPNGatewayConnectionPeerCIDRsAsProperty(m map[string]interface{}, propertyName string) (result *VPNGatewayConnectionPeerCIDRs, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPNGatewayConnectionPeerCIDRs'", propertyName)
			return
		}
		result, err = UnmarshalVPNGatewayConnectionPeerCIDRs(objMap)
	}
	return
}

// UnmarshalVPNGatewayConnectionPeerCIDRsSliceAsProperty unmarshals a slice of VPNGatewayConnectionPeerCIDRs instances that are stored as a property
// within the specified map.
func UnmarshalVPNGatewayConnectionPeerCIDRsSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPNGatewayConnectionPeerCIDRs, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPNGatewayConnectionPeerCIDRs'", propertyName)
			return
		}
		slice, err = UnmarshalVPNGatewayConnectionPeerCIDRsSlice(vSlice)
	}
	return
}

// VPNGatewayConnectionReference : VPNGatewayConnectionReference struct
type VPNGatewayConnectionReference struct {
	// The VPN connection's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN connection.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this VPN connection.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalVPNGatewayConnectionReference constructs an instance of VPNGatewayConnectionReference from the specified map.
func UnmarshalVPNGatewayConnectionReference(m map[string]interface{}) (result *VPNGatewayConnectionReference, err error) {
	obj := new(VPNGatewayConnectionReference)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPNGatewayConnectionReferenceSlice unmarshals a slice of VPNGatewayConnectionReference instances from the specified list of maps.
func UnmarshalVPNGatewayConnectionReferenceSlice(s []interface{}) (slice []VPNGatewayConnectionReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPNGatewayConnectionReference'")
			return
		}
		obj, e := UnmarshalVPNGatewayConnectionReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPNGatewayConnectionReferenceAsProperty unmarshals an instance of VPNGatewayConnectionReference that is stored as a property
// within the specified map.
func UnmarshalVPNGatewayConnectionReferenceAsProperty(m map[string]interface{}, propertyName string) (result *VPNGatewayConnectionReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPNGatewayConnectionReference'", propertyName)
			return
		}
		result, err = UnmarshalVPNGatewayConnectionReference(objMap)
	}
	return
}

// UnmarshalVPNGatewayConnectionReferenceSliceAsProperty unmarshals a slice of VPNGatewayConnectionReference instances that are stored as a property
// within the specified map.
func UnmarshalVPNGatewayConnectionReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPNGatewayConnectionReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPNGatewayConnectionReference'", propertyName)
			return
		}
		slice, err = UnmarshalVPNGatewayConnectionReferenceSlice(vSlice)
	}
	return
}

// VPNGatewayPublicIp : The public IP address assigned to this VPN gateway.
type VPNGatewayPublicIp struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// UnmarshalVPNGatewayPublicIp constructs an instance of VPNGatewayPublicIp from the specified map.
func UnmarshalVPNGatewayPublicIp(m map[string]interface{}) (result *VPNGatewayPublicIp, err error) {
	obj := new(VPNGatewayPublicIp)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPNGatewayPublicIpSlice unmarshals a slice of VPNGatewayPublicIp instances from the specified list of maps.
func UnmarshalVPNGatewayPublicIpSlice(s []interface{}) (slice []VPNGatewayPublicIp, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPNGatewayPublicIp'")
			return
		}
		obj, e := UnmarshalVPNGatewayPublicIp(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPNGatewayPublicIpAsProperty unmarshals an instance of VPNGatewayPublicIp that is stored as a property
// within the specified map.
func UnmarshalVPNGatewayPublicIpAsProperty(m map[string]interface{}, propertyName string) (result *VPNGatewayPublicIp, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPNGatewayPublicIp'", propertyName)
			return
		}
		result, err = UnmarshalVPNGatewayPublicIp(objMap)
	}
	return
}

// UnmarshalVPNGatewayPublicIpSliceAsProperty unmarshals a slice of VPNGatewayPublicIp instances that are stored as a property
// within the specified map.
func UnmarshalVPNGatewayPublicIpSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPNGatewayPublicIp, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPNGatewayPublicIp'", propertyName)
			return
		}
		slice, err = UnmarshalVPNGatewayPublicIpSlice(vSlice)
	}
	return
}

// Volume : Volume struct
type Volume struct {
	// The capacity of the volume in gigabytes.
	Capacity *int64 `json:"capacity" validate:"required"`

	// The date and time that the volume was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this volume.
	Crn *string `json:"crn" validate:"required"`

	// The type of encryption used on the volume.
	Encryption *string `json:"encryption" validate:"required"`

	// The URL for this volume.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this volume.
	ID *string `json:"id" validate:"required"`

	// The bandwidth for the volume.
	Iops *int64 `json:"iops" validate:"required"`

	// The unique user-defined name for this volume.
	Name *string `json:"name" validate:"required"`

	// The profile this volume uses.
	Profile *VolumeProfileReference `json:"profile" validate:"required"`

	// The resource group for this volume.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The status of the volume.
	Status *string `json:"status" validate:"required"`

	// The collection of volume attachments attaching instances to the volume.
	VolumeAttachments []VolumeAttachmentReferenceVolumeContext `json:"volume_attachments" validate:"required"`

	// The zone this volume resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the Volume.Encryption property.
// The type of encryption used on the volume.
const (
	Volume_Encryption_ProviderManaged = "provider_managed"
	Volume_Encryption_UserManaged     = "user_managed"
)

// Constants associated with the Volume.Status property.
// The status of the volume.
const (
	Volume_Status_Available       = "available"
	Volume_Status_Failed          = "failed"
	Volume_Status_Pending         = "pending"
	Volume_Status_PendingDeletion = "pending_deletion"
)

// UnmarshalVolume constructs an instance of Volume from the specified map.
func UnmarshalVolume(m map[string]interface{}) (result *Volume, err error) {
	obj := new(Volume)
	obj.Capacity, err = core.UnmarshalInt64(m, "capacity")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Encryption, err = core.UnmarshalString(m, "encryption")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Iops, err = core.UnmarshalInt64(m, "iops")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Profile, err = UnmarshalVolumeProfileReferenceAsProperty(m, "profile")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupReferenceAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Status, err = core.UnmarshalString(m, "status")
	if err != nil {
		return
	}
	obj.VolumeAttachments, err = UnmarshalVolumeAttachmentReferenceVolumeContextSliceAsProperty(m, "volume_attachments")
	if err != nil {
		return
	}
	obj.Zone, err = UnmarshalZoneReferenceAsProperty(m, "zone")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeSlice unmarshals a slice of Volume instances from the specified list of maps.
func UnmarshalVolumeSlice(s []interface{}) (slice []Volume, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Volume'")
			return
		}
		obj, e := UnmarshalVolume(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeAsProperty unmarshals an instance of Volume that is stored as a property
// within the specified map.
func UnmarshalVolumeAsProperty(m map[string]interface{}, propertyName string) (result *Volume, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Volume'", propertyName)
			return
		}
		result, err = UnmarshalVolume(objMap)
	}
	return
}

// UnmarshalVolumeSliceAsProperty unmarshals a slice of Volume instances that are stored as a property
// within the specified map.
func UnmarshalVolumeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Volume, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Volume'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeSlice(vSlice)
	}
	return
}

// VolumeAttachment : VolumeAttachment struct
type VolumeAttachment struct {
	// The date and time that the volume was attached.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// If set to true, when deleting the instance the volume will also be deleted.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete,omitempty"`

	// Information about how the volume is exposed to the instance operating system.
	//
	// This property may be absent if the volume attachment's `status` is not `attached`.
	Device *VolumeAttachmentDevice `json:"device,omitempty"`

	// The URL for this volume attachment.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this volume attachment.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this volume attachment.
	Name *string `json:"name" validate:"required"`

	// The status of this volume attachment.
	Status *string `json:"status" validate:"required"`

	// The type of volume attachment.
	Type *string `json:"type" validate:"required"`

	// The attached volume.
	Volume *VolumeReference `json:"volume" validate:"required"`
}

// Constants associated with the VolumeAttachment.Status property.
// The status of this volume attachment.
const (
	VolumeAttachment_Status_Attached  = "attached"
	VolumeAttachment_Status_Attaching = "attaching"
	VolumeAttachment_Status_Detaching = "detaching"
)

// Constants associated with the VolumeAttachment.Type property.
// The type of volume attachment.
const (
	VolumeAttachment_Type_Boot = "boot"
	VolumeAttachment_Type_Data = "data"
)

// UnmarshalVolumeAttachment constructs an instance of VolumeAttachment from the specified map.
func UnmarshalVolumeAttachment(m map[string]interface{}) (result *VolumeAttachment, err error) {
	obj := new(VolumeAttachment)
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.DeleteVolumeOnInstanceDelete, err = core.UnmarshalBool(m, "delete_volume_on_instance_delete")
	if err != nil {
		return
	}
	obj.Device, err = UnmarshalVolumeAttachmentDeviceAsProperty(m, "device")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Status, err = core.UnmarshalString(m, "status")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.Volume, err = UnmarshalVolumeReferenceAsProperty(m, "volume")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeAttachmentSlice unmarshals a slice of VolumeAttachment instances from the specified list of maps.
func UnmarshalVolumeAttachmentSlice(s []interface{}) (slice []VolumeAttachment, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeAttachment'")
			return
		}
		obj, e := UnmarshalVolumeAttachment(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeAttachmentAsProperty unmarshals an instance of VolumeAttachment that is stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentAsProperty(m map[string]interface{}, propertyName string) (result *VolumeAttachment, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeAttachment'", propertyName)
			return
		}
		result, err = UnmarshalVolumeAttachment(objMap)
	}
	return
}

// UnmarshalVolumeAttachmentSliceAsProperty unmarshals a slice of VolumeAttachment instances that are stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeAttachment, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeAttachment'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeAttachmentSlice(vSlice)
	}
	return
}

// VolumeAttachmentCollection : VolumeAttachmentCollection struct
type VolumeAttachmentCollection struct {
	// Collection of volume attachments.
	VolumeAttachments []VolumeAttachment `json:"volume_attachments" validate:"required"`
}

// UnmarshalVolumeAttachmentCollection constructs an instance of VolumeAttachmentCollection from the specified map.
func UnmarshalVolumeAttachmentCollection(m map[string]interface{}) (result *VolumeAttachmentCollection, err error) {
	obj := new(VolumeAttachmentCollection)
	obj.VolumeAttachments, err = UnmarshalVolumeAttachmentSliceAsProperty(m, "volume_attachments")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeAttachmentCollectionSlice unmarshals a slice of VolumeAttachmentCollection instances from the specified list of maps.
func UnmarshalVolumeAttachmentCollectionSlice(s []interface{}) (slice []VolumeAttachmentCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeAttachmentCollection'")
			return
		}
		obj, e := UnmarshalVolumeAttachmentCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeAttachmentCollectionAsProperty unmarshals an instance of VolumeAttachmentCollection that is stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentCollectionAsProperty(m map[string]interface{}, propertyName string) (result *VolumeAttachmentCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeAttachmentCollection'", propertyName)
			return
		}
		result, err = UnmarshalVolumeAttachmentCollection(objMap)
	}
	return
}

// UnmarshalVolumeAttachmentCollectionSliceAsProperty unmarshals a slice of VolumeAttachmentCollection instances that are stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeAttachmentCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeAttachmentCollection'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeAttachmentCollectionSlice(vSlice)
	}
	return
}

// VolumeAttachmentDevice : VolumeAttachmentDevice struct
type VolumeAttachmentDevice struct {
	// A unique identifier for the device which is exposed to the instance operating system.
	ID *string `json:"id,omitempty"`
}

// UnmarshalVolumeAttachmentDevice constructs an instance of VolumeAttachmentDevice from the specified map.
func UnmarshalVolumeAttachmentDevice(m map[string]interface{}) (result *VolumeAttachmentDevice, err error) {
	obj := new(VolumeAttachmentDevice)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeAttachmentDeviceSlice unmarshals a slice of VolumeAttachmentDevice instances from the specified list of maps.
func UnmarshalVolumeAttachmentDeviceSlice(s []interface{}) (slice []VolumeAttachmentDevice, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeAttachmentDevice'")
			return
		}
		obj, e := UnmarshalVolumeAttachmentDevice(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeAttachmentDeviceAsProperty unmarshals an instance of VolumeAttachmentDevice that is stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentDeviceAsProperty(m map[string]interface{}, propertyName string) (result *VolumeAttachmentDevice, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeAttachmentDevice'", propertyName)
			return
		}
		result, err = UnmarshalVolumeAttachmentDevice(objMap)
	}
	return
}

// UnmarshalVolumeAttachmentDeviceSliceAsProperty unmarshals a slice of VolumeAttachmentDevice instances that are stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentDeviceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeAttachmentDevice, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeAttachmentDevice'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeAttachmentDeviceSlice(vSlice)
	}
	return
}

// VolumeAttachmentPrototypeInstanceByImageContext : VolumeAttachmentPrototypeInstanceByImageContext struct
type VolumeAttachmentPrototypeInstanceByImageContext struct {
	// If set to true, when deleting the instance the volume will also be deleted.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete,omitempty"`

	// The user-defined name for this volume attachment.
	Name *string `json:"name,omitempty"`

	// The identity of the volume to attach to the instance, or a prototype object for a
	// new volume.
	Volume *VolumePrototypeInstanceByImageContext `json:"volume" validate:"required"`
}

// NewVolumeAttachmentPrototypeInstanceByImageContext : Instantiate VolumeAttachmentPrototypeInstanceByImageContext (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeInstanceByImageContext(volume *VolumePrototypeInstanceByImageContext) (model *VolumeAttachmentPrototypeInstanceByImageContext, err error) {
	model = &VolumeAttachmentPrototypeInstanceByImageContext{
		Volume: volume,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceByImageContext constructs an instance of VolumeAttachmentPrototypeInstanceByImageContext from the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceByImageContext(m map[string]interface{}) (result *VolumeAttachmentPrototypeInstanceByImageContext, err error) {
	obj := new(VolumeAttachmentPrototypeInstanceByImageContext)
	obj.DeleteVolumeOnInstanceDelete, err = core.UnmarshalBool(m, "delete_volume_on_instance_delete")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Volume, err = UnmarshalVolumePrototypeInstanceByImageContextAsProperty(m, "volume")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceByImageContextSlice unmarshals a slice of VolumeAttachmentPrototypeInstanceByImageContext instances from the specified list of maps.
func UnmarshalVolumeAttachmentPrototypeInstanceByImageContextSlice(s []interface{}) (slice []VolumeAttachmentPrototypeInstanceByImageContext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeAttachmentPrototypeInstanceByImageContext'")
			return
		}
		obj, e := UnmarshalVolumeAttachmentPrototypeInstanceByImageContext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceByImageContextAsProperty unmarshals an instance of VolumeAttachmentPrototypeInstanceByImageContext that is stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceByImageContextAsProperty(m map[string]interface{}, propertyName string) (result *VolumeAttachmentPrototypeInstanceByImageContext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeAttachmentPrototypeInstanceByImageContext'", propertyName)
			return
		}
		result, err = UnmarshalVolumeAttachmentPrototypeInstanceByImageContext(objMap)
	}
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceByImageContextSliceAsProperty unmarshals a slice of VolumeAttachmentPrototypeInstanceByImageContext instances that are stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceByImageContextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeAttachmentPrototypeInstanceByImageContext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeAttachmentPrototypeInstanceByImageContext'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeAttachmentPrototypeInstanceByImageContextSlice(vSlice)
	}
	return
}

// VolumeAttachmentPrototypeInstanceContext : VolumeAttachmentPrototypeInstanceContext struct
type VolumeAttachmentPrototypeInstanceContext struct {
	// If set to true, when deleting the instance the volume will also be deleted.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete,omitempty"`

	// The user-defined name for this volume attachment.
	Name *string `json:"name,omitempty"`

	// The identity of the volume to attach to the instance, or a prototype object for a new
	// volume.
	Volume VolumeAttachmentPrototypeInstanceContextVolumeIntf `json:"volume" validate:"required"`
}

// NewVolumeAttachmentPrototypeInstanceContext : Instantiate VolumeAttachmentPrototypeInstanceContext (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeInstanceContext(volume VolumeAttachmentPrototypeInstanceContextVolumeIntf) (model *VolumeAttachmentPrototypeInstanceContext, err error) {
	model = &VolumeAttachmentPrototypeInstanceContext{
		Volume: volume,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContext constructs an instance of VolumeAttachmentPrototypeInstanceContext from the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContext(m map[string]interface{}) (result *VolumeAttachmentPrototypeInstanceContext, err error) {
	obj := new(VolumeAttachmentPrototypeInstanceContext)
	obj.DeleteVolumeOnInstanceDelete, err = core.UnmarshalBool(m, "delete_volume_on_instance_delete")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Volume, err = UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeAsProperty(m, "volume")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextSlice unmarshals a slice of VolumeAttachmentPrototypeInstanceContext instances from the specified list of maps.
func UnmarshalVolumeAttachmentPrototypeInstanceContextSlice(s []interface{}) (slice []VolumeAttachmentPrototypeInstanceContext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeAttachmentPrototypeInstanceContext'")
			return
		}
		obj, e := UnmarshalVolumeAttachmentPrototypeInstanceContext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextAsProperty unmarshals an instance of VolumeAttachmentPrototypeInstanceContext that is stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextAsProperty(m map[string]interface{}, propertyName string) (result *VolumeAttachmentPrototypeInstanceContext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeAttachmentPrototypeInstanceContext'", propertyName)
			return
		}
		result, err = UnmarshalVolumeAttachmentPrototypeInstanceContext(objMap)
	}
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextSliceAsProperty unmarshals a slice of VolumeAttachmentPrototypeInstanceContext instances that are stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeAttachmentPrototypeInstanceContext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeAttachmentPrototypeInstanceContext'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeAttachmentPrototypeInstanceContextSlice(vSlice)
	}
	return
}

// VolumeAttachmentPrototypeInstanceContextVolume : The identity of the volume to attach to the instance, or a prototype object for a new volume.
// Models which "extend" this model:
// - VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity
// - VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext
type VolumeAttachmentPrototypeInstanceContextVolume struct {
	// The unique identifier for this volume.
	ID *string `json:"id,omitempty"`

	// The CRN for this volume.
	Crn *string `json:"crn,omitempty"`

	// The URL for this volume.
	Href *string `json:"href,omitempty"`

	// The bandwidth for the volume.
	Iops *int64 `json:"iops,omitempty"`

	// The unique user-defined name for this volume.
	Name *string `json:"name,omitempty"`

	// The profile to use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile,omitempty"`

	// The capacity of the volume in gigabytes.
	Capacity *int64 `json:"capacity,omitempty"`
}

func (*VolumeAttachmentPrototypeInstanceContextVolume) isaVolumeAttachmentPrototypeInstanceContextVolume() bool {
	return true
}

type VolumeAttachmentPrototypeInstanceContextVolumeIntf interface {
	isaVolumeAttachmentPrototypeInstanceContextVolume() bool
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolume constructs an instance of VolumeAttachmentPrototypeInstanceContextVolume from the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolume(m map[string]interface{}) (result VolumeAttachmentPrototypeInstanceContextVolumeIntf, err error) {
	obj := new(VolumeAttachmentPrototypeInstanceContextVolume)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.Iops, err = core.UnmarshalInt64(m, "iops")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Profile, err = UnmarshalVolumeProfileIdentityAsProperty(m, "profile")
	if err != nil {
		return
	}
	obj.Capacity, err = core.UnmarshalInt64(m, "capacity")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeSlice unmarshals a slice of VolumeAttachmentPrototypeInstanceContextVolume instances from the specified list of maps.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeSlice(s []interface{}) (slice []VolumeAttachmentPrototypeInstanceContextVolumeIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolume'")
			return
		}
		obj, e := UnmarshalVolumeAttachmentPrototypeInstanceContextVolume(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeAsProperty unmarshals an instance of VolumeAttachmentPrototypeInstanceContextVolume that is stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeAsProperty(m map[string]interface{}, propertyName string) (result VolumeAttachmentPrototypeInstanceContextVolumeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolume'", propertyName)
			return
		}
		result, err = UnmarshalVolumeAttachmentPrototypeInstanceContextVolume(objMap)
	}
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeSliceAsProperty unmarshals a slice of VolumeAttachmentPrototypeInstanceContextVolume instances that are stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeAttachmentPrototypeInstanceContextVolumeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolume'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeSlice(vSlice)
	}
	return
}

// VolumeAttachmentReferenceInstanceContext : VolumeAttachmentReferenceInstanceContext struct
type VolumeAttachmentReferenceInstanceContext struct {
	// Information about how the volume is exposed to the instance operating system.
	//
	// This property may be absent if the volume attachment's `status` is not `attached`.
	Device *VolumeAttachmentDevice `json:"device,omitempty"`

	// The URL for this volume attachment.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this volume attachment.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this volume attachment.
	Name *string `json:"name" validate:"required"`

	// The attached volume.
	Volume *VolumeReference `json:"volume" validate:"required"`
}

// UnmarshalVolumeAttachmentReferenceInstanceContext constructs an instance of VolumeAttachmentReferenceInstanceContext from the specified map.
func UnmarshalVolumeAttachmentReferenceInstanceContext(m map[string]interface{}) (result *VolumeAttachmentReferenceInstanceContext, err error) {
	obj := new(VolumeAttachmentReferenceInstanceContext)
	obj.Device, err = UnmarshalVolumeAttachmentDeviceAsProperty(m, "device")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Volume, err = UnmarshalVolumeReferenceAsProperty(m, "volume")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeAttachmentReferenceInstanceContextSlice unmarshals a slice of VolumeAttachmentReferenceInstanceContext instances from the specified list of maps.
func UnmarshalVolumeAttachmentReferenceInstanceContextSlice(s []interface{}) (slice []VolumeAttachmentReferenceInstanceContext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeAttachmentReferenceInstanceContext'")
			return
		}
		obj, e := UnmarshalVolumeAttachmentReferenceInstanceContext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeAttachmentReferenceInstanceContextAsProperty unmarshals an instance of VolumeAttachmentReferenceInstanceContext that is stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentReferenceInstanceContextAsProperty(m map[string]interface{}, propertyName string) (result *VolumeAttachmentReferenceInstanceContext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeAttachmentReferenceInstanceContext'", propertyName)
			return
		}
		result, err = UnmarshalVolumeAttachmentReferenceInstanceContext(objMap)
	}
	return
}

// UnmarshalVolumeAttachmentReferenceInstanceContextSliceAsProperty unmarshals a slice of VolumeAttachmentReferenceInstanceContext instances that are stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentReferenceInstanceContextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeAttachmentReferenceInstanceContext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeAttachmentReferenceInstanceContext'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeAttachmentReferenceInstanceContextSlice(vSlice)
	}
	return
}

// VolumeAttachmentReferenceVolumeContext : VolumeAttachmentReferenceVolumeContext struct
type VolumeAttachmentReferenceVolumeContext struct {
	// If set to true, when deleting the instance the volume will also be deleted.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete" validate:"required"`

	// Information about how the volume is exposed to the instance operating system.
	//
	// This property may be absent if the volume attachment's `status` is not `attached`.
	Device *VolumeAttachmentDevice `json:"device,omitempty"`

	// The URL for this volume attachment.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this volume attachment.
	ID *string `json:"id" validate:"required"`

	// The attached instance.
	Instance *InstanceReference `json:"instance" validate:"required"`

	// The user-defined name for this volume attachment.
	Name *string `json:"name" validate:"required"`

	// The type of volume attachment.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the VolumeAttachmentReferenceVolumeContext.Type property.
// The type of volume attachment.
const (
	VolumeAttachmentReferenceVolumeContext_Type_Boot = "boot"
	VolumeAttachmentReferenceVolumeContext_Type_Data = "data"
)

// UnmarshalVolumeAttachmentReferenceVolumeContext constructs an instance of VolumeAttachmentReferenceVolumeContext from the specified map.
func UnmarshalVolumeAttachmentReferenceVolumeContext(m map[string]interface{}) (result *VolumeAttachmentReferenceVolumeContext, err error) {
	obj := new(VolumeAttachmentReferenceVolumeContext)
	obj.DeleteVolumeOnInstanceDelete, err = core.UnmarshalBool(m, "delete_volume_on_instance_delete")
	if err != nil {
		return
	}
	obj.Device, err = UnmarshalVolumeAttachmentDeviceAsProperty(m, "device")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Instance, err = UnmarshalInstanceReferenceAsProperty(m, "instance")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeAttachmentReferenceVolumeContextSlice unmarshals a slice of VolumeAttachmentReferenceVolumeContext instances from the specified list of maps.
func UnmarshalVolumeAttachmentReferenceVolumeContextSlice(s []interface{}) (slice []VolumeAttachmentReferenceVolumeContext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeAttachmentReferenceVolumeContext'")
			return
		}
		obj, e := UnmarshalVolumeAttachmentReferenceVolumeContext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeAttachmentReferenceVolumeContextAsProperty unmarshals an instance of VolumeAttachmentReferenceVolumeContext that is stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentReferenceVolumeContextAsProperty(m map[string]interface{}, propertyName string) (result *VolumeAttachmentReferenceVolumeContext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeAttachmentReferenceVolumeContext'", propertyName)
			return
		}
		result, err = UnmarshalVolumeAttachmentReferenceVolumeContext(objMap)
	}
	return
}

// UnmarshalVolumeAttachmentReferenceVolumeContextSliceAsProperty unmarshals a slice of VolumeAttachmentReferenceVolumeContext instances that are stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentReferenceVolumeContextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeAttachmentReferenceVolumeContext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeAttachmentReferenceVolumeContext'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeAttachmentReferenceVolumeContextSlice(vSlice)
	}
	return
}

// VolumeCollection : VolumeCollection struct
type VolumeCollection struct {
	// A reference to the first page of resources.
	First *VolumeCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *VolumeCollectionNext `json:"next,omitempty"`

	// Collection of volumes.
	Volumes []Volume `json:"volumes" validate:"required"`
}

// UnmarshalVolumeCollection constructs an instance of VolumeCollection from the specified map.
func UnmarshalVolumeCollection(m map[string]interface{}) (result *VolumeCollection, err error) {
	obj := new(VolumeCollection)
	obj.First, err = UnmarshalVolumeCollectionFirstAsProperty(m, "first")
	if err != nil {
		return
	}
	obj.Limit, err = core.UnmarshalInt64(m, "limit")
	if err != nil {
		return
	}
	obj.Next, err = UnmarshalVolumeCollectionNextAsProperty(m, "next")
	if err != nil {
		return
	}
	obj.Volumes, err = UnmarshalVolumeSliceAsProperty(m, "volumes")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeCollectionSlice unmarshals a slice of VolumeCollection instances from the specified list of maps.
func UnmarshalVolumeCollectionSlice(s []interface{}) (slice []VolumeCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeCollection'")
			return
		}
		obj, e := UnmarshalVolumeCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeCollectionAsProperty unmarshals an instance of VolumeCollection that is stored as a property
// within the specified map.
func UnmarshalVolumeCollectionAsProperty(m map[string]interface{}, propertyName string) (result *VolumeCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeCollection'", propertyName)
			return
		}
		result, err = UnmarshalVolumeCollection(objMap)
	}
	return
}

// UnmarshalVolumeCollectionSliceAsProperty unmarshals a slice of VolumeCollection instances that are stored as a property
// within the specified map.
func UnmarshalVolumeCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeCollection'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeCollectionSlice(vSlice)
	}
	return
}

// VolumeCollectionFirst : A reference to the first page of resources.
type VolumeCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVolumeCollectionFirst constructs an instance of VolumeCollectionFirst from the specified map.
func UnmarshalVolumeCollectionFirst(m map[string]interface{}) (result *VolumeCollectionFirst, err error) {
	obj := new(VolumeCollectionFirst)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeCollectionFirstSlice unmarshals a slice of VolumeCollectionFirst instances from the specified list of maps.
func UnmarshalVolumeCollectionFirstSlice(s []interface{}) (slice []VolumeCollectionFirst, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeCollectionFirst'")
			return
		}
		obj, e := UnmarshalVolumeCollectionFirst(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeCollectionFirstAsProperty unmarshals an instance of VolumeCollectionFirst that is stored as a property
// within the specified map.
func UnmarshalVolumeCollectionFirstAsProperty(m map[string]interface{}, propertyName string) (result *VolumeCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeCollectionFirst'", propertyName)
			return
		}
		result, err = UnmarshalVolumeCollectionFirst(objMap)
	}
	return
}

// UnmarshalVolumeCollectionFirstSliceAsProperty unmarshals a slice of VolumeCollectionFirst instances that are stored as a property
// within the specified map.
func UnmarshalVolumeCollectionFirstSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeCollectionFirst'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeCollectionFirstSlice(vSlice)
	}
	return
}

// VolumeCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type VolumeCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVolumeCollectionNext constructs an instance of VolumeCollectionNext from the specified map.
func UnmarshalVolumeCollectionNext(m map[string]interface{}) (result *VolumeCollectionNext, err error) {
	obj := new(VolumeCollectionNext)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeCollectionNextSlice unmarshals a slice of VolumeCollectionNext instances from the specified list of maps.
func UnmarshalVolumeCollectionNextSlice(s []interface{}) (slice []VolumeCollectionNext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeCollectionNext'")
			return
		}
		obj, e := UnmarshalVolumeCollectionNext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeCollectionNextAsProperty unmarshals an instance of VolumeCollectionNext that is stored as a property
// within the specified map.
func UnmarshalVolumeCollectionNextAsProperty(m map[string]interface{}, propertyName string) (result *VolumeCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeCollectionNext'", propertyName)
			return
		}
		result, err = UnmarshalVolumeCollectionNext(objMap)
	}
	return
}

// UnmarshalVolumeCollectionNextSliceAsProperty unmarshals a slice of VolumeCollectionNext instances that are stored as a property
// within the specified map.
func UnmarshalVolumeCollectionNextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeCollectionNext'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeCollectionNextSlice(vSlice)
	}
	return
}

// VolumeIdentity : Identifies a volume by a unique property.
// Models which "extend" this model:
// - VolumeIdentityByID
// - VolumeIdentityByCRN
// - VolumeIdentityByHref
type VolumeIdentity struct {
	// The unique identifier for this volume.
	ID *string `json:"id,omitempty"`

	// The CRN for this volume.
	Crn *string `json:"crn,omitempty"`

	// The URL for this volume.
	Href *string `json:"href,omitempty"`
}

func (*VolumeIdentity) isaVolumeIdentity() bool {
	return true
}

type VolumeIdentityIntf interface {
	isaVolumeIdentity() bool
}

// UnmarshalVolumeIdentity constructs an instance of VolumeIdentity from the specified map.
func UnmarshalVolumeIdentity(m map[string]interface{}) (result VolumeIdentityIntf, err error) {
	obj := new(VolumeIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeIdentitySlice unmarshals a slice of VolumeIdentity instances from the specified list of maps.
func UnmarshalVolumeIdentitySlice(s []interface{}) (slice []VolumeIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeIdentity'")
			return
		}
		obj, e := UnmarshalVolumeIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalVolumeIdentityAsProperty unmarshals an instance of VolumeIdentity that is stored as a property
// within the specified map.
func UnmarshalVolumeIdentityAsProperty(m map[string]interface{}, propertyName string) (result VolumeIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeIdentity'", propertyName)
			return
		}
		result, err = UnmarshalVolumeIdentity(objMap)
	}
	return
}

// UnmarshalVolumeIdentitySliceAsProperty unmarshals a slice of VolumeIdentity instances that are stored as a property
// within the specified map.
func UnmarshalVolumeIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeIdentitySlice(vSlice)
	}
	return
}

// VolumeProfile : VolumeProfile struct
type VolumeProfile struct {
	// The product family this volume profile belongs to.
	Family *string `json:"family,omitempty"`

	// The URL for this volume profile.
	Href *string `json:"href" validate:"required"`

	// The name for this volume profile.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalVolumeProfile constructs an instance of VolumeProfile from the specified map.
func UnmarshalVolumeProfile(m map[string]interface{}) (result *VolumeProfile, err error) {
	obj := new(VolumeProfile)
	obj.Family, err = core.UnmarshalString(m, "family")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeProfileSlice unmarshals a slice of VolumeProfile instances from the specified list of maps.
func UnmarshalVolumeProfileSlice(s []interface{}) (slice []VolumeProfile, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeProfile'")
			return
		}
		obj, e := UnmarshalVolumeProfile(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeProfileAsProperty unmarshals an instance of VolumeProfile that is stored as a property
// within the specified map.
func UnmarshalVolumeProfileAsProperty(m map[string]interface{}, propertyName string) (result *VolumeProfile, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeProfile'", propertyName)
			return
		}
		result, err = UnmarshalVolumeProfile(objMap)
	}
	return
}

// UnmarshalVolumeProfileSliceAsProperty unmarshals a slice of VolumeProfile instances that are stored as a property
// within the specified map.
func UnmarshalVolumeProfileSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeProfile, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeProfile'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeProfileSlice(vSlice)
	}
	return
}

// VolumeProfileCollection : VolumeProfileCollection struct
type VolumeProfileCollection struct {
	// A reference to the first page of resources.
	First *VolumeProfileCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *VolumeProfileCollectionNext `json:"next,omitempty"`

	// Collection of volume profiles.
	Profiles []VolumeProfile `json:"profiles" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalVolumeProfileCollection constructs an instance of VolumeProfileCollection from the specified map.
func UnmarshalVolumeProfileCollection(m map[string]interface{}) (result *VolumeProfileCollection, err error) {
	obj := new(VolumeProfileCollection)
	obj.First, err = UnmarshalVolumeProfileCollectionFirstAsProperty(m, "first")
	if err != nil {
		return
	}
	obj.Limit, err = core.UnmarshalInt64(m, "limit")
	if err != nil {
		return
	}
	obj.Next, err = UnmarshalVolumeProfileCollectionNextAsProperty(m, "next")
	if err != nil {
		return
	}
	obj.Profiles, err = UnmarshalVolumeProfileSliceAsProperty(m, "profiles")
	if err != nil {
		return
	}
	obj.TotalCount, err = core.UnmarshalInt64(m, "total_count")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeProfileCollectionSlice unmarshals a slice of VolumeProfileCollection instances from the specified list of maps.
func UnmarshalVolumeProfileCollectionSlice(s []interface{}) (slice []VolumeProfileCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeProfileCollection'")
			return
		}
		obj, e := UnmarshalVolumeProfileCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeProfileCollectionAsProperty unmarshals an instance of VolumeProfileCollection that is stored as a property
// within the specified map.
func UnmarshalVolumeProfileCollectionAsProperty(m map[string]interface{}, propertyName string) (result *VolumeProfileCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeProfileCollection'", propertyName)
			return
		}
		result, err = UnmarshalVolumeProfileCollection(objMap)
	}
	return
}

// UnmarshalVolumeProfileCollectionSliceAsProperty unmarshals a slice of VolumeProfileCollection instances that are stored as a property
// within the specified map.
func UnmarshalVolumeProfileCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeProfileCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeProfileCollection'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeProfileCollectionSlice(vSlice)
	}
	return
}

// VolumeProfileCollectionFirst : A reference to the first page of resources.
type VolumeProfileCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVolumeProfileCollectionFirst constructs an instance of VolumeProfileCollectionFirst from the specified map.
func UnmarshalVolumeProfileCollectionFirst(m map[string]interface{}) (result *VolumeProfileCollectionFirst, err error) {
	obj := new(VolumeProfileCollectionFirst)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeProfileCollectionFirstSlice unmarshals a slice of VolumeProfileCollectionFirst instances from the specified list of maps.
func UnmarshalVolumeProfileCollectionFirstSlice(s []interface{}) (slice []VolumeProfileCollectionFirst, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeProfileCollectionFirst'")
			return
		}
		obj, e := UnmarshalVolumeProfileCollectionFirst(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeProfileCollectionFirstAsProperty unmarshals an instance of VolumeProfileCollectionFirst that is stored as a property
// within the specified map.
func UnmarshalVolumeProfileCollectionFirstAsProperty(m map[string]interface{}, propertyName string) (result *VolumeProfileCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeProfileCollectionFirst'", propertyName)
			return
		}
		result, err = UnmarshalVolumeProfileCollectionFirst(objMap)
	}
	return
}

// UnmarshalVolumeProfileCollectionFirstSliceAsProperty unmarshals a slice of VolumeProfileCollectionFirst instances that are stored as a property
// within the specified map.
func UnmarshalVolumeProfileCollectionFirstSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeProfileCollectionFirst, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeProfileCollectionFirst'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeProfileCollectionFirstSlice(vSlice)
	}
	return
}

// VolumeProfileCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type VolumeProfileCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVolumeProfileCollectionNext constructs an instance of VolumeProfileCollectionNext from the specified map.
func UnmarshalVolumeProfileCollectionNext(m map[string]interface{}) (result *VolumeProfileCollectionNext, err error) {
	obj := new(VolumeProfileCollectionNext)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeProfileCollectionNextSlice unmarshals a slice of VolumeProfileCollectionNext instances from the specified list of maps.
func UnmarshalVolumeProfileCollectionNextSlice(s []interface{}) (slice []VolumeProfileCollectionNext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeProfileCollectionNext'")
			return
		}
		obj, e := UnmarshalVolumeProfileCollectionNext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeProfileCollectionNextAsProperty unmarshals an instance of VolumeProfileCollectionNext that is stored as a property
// within the specified map.
func UnmarshalVolumeProfileCollectionNextAsProperty(m map[string]interface{}, propertyName string) (result *VolumeProfileCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeProfileCollectionNext'", propertyName)
			return
		}
		result, err = UnmarshalVolumeProfileCollectionNext(objMap)
	}
	return
}

// UnmarshalVolumeProfileCollectionNextSliceAsProperty unmarshals a slice of VolumeProfileCollectionNext instances that are stored as a property
// within the specified map.
func UnmarshalVolumeProfileCollectionNextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeProfileCollectionNext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeProfileCollectionNext'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeProfileCollectionNextSlice(vSlice)
	}
	return
}

// VolumeProfileIdentity : Identifies a volume profile by a unique property.
// Models which "extend" this model:
// - VolumeProfileIdentityByName
// - VolumeProfileIdentityByHref
type VolumeProfileIdentity struct {
	// The name for this volume profile.
	Name *string `json:"name,omitempty"`

	// The URL for this volume profile.
	Href *string `json:"href,omitempty"`
}

func (*VolumeProfileIdentity) isaVolumeProfileIdentity() bool {
	return true
}

type VolumeProfileIdentityIntf interface {
	isaVolumeProfileIdentity() bool
}

// UnmarshalVolumeProfileIdentity constructs an instance of VolumeProfileIdentity from the specified map.
func UnmarshalVolumeProfileIdentity(m map[string]interface{}) (result VolumeProfileIdentityIntf, err error) {
	obj := new(VolumeProfileIdentity)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeProfileIdentitySlice unmarshals a slice of VolumeProfileIdentity instances from the specified list of maps.
func UnmarshalVolumeProfileIdentitySlice(s []interface{}) (slice []VolumeProfileIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeProfileIdentity'")
			return
		}
		obj, e := UnmarshalVolumeProfileIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalVolumeProfileIdentityAsProperty unmarshals an instance of VolumeProfileIdentity that is stored as a property
// within the specified map.
func UnmarshalVolumeProfileIdentityAsProperty(m map[string]interface{}, propertyName string) (result VolumeProfileIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeProfileIdentity'", propertyName)
			return
		}
		result, err = UnmarshalVolumeProfileIdentity(objMap)
	}
	return
}

// UnmarshalVolumeProfileIdentitySliceAsProperty unmarshals a slice of VolumeProfileIdentity instances that are stored as a property
// within the specified map.
func UnmarshalVolumeProfileIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeProfileIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeProfileIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeProfileIdentitySlice(vSlice)
	}
	return
}

// VolumeProfileReference : VolumeProfileReference struct
type VolumeProfileReference struct {
	// The URL for this volume profile.
	Href *string `json:"href" validate:"required"`

	// The name for this volume profile.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalVolumeProfileReference constructs an instance of VolumeProfileReference from the specified map.
func UnmarshalVolumeProfileReference(m map[string]interface{}) (result *VolumeProfileReference, err error) {
	obj := new(VolumeProfileReference)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeProfileReferenceSlice unmarshals a slice of VolumeProfileReference instances from the specified list of maps.
func UnmarshalVolumeProfileReferenceSlice(s []interface{}) (slice []VolumeProfileReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeProfileReference'")
			return
		}
		obj, e := UnmarshalVolumeProfileReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeProfileReferenceAsProperty unmarshals an instance of VolumeProfileReference that is stored as a property
// within the specified map.
func UnmarshalVolumeProfileReferenceAsProperty(m map[string]interface{}, propertyName string) (result *VolumeProfileReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeProfileReference'", propertyName)
			return
		}
		result, err = UnmarshalVolumeProfileReference(objMap)
	}
	return
}

// UnmarshalVolumeProfileReferenceSliceAsProperty unmarshals a slice of VolumeProfileReference instances that are stored as a property
// within the specified map.
func UnmarshalVolumeProfileReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeProfileReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeProfileReference'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeProfileReferenceSlice(vSlice)
	}
	return
}

// VolumePrototype : VolumePrototype struct
// Models which "extend" this model:
// - VolumePrototypeVolumeByCapacity
type VolumePrototype struct {
	// The bandwidth for the volume.
	Iops *int64 `json:"iops,omitempty"`

	// The unique user-defined name for this volume.
	Name *string `json:"name,omitempty"`

	// The profile to use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile" validate:"required"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The location of the volume.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// The capacity of the volume in gigabytes.
	Capacity *int64 `json:"capacity,omitempty"`
}

func (*VolumePrototype) isaVolumePrototype() bool {
	return true
}

type VolumePrototypeIntf interface {
	isaVolumePrototype() bool
}

// UnmarshalVolumePrototype constructs an instance of VolumePrototype from the specified map.
func UnmarshalVolumePrototype(m map[string]interface{}) (result VolumePrototypeIntf, err error) {
	obj := new(VolumePrototype)
	obj.Iops, err = core.UnmarshalInt64(m, "iops")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Profile, err = UnmarshalVolumeProfileIdentityAsProperty(m, "profile")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupIdentityAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Zone, err = UnmarshalZoneIdentityAsProperty(m, "zone")
	if err != nil {
		return
	}
	obj.Capacity, err = core.UnmarshalInt64(m, "capacity")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumePrototypeSlice unmarshals a slice of VolumePrototype instances from the specified list of maps.
func UnmarshalVolumePrototypeSlice(s []interface{}) (slice []VolumePrototypeIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumePrototype'")
			return
		}
		obj, e := UnmarshalVolumePrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalVolumePrototypeAsProperty unmarshals an instance of VolumePrototype that is stored as a property
// within the specified map.
func UnmarshalVolumePrototypeAsProperty(m map[string]interface{}, propertyName string) (result VolumePrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumePrototype'", propertyName)
			return
		}
		result, err = UnmarshalVolumePrototype(objMap)
	}
	return
}

// UnmarshalVolumePrototypeSliceAsProperty unmarshals a slice of VolumePrototype instances that are stored as a property
// within the specified map.
func UnmarshalVolumePrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumePrototypeIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumePrototype'", propertyName)
			return
		}
		slice, err = UnmarshalVolumePrototypeSlice(vSlice)
	}
	return
}

// VolumePrototypeInstanceByImageContext : VolumePrototypeInstanceByImageContext struct
type VolumePrototypeInstanceByImageContext struct {
	// The capacity of the volume in gigabytes.
	Capacity *int64 `json:"capacity,omitempty"`

	// The bandwidth for the volume.
	Iops *int64 `json:"iops,omitempty"`

	// The unique user-defined name for this volume.
	Name *string `json:"name,omitempty"`

	// The profile to use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile" validate:"required"`
}

// NewVolumePrototypeInstanceByImageContext : Instantiate VolumePrototypeInstanceByImageContext (Generic Model Constructor)
func (*VpcV1) NewVolumePrototypeInstanceByImageContext(profile VolumeProfileIdentityIntf) (model *VolumePrototypeInstanceByImageContext, err error) {
	model = &VolumePrototypeInstanceByImageContext{
		Profile: profile,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalVolumePrototypeInstanceByImageContext constructs an instance of VolumePrototypeInstanceByImageContext from the specified map.
func UnmarshalVolumePrototypeInstanceByImageContext(m map[string]interface{}) (result *VolumePrototypeInstanceByImageContext, err error) {
	obj := new(VolumePrototypeInstanceByImageContext)
	obj.Capacity, err = core.UnmarshalInt64(m, "capacity")
	if err != nil {
		return
	}
	obj.Iops, err = core.UnmarshalInt64(m, "iops")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Profile, err = UnmarshalVolumeProfileIdentityAsProperty(m, "profile")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumePrototypeInstanceByImageContextSlice unmarshals a slice of VolumePrototypeInstanceByImageContext instances from the specified list of maps.
func UnmarshalVolumePrototypeInstanceByImageContextSlice(s []interface{}) (slice []VolumePrototypeInstanceByImageContext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumePrototypeInstanceByImageContext'")
			return
		}
		obj, e := UnmarshalVolumePrototypeInstanceByImageContext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumePrototypeInstanceByImageContextAsProperty unmarshals an instance of VolumePrototypeInstanceByImageContext that is stored as a property
// within the specified map.
func UnmarshalVolumePrototypeInstanceByImageContextAsProperty(m map[string]interface{}, propertyName string) (result *VolumePrototypeInstanceByImageContext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumePrototypeInstanceByImageContext'", propertyName)
			return
		}
		result, err = UnmarshalVolumePrototypeInstanceByImageContext(objMap)
	}
	return
}

// UnmarshalVolumePrototypeInstanceByImageContextSliceAsProperty unmarshals a slice of VolumePrototypeInstanceByImageContext instances that are stored as a property
// within the specified map.
func UnmarshalVolumePrototypeInstanceByImageContextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumePrototypeInstanceByImageContext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumePrototypeInstanceByImageContext'", propertyName)
			return
		}
		slice, err = UnmarshalVolumePrototypeInstanceByImageContextSlice(vSlice)
	}
	return
}

// VolumeReference : VolumeReference struct
type VolumeReference struct {
	// The CRN for this volume.
	Crn *string `json:"crn" validate:"required"`

	// The URL for this volume.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this volume.
	ID *string `json:"id" validate:"required"`

	// The unique user-defined name for this volume.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalVolumeReference constructs an instance of VolumeReference from the specified map.
func UnmarshalVolumeReference(m map[string]interface{}) (result *VolumeReference, err error) {
	obj := new(VolumeReference)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeReferenceSlice unmarshals a slice of VolumeReference instances from the specified list of maps.
func UnmarshalVolumeReferenceSlice(s []interface{}) (slice []VolumeReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeReference'")
			return
		}
		obj, e := UnmarshalVolumeReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeReferenceAsProperty unmarshals an instance of VolumeReference that is stored as a property
// within the specified map.
func UnmarshalVolumeReferenceAsProperty(m map[string]interface{}, propertyName string) (result *VolumeReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeReference'", propertyName)
			return
		}
		result, err = UnmarshalVolumeReference(objMap)
	}
	return
}

// UnmarshalVolumeReferenceSliceAsProperty unmarshals a slice of VolumeReference instances that are stored as a property
// within the specified map.
func UnmarshalVolumeReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeReference'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeReferenceSlice(vSlice)
	}
	return
}

// Zone : Zone struct
type Zone struct {
	// The URL for this zone.
	Href *string `json:"href" validate:"required"`

	// The name for this zone.
	Name *string `json:"name" validate:"required"`

	// The region this zone belongs to.
	Region *RegionReference `json:"region" validate:"required"`

	// The availability status of this zone.
	Status *string `json:"status" validate:"required"`
}

// Constants associated with the Zone.Status property.
// The availability status of this zone.
const (
	Zone_Status_Available   = "available"
	Zone_Status_Impaired    = "impaired"
	Zone_Status_Unavailable = "unavailable"
)

// UnmarshalZone constructs an instance of Zone from the specified map.
func UnmarshalZone(m map[string]interface{}) (result *Zone, err error) {
	obj := new(Zone)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Region, err = UnmarshalRegionReferenceAsProperty(m, "region")
	if err != nil {
		return
	}
	obj.Status, err = core.UnmarshalString(m, "status")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalZoneSlice unmarshals a slice of Zone instances from the specified list of maps.
func UnmarshalZoneSlice(s []interface{}) (slice []Zone, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'Zone'")
			return
		}
		obj, e := UnmarshalZone(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalZoneAsProperty unmarshals an instance of Zone that is stored as a property
// within the specified map.
func UnmarshalZoneAsProperty(m map[string]interface{}, propertyName string) (result *Zone, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'Zone'", propertyName)
			return
		}
		result, err = UnmarshalZone(objMap)
	}
	return
}

// UnmarshalZoneSliceAsProperty unmarshals a slice of Zone instances that are stored as a property
// within the specified map.
func UnmarshalZoneSliceAsProperty(m map[string]interface{}, propertyName string) (slice []Zone, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'Zone'", propertyName)
			return
		}
		slice, err = UnmarshalZoneSlice(vSlice)
	}
	return
}

// ZoneCollection : ZoneCollection struct
type ZoneCollection struct {
	// Collection of zones.
	Zones []Zone `json:"zones" validate:"required"`
}

// UnmarshalZoneCollection constructs an instance of ZoneCollection from the specified map.
func UnmarshalZoneCollection(m map[string]interface{}) (result *ZoneCollection, err error) {
	obj := new(ZoneCollection)
	obj.Zones, err = UnmarshalZoneSliceAsProperty(m, "zones")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalZoneCollectionSlice unmarshals a slice of ZoneCollection instances from the specified list of maps.
func UnmarshalZoneCollectionSlice(s []interface{}) (slice []ZoneCollection, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ZoneCollection'")
			return
		}
		obj, e := UnmarshalZoneCollection(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalZoneCollectionAsProperty unmarshals an instance of ZoneCollection that is stored as a property
// within the specified map.
func UnmarshalZoneCollectionAsProperty(m map[string]interface{}, propertyName string) (result *ZoneCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ZoneCollection'", propertyName)
			return
		}
		result, err = UnmarshalZoneCollection(objMap)
	}
	return
}

// UnmarshalZoneCollectionSliceAsProperty unmarshals a slice of ZoneCollection instances that are stored as a property
// within the specified map.
func UnmarshalZoneCollectionSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ZoneCollection, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ZoneCollection'", propertyName)
			return
		}
		slice, err = UnmarshalZoneCollectionSlice(vSlice)
	}
	return
}

// ZoneIdentity : ZoneIdentity struct
// Models which "extend" this model:
// - ZoneIdentityByName
// - ZoneIdentityByHref
type ZoneIdentity struct {
	// The name for this zone.
	Name *string `json:"name,omitempty"`

	// The URL for this zone.
	Href *string `json:"href,omitempty"`
}

func (*ZoneIdentity) isaZoneIdentity() bool {
	return true
}

type ZoneIdentityIntf interface {
	isaZoneIdentity() bool
}

// UnmarshalZoneIdentity constructs an instance of ZoneIdentity from the specified map.
func UnmarshalZoneIdentity(m map[string]interface{}) (result ZoneIdentityIntf, err error) {
	obj := new(ZoneIdentity)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalZoneIdentitySlice unmarshals a slice of ZoneIdentity instances from the specified list of maps.
func UnmarshalZoneIdentitySlice(s []interface{}) (slice []ZoneIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ZoneIdentity'")
			return
		}
		obj, e := UnmarshalZoneIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalZoneIdentityAsProperty unmarshals an instance of ZoneIdentity that is stored as a property
// within the specified map.
func UnmarshalZoneIdentityAsProperty(m map[string]interface{}, propertyName string) (result ZoneIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ZoneIdentity'", propertyName)
			return
		}
		result, err = UnmarshalZoneIdentity(objMap)
	}
	return
}

// UnmarshalZoneIdentitySliceAsProperty unmarshals a slice of ZoneIdentity instances that are stored as a property
// within the specified map.
func UnmarshalZoneIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []ZoneIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ZoneIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalZoneIdentitySlice(vSlice)
	}
	return
}

// ZoneReference : ZoneReference struct
type ZoneReference struct {
	// The URL for this zone.
	Href *string `json:"href" validate:"required"`

	// The name for this zone.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalZoneReference constructs an instance of ZoneReference from the specified map.
func UnmarshalZoneReference(m map[string]interface{}) (result *ZoneReference, err error) {
	obj := new(ZoneReference)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalZoneReferenceSlice unmarshals a slice of ZoneReference instances from the specified list of maps.
func UnmarshalZoneReferenceSlice(s []interface{}) (slice []ZoneReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ZoneReference'")
			return
		}
		obj, e := UnmarshalZoneReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalZoneReferenceAsProperty unmarshals an instance of ZoneReference that is stored as a property
// within the specified map.
func UnmarshalZoneReferenceAsProperty(m map[string]interface{}, propertyName string) (result *ZoneReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ZoneReference'", propertyName)
			return
		}
		result, err = UnmarshalZoneReference(objMap)
	}
	return
}

// UnmarshalZoneReferenceSliceAsProperty unmarshals a slice of ZoneReference instances that are stored as a property
// within the specified map.
func UnmarshalZoneReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ZoneReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ZoneReference'", propertyName)
			return
		}
		slice, err = UnmarshalZoneReferenceSlice(vSlice)
	}
	return
}

// CertificateInstanceIdentityByCRN : CertificateInstanceIdentityByCRN struct
// This model "extends" CertificateInstanceIdentity
type CertificateInstanceIdentityByCRN struct {
	// The CRN for this certificate instance.
	Crn *string `json:"crn" validate:"required"`
}

// NewCertificateInstanceIdentityByCRN : Instantiate CertificateInstanceIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewCertificateInstanceIdentityByCRN(crn string) (model *CertificateInstanceIdentityByCRN, err error) {
	model = &CertificateInstanceIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*CertificateInstanceIdentityByCRN) isaCertificateInstanceIdentity() bool {
	return true
}

// UnmarshalCertificateInstanceIdentityByCRN constructs an instance of CertificateInstanceIdentityByCRN from the specified map.
func UnmarshalCertificateInstanceIdentityByCRN(m map[string]interface{}) (result *CertificateInstanceIdentityByCRN, err error) {
	obj := new(CertificateInstanceIdentityByCRN)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalCertificateInstanceIdentityByCRNSlice unmarshals a slice of CertificateInstanceIdentityByCRN instances from the specified list of maps.
func UnmarshalCertificateInstanceIdentityByCRNSlice(s []interface{}) (slice []CertificateInstanceIdentityByCRN, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'CertificateInstanceIdentityByCRN'")
			return
		}
		obj, e := UnmarshalCertificateInstanceIdentityByCRN(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalCertificateInstanceIdentityByCRNAsProperty unmarshals an instance of CertificateInstanceIdentityByCRN that is stored as a property
// within the specified map.
func UnmarshalCertificateInstanceIdentityByCRNAsProperty(m map[string]interface{}, propertyName string) (result *CertificateInstanceIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'CertificateInstanceIdentityByCRN'", propertyName)
			return
		}
		result, err = UnmarshalCertificateInstanceIdentityByCRN(objMap)
	}
	return
}

// UnmarshalCertificateInstanceIdentityByCRNSliceAsProperty unmarshals a slice of CertificateInstanceIdentityByCRN instances that are stored as a property
// within the specified map.
func UnmarshalCertificateInstanceIdentityByCRNSliceAsProperty(m map[string]interface{}, propertyName string) (slice []CertificateInstanceIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'CertificateInstanceIdentityByCRN'", propertyName)
			return
		}
		slice, err = UnmarshalCertificateInstanceIdentityByCRNSlice(vSlice)
	}
	return
}

// FloatingIPPrototypeFloatingIPByTarget : FloatingIPPrototypeFloatingIPByTarget struct
// This model "extends" FloatingIPPrototype
type FloatingIPPrototypeFloatingIPByTarget struct {
	// The unique user-defined name for this floating IP. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The target this address is to be bound to.
	Target NetworkInterfaceIdentityIntf `json:"target" validate:"required"`
}

// NewFloatingIPPrototypeFloatingIPByTarget : Instantiate FloatingIPPrototypeFloatingIPByTarget (Generic Model Constructor)
func (*VpcV1) NewFloatingIPPrototypeFloatingIPByTarget(target NetworkInterfaceIdentityIntf) (model *FloatingIPPrototypeFloatingIPByTarget, err error) {
	model = &FloatingIPPrototypeFloatingIPByTarget{
		Target: target,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*FloatingIPPrototypeFloatingIPByTarget) isaFloatingIPPrototype() bool {
	return true
}

// UnmarshalFloatingIPPrototypeFloatingIPByTarget constructs an instance of FloatingIPPrototypeFloatingIPByTarget from the specified map.
func UnmarshalFloatingIPPrototypeFloatingIPByTarget(m map[string]interface{}) (result *FloatingIPPrototypeFloatingIPByTarget, err error) {
	obj := new(FloatingIPPrototypeFloatingIPByTarget)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupIdentityAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Target, err = UnmarshalNetworkInterfaceIdentityAsProperty(m, "target")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalFloatingIPPrototypeFloatingIPByTargetSlice unmarshals a slice of FloatingIPPrototypeFloatingIPByTarget instances from the specified list of maps.
func UnmarshalFloatingIPPrototypeFloatingIPByTargetSlice(s []interface{}) (slice []FloatingIPPrototypeFloatingIPByTarget, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'FloatingIPPrototypeFloatingIPByTarget'")
			return
		}
		obj, e := UnmarshalFloatingIPPrototypeFloatingIPByTarget(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalFloatingIPPrototypeFloatingIPByTargetAsProperty unmarshals an instance of FloatingIPPrototypeFloatingIPByTarget that is stored as a property
// within the specified map.
func UnmarshalFloatingIPPrototypeFloatingIPByTargetAsProperty(m map[string]interface{}, propertyName string) (result *FloatingIPPrototypeFloatingIPByTarget, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'FloatingIPPrototypeFloatingIPByTarget'", propertyName)
			return
		}
		result, err = UnmarshalFloatingIPPrototypeFloatingIPByTarget(objMap)
	}
	return
}

// UnmarshalFloatingIPPrototypeFloatingIPByTargetSliceAsProperty unmarshals a slice of FloatingIPPrototypeFloatingIPByTarget instances that are stored as a property
// within the specified map.
func UnmarshalFloatingIPPrototypeFloatingIPByTargetSliceAsProperty(m map[string]interface{}, propertyName string) (slice []FloatingIPPrototypeFloatingIPByTarget, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'FloatingIPPrototypeFloatingIPByTarget'", propertyName)
			return
		}
		slice, err = UnmarshalFloatingIPPrototypeFloatingIPByTargetSlice(vSlice)
	}
	return
}

// FloatingIPPrototypeFloatingIPByZone : FloatingIPPrototypeFloatingIPByZone struct
// This model "extends" FloatingIPPrototype
type FloatingIPPrototypeFloatingIPByZone struct {
	// The unique user-defined name for this floating IP. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The identity of the zone to provision a floating IP in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// NewFloatingIPPrototypeFloatingIPByZone : Instantiate FloatingIPPrototypeFloatingIPByZone (Generic Model Constructor)
func (*VpcV1) NewFloatingIPPrototypeFloatingIPByZone(zone ZoneIdentityIntf) (model *FloatingIPPrototypeFloatingIPByZone, err error) {
	model = &FloatingIPPrototypeFloatingIPByZone{
		Zone: zone,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*FloatingIPPrototypeFloatingIPByZone) isaFloatingIPPrototype() bool {
	return true
}

// UnmarshalFloatingIPPrototypeFloatingIPByZone constructs an instance of FloatingIPPrototypeFloatingIPByZone from the specified map.
func UnmarshalFloatingIPPrototypeFloatingIPByZone(m map[string]interface{}) (result *FloatingIPPrototypeFloatingIPByZone, err error) {
	obj := new(FloatingIPPrototypeFloatingIPByZone)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupIdentityAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Zone, err = UnmarshalZoneIdentityAsProperty(m, "zone")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalFloatingIPPrototypeFloatingIPByZoneSlice unmarshals a slice of FloatingIPPrototypeFloatingIPByZone instances from the specified list of maps.
func UnmarshalFloatingIPPrototypeFloatingIPByZoneSlice(s []interface{}) (slice []FloatingIPPrototypeFloatingIPByZone, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'FloatingIPPrototypeFloatingIPByZone'")
			return
		}
		obj, e := UnmarshalFloatingIPPrototypeFloatingIPByZone(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalFloatingIPPrototypeFloatingIPByZoneAsProperty unmarshals an instance of FloatingIPPrototypeFloatingIPByZone that is stored as a property
// within the specified map.
func UnmarshalFloatingIPPrototypeFloatingIPByZoneAsProperty(m map[string]interface{}, propertyName string) (result *FloatingIPPrototypeFloatingIPByZone, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'FloatingIPPrototypeFloatingIPByZone'", propertyName)
			return
		}
		result, err = UnmarshalFloatingIPPrototypeFloatingIPByZone(objMap)
	}
	return
}

// UnmarshalFloatingIPPrototypeFloatingIPByZoneSliceAsProperty unmarshals a slice of FloatingIPPrototypeFloatingIPByZone instances that are stored as a property
// within the specified map.
func UnmarshalFloatingIPPrototypeFloatingIPByZoneSliceAsProperty(m map[string]interface{}, propertyName string) (slice []FloatingIPPrototypeFloatingIPByZone, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'FloatingIPPrototypeFloatingIPByZone'", propertyName)
			return
		}
		slice, err = UnmarshalFloatingIPPrototypeFloatingIPByZoneSlice(vSlice)
	}
	return
}

// FloatingIPTargetNetworkInterfaceReference : FloatingIPTargetNetworkInterfaceReference struct
// This model "extends" FloatingIPTarget
type FloatingIPTargetNetworkInterfaceReference struct {
	// The URL for this network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network interface.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this network interface.
	Name *string `json:"name" validate:"required"`

	// The primary IPv4 address.
	PrimaryIpv4Address *string `json:"primary_ipv4_address" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the FloatingIPTargetNetworkInterfaceReference.ResourceType property.
// The type of resource referenced.
const (
	FloatingIPTargetNetworkInterfaceReference_ResourceType_NetworkInterface = "network_interface"
)

func (*FloatingIPTargetNetworkInterfaceReference) isaFloatingIPTarget() bool {
	return true
}

// UnmarshalFloatingIPTargetNetworkInterfaceReference constructs an instance of FloatingIPTargetNetworkInterfaceReference from the specified map.
func UnmarshalFloatingIPTargetNetworkInterfaceReference(m map[string]interface{}) (result *FloatingIPTargetNetworkInterfaceReference, err error) {
	obj := new(FloatingIPTargetNetworkInterfaceReference)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.PrimaryIpv4Address, err = core.UnmarshalString(m, "primary_ipv4_address")
	if err != nil {
		return
	}
	obj.ResourceType, err = core.UnmarshalString(m, "resource_type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalFloatingIPTargetNetworkInterfaceReferenceSlice unmarshals a slice of FloatingIPTargetNetworkInterfaceReference instances from the specified list of maps.
func UnmarshalFloatingIPTargetNetworkInterfaceReferenceSlice(s []interface{}) (slice []FloatingIPTargetNetworkInterfaceReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'FloatingIPTargetNetworkInterfaceReference'")
			return
		}
		obj, e := UnmarshalFloatingIPTargetNetworkInterfaceReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalFloatingIPTargetNetworkInterfaceReferenceAsProperty unmarshals an instance of FloatingIPTargetNetworkInterfaceReference that is stored as a property
// within the specified map.
func UnmarshalFloatingIPTargetNetworkInterfaceReferenceAsProperty(m map[string]interface{}, propertyName string) (result *FloatingIPTargetNetworkInterfaceReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'FloatingIPTargetNetworkInterfaceReference'", propertyName)
			return
		}
		result, err = UnmarshalFloatingIPTargetNetworkInterfaceReference(objMap)
	}
	return
}

// UnmarshalFloatingIPTargetNetworkInterfaceReferenceSliceAsProperty unmarshals a slice of FloatingIPTargetNetworkInterfaceReference instances that are stored as a property
// within the specified map.
func UnmarshalFloatingIPTargetNetworkInterfaceReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []FloatingIPTargetNetworkInterfaceReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'FloatingIPTargetNetworkInterfaceReference'", propertyName)
			return
		}
		slice, err = UnmarshalFloatingIPTargetNetworkInterfaceReferenceSlice(vSlice)
	}
	return
}

// FloatingIPTargetPublicGatewayReference : FloatingIPTargetPublicGatewayReference struct
// This model "extends" FloatingIPTarget
type FloatingIPTargetPublicGatewayReference struct {
	// The CRN for this public gateway.
	Crn *string `json:"crn" validate:"required"`

	// The URL for this gateway.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this public gateway.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this public gateway.
	Name *string `json:"name" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the FloatingIPTargetPublicGatewayReference.ResourceType property.
// The type of resource referenced.
const (
	FloatingIPTargetPublicGatewayReference_ResourceType_PublicGateway = "public_gateway"
)

func (*FloatingIPTargetPublicGatewayReference) isaFloatingIPTarget() bool {
	return true
}

// UnmarshalFloatingIPTargetPublicGatewayReference constructs an instance of FloatingIPTargetPublicGatewayReference from the specified map.
func UnmarshalFloatingIPTargetPublicGatewayReference(m map[string]interface{}) (result *FloatingIPTargetPublicGatewayReference, err error) {
	obj := new(FloatingIPTargetPublicGatewayReference)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.ResourceType, err = core.UnmarshalString(m, "resource_type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalFloatingIPTargetPublicGatewayReferenceSlice unmarshals a slice of FloatingIPTargetPublicGatewayReference instances from the specified list of maps.
func UnmarshalFloatingIPTargetPublicGatewayReferenceSlice(s []interface{}) (slice []FloatingIPTargetPublicGatewayReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'FloatingIPTargetPublicGatewayReference'")
			return
		}
		obj, e := UnmarshalFloatingIPTargetPublicGatewayReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalFloatingIPTargetPublicGatewayReferenceAsProperty unmarshals an instance of FloatingIPTargetPublicGatewayReference that is stored as a property
// within the specified map.
func UnmarshalFloatingIPTargetPublicGatewayReferenceAsProperty(m map[string]interface{}, propertyName string) (result *FloatingIPTargetPublicGatewayReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'FloatingIPTargetPublicGatewayReference'", propertyName)
			return
		}
		result, err = UnmarshalFloatingIPTargetPublicGatewayReference(objMap)
	}
	return
}

// UnmarshalFloatingIPTargetPublicGatewayReferenceSliceAsProperty unmarshals a slice of FloatingIPTargetPublicGatewayReference instances that are stored as a property
// within the specified map.
func UnmarshalFloatingIPTargetPublicGatewayReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []FloatingIPTargetPublicGatewayReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'FloatingIPTargetPublicGatewayReference'", propertyName)
			return
		}
		slice, err = UnmarshalFloatingIPTargetPublicGatewayReferenceSlice(vSlice)
	}
	return
}

// IKEPolicyIdentityByHref : IKEPolicyIdentityByHref struct
// This model "extends" IKEPolicyIdentity
type IKEPolicyIdentityByHref struct {
	// The IKE policy's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewIKEPolicyIdentityByHref : Instantiate IKEPolicyIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewIKEPolicyIdentityByHref(href string) (model *IKEPolicyIdentityByHref, err error) {
	model = &IKEPolicyIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*IKEPolicyIdentityByHref) isaIKEPolicyIdentity() bool {
	return true
}

// UnmarshalIKEPolicyIdentityByHref constructs an instance of IKEPolicyIdentityByHref from the specified map.
func UnmarshalIKEPolicyIdentityByHref(m map[string]interface{}) (result *IKEPolicyIdentityByHref, err error) {
	obj := new(IKEPolicyIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalIKEPolicyIdentityByHrefSlice unmarshals a slice of IKEPolicyIdentityByHref instances from the specified list of maps.
func UnmarshalIKEPolicyIdentityByHrefSlice(s []interface{}) (slice []IKEPolicyIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'IKEPolicyIdentityByHref'")
			return
		}
		obj, e := UnmarshalIKEPolicyIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalIKEPolicyIdentityByHrefAsProperty unmarshals an instance of IKEPolicyIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalIKEPolicyIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *IKEPolicyIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'IKEPolicyIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalIKEPolicyIdentityByHref(objMap)
	}
	return
}

// UnmarshalIKEPolicyIdentityByHrefSliceAsProperty unmarshals a slice of IKEPolicyIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalIKEPolicyIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []IKEPolicyIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'IKEPolicyIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalIKEPolicyIdentityByHrefSlice(vSlice)
	}
	return
}

// IKEPolicyIdentityByID : IKEPolicyIdentityByID struct
// This model "extends" IKEPolicyIdentity
type IKEPolicyIdentityByID struct {
	// The unique identifier for this IKE policy.
	ID *string `json:"id" validate:"required"`
}

// NewIKEPolicyIdentityByID : Instantiate IKEPolicyIdentityByID (Generic Model Constructor)
func (*VpcV1) NewIKEPolicyIdentityByID(id string) (model *IKEPolicyIdentityByID, err error) {
	model = &IKEPolicyIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*IKEPolicyIdentityByID) isaIKEPolicyIdentity() bool {
	return true
}

// UnmarshalIKEPolicyIdentityByID constructs an instance of IKEPolicyIdentityByID from the specified map.
func UnmarshalIKEPolicyIdentityByID(m map[string]interface{}) (result *IKEPolicyIdentityByID, err error) {
	obj := new(IKEPolicyIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalIKEPolicyIdentityByIDSlice unmarshals a slice of IKEPolicyIdentityByID instances from the specified list of maps.
func UnmarshalIKEPolicyIdentityByIDSlice(s []interface{}) (slice []IKEPolicyIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'IKEPolicyIdentityByID'")
			return
		}
		obj, e := UnmarshalIKEPolicyIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalIKEPolicyIdentityByIDAsProperty unmarshals an instance of IKEPolicyIdentityByID that is stored as a property
// within the specified map.
func UnmarshalIKEPolicyIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *IKEPolicyIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'IKEPolicyIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalIKEPolicyIdentityByID(objMap)
	}
	return
}

// UnmarshalIKEPolicyIdentityByIDSliceAsProperty unmarshals a slice of IKEPolicyIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalIKEPolicyIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []IKEPolicyIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'IKEPolicyIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalIKEPolicyIdentityByIDSlice(vSlice)
	}
	return
}

// IPsecPolicyIdentityByHref : IPsecPolicyIdentityByHref struct
// This model "extends" IPsecPolicyIdentity
type IPsecPolicyIdentityByHref struct {
	// The IPsec policy's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewIPsecPolicyIdentityByHref : Instantiate IPsecPolicyIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewIPsecPolicyIdentityByHref(href string) (model *IPsecPolicyIdentityByHref, err error) {
	model = &IPsecPolicyIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*IPsecPolicyIdentityByHref) isaIPsecPolicyIdentity() bool {
	return true
}

// UnmarshalIPsecPolicyIdentityByHref constructs an instance of IPsecPolicyIdentityByHref from the specified map.
func UnmarshalIPsecPolicyIdentityByHref(m map[string]interface{}) (result *IPsecPolicyIdentityByHref, err error) {
	obj := new(IPsecPolicyIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalIPsecPolicyIdentityByHrefSlice unmarshals a slice of IPsecPolicyIdentityByHref instances from the specified list of maps.
func UnmarshalIPsecPolicyIdentityByHrefSlice(s []interface{}) (slice []IPsecPolicyIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'IPsecPolicyIdentityByHref'")
			return
		}
		obj, e := UnmarshalIPsecPolicyIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalIPsecPolicyIdentityByHrefAsProperty unmarshals an instance of IPsecPolicyIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalIPsecPolicyIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *IPsecPolicyIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'IPsecPolicyIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalIPsecPolicyIdentityByHref(objMap)
	}
	return
}

// UnmarshalIPsecPolicyIdentityByHrefSliceAsProperty unmarshals a slice of IPsecPolicyIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalIPsecPolicyIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []IPsecPolicyIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'IPsecPolicyIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalIPsecPolicyIdentityByHrefSlice(vSlice)
	}
	return
}

// IPsecPolicyIdentityByID : IPsecPolicyIdentityByID struct
// This model "extends" IPsecPolicyIdentity
type IPsecPolicyIdentityByID struct {
	// The unique identifier for this IPsec policy.
	ID *string `json:"id" validate:"required"`
}

// NewIPsecPolicyIdentityByID : Instantiate IPsecPolicyIdentityByID (Generic Model Constructor)
func (*VpcV1) NewIPsecPolicyIdentityByID(id string) (model *IPsecPolicyIdentityByID, err error) {
	model = &IPsecPolicyIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*IPsecPolicyIdentityByID) isaIPsecPolicyIdentity() bool {
	return true
}

// UnmarshalIPsecPolicyIdentityByID constructs an instance of IPsecPolicyIdentityByID from the specified map.
func UnmarshalIPsecPolicyIdentityByID(m map[string]interface{}) (result *IPsecPolicyIdentityByID, err error) {
	obj := new(IPsecPolicyIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalIPsecPolicyIdentityByIDSlice unmarshals a slice of IPsecPolicyIdentityByID instances from the specified list of maps.
func UnmarshalIPsecPolicyIdentityByIDSlice(s []interface{}) (slice []IPsecPolicyIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'IPsecPolicyIdentityByID'")
			return
		}
		obj, e := UnmarshalIPsecPolicyIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalIPsecPolicyIdentityByIDAsProperty unmarshals an instance of IPsecPolicyIdentityByID that is stored as a property
// within the specified map.
func UnmarshalIPsecPolicyIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *IPsecPolicyIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'IPsecPolicyIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalIPsecPolicyIdentityByID(objMap)
	}
	return
}

// UnmarshalIPsecPolicyIdentityByIDSliceAsProperty unmarshals a slice of IPsecPolicyIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalIPsecPolicyIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []IPsecPolicyIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'IPsecPolicyIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalIPsecPolicyIdentityByIDSlice(vSlice)
	}
	return
}

// ImageIdentityByCRN : ImageIdentityByCRN struct
// This model "extends" ImageIdentity
type ImageIdentityByCRN struct {
	// The CRN for this image.
	Crn *string `json:"crn" validate:"required"`
}

// NewImageIdentityByCRN : Instantiate ImageIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewImageIdentityByCRN(crn string) (model *ImageIdentityByCRN, err error) {
	model = &ImageIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*ImageIdentityByCRN) isaImageIdentity() bool {
	return true
}

// UnmarshalImageIdentityByCRN constructs an instance of ImageIdentityByCRN from the specified map.
func UnmarshalImageIdentityByCRN(m map[string]interface{}) (result *ImageIdentityByCRN, err error) {
	obj := new(ImageIdentityByCRN)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalImageIdentityByCRNSlice unmarshals a slice of ImageIdentityByCRN instances from the specified list of maps.
func UnmarshalImageIdentityByCRNSlice(s []interface{}) (slice []ImageIdentityByCRN, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ImageIdentityByCRN'")
			return
		}
		obj, e := UnmarshalImageIdentityByCRN(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalImageIdentityByCRNAsProperty unmarshals an instance of ImageIdentityByCRN that is stored as a property
// within the specified map.
func UnmarshalImageIdentityByCRNAsProperty(m map[string]interface{}, propertyName string) (result *ImageIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ImageIdentityByCRN'", propertyName)
			return
		}
		result, err = UnmarshalImageIdentityByCRN(objMap)
	}
	return
}

// UnmarshalImageIdentityByCRNSliceAsProperty unmarshals a slice of ImageIdentityByCRN instances that are stored as a property
// within the specified map.
func UnmarshalImageIdentityByCRNSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ImageIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ImageIdentityByCRN'", propertyName)
			return
		}
		slice, err = UnmarshalImageIdentityByCRNSlice(vSlice)
	}
	return
}

// ImageIdentityByHref : ImageIdentityByHref struct
// This model "extends" ImageIdentity
type ImageIdentityByHref struct {
	// The URL for this image.
	Href *string `json:"href" validate:"required"`
}

// NewImageIdentityByHref : Instantiate ImageIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewImageIdentityByHref(href string) (model *ImageIdentityByHref, err error) {
	model = &ImageIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*ImageIdentityByHref) isaImageIdentity() bool {
	return true
}

// UnmarshalImageIdentityByHref constructs an instance of ImageIdentityByHref from the specified map.
func UnmarshalImageIdentityByHref(m map[string]interface{}) (result *ImageIdentityByHref, err error) {
	obj := new(ImageIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalImageIdentityByHrefSlice unmarshals a slice of ImageIdentityByHref instances from the specified list of maps.
func UnmarshalImageIdentityByHrefSlice(s []interface{}) (slice []ImageIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ImageIdentityByHref'")
			return
		}
		obj, e := UnmarshalImageIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalImageIdentityByHrefAsProperty unmarshals an instance of ImageIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalImageIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *ImageIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ImageIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalImageIdentityByHref(objMap)
	}
	return
}

// UnmarshalImageIdentityByHrefSliceAsProperty unmarshals a slice of ImageIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalImageIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ImageIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ImageIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalImageIdentityByHrefSlice(vSlice)
	}
	return
}

// ImageIdentityByID : ImageIdentityByID struct
// This model "extends" ImageIdentity
type ImageIdentityByID struct {
	// The unique identifier for this image.
	ID *string `json:"id" validate:"required"`
}

// NewImageIdentityByID : Instantiate ImageIdentityByID (Generic Model Constructor)
func (*VpcV1) NewImageIdentityByID(id string) (model *ImageIdentityByID, err error) {
	model = &ImageIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*ImageIdentityByID) isaImageIdentity() bool {
	return true
}

// UnmarshalImageIdentityByID constructs an instance of ImageIdentityByID from the specified map.
func UnmarshalImageIdentityByID(m map[string]interface{}) (result *ImageIdentityByID, err error) {
	obj := new(ImageIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalImageIdentityByIDSlice unmarshals a slice of ImageIdentityByID instances from the specified list of maps.
func UnmarshalImageIdentityByIDSlice(s []interface{}) (slice []ImageIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ImageIdentityByID'")
			return
		}
		obj, e := UnmarshalImageIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalImageIdentityByIDAsProperty unmarshals an instance of ImageIdentityByID that is stored as a property
// within the specified map.
func UnmarshalImageIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *ImageIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ImageIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalImageIdentityByID(objMap)
	}
	return
}

// UnmarshalImageIdentityByIDSliceAsProperty unmarshals a slice of ImageIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalImageIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ImageIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ImageIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalImageIdentityByIDSlice(vSlice)
	}
	return
}

// ImagePrototypeImageByFile : ImagePrototypeImageByFile struct
// This model "extends" ImagePrototype
type ImagePrototypeImageByFile struct {
	// The unique user-defined name for this image. Names starting with "ibm-" are not allowed. If unspecified, the name
	// will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The file from which to create the image.
	File *ImageFilePrototype `json:"file" validate:"required"`

	// The operating system included in this image.
	OperatingSystem OperatingSystemIdentityIntf `json:"operating_system" validate:"required"`
}

// NewImagePrototypeImageByFile : Instantiate ImagePrototypeImageByFile (Generic Model Constructor)
func (*VpcV1) NewImagePrototypeImageByFile(file *ImageFilePrototype, operatingSystem OperatingSystemIdentityIntf) (model *ImagePrototypeImageByFile, err error) {
	model = &ImagePrototypeImageByFile{
		File:            file,
		OperatingSystem: operatingSystem,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*ImagePrototypeImageByFile) isaImagePrototype() bool {
	return true
}

// UnmarshalImagePrototypeImageByFile constructs an instance of ImagePrototypeImageByFile from the specified map.
func UnmarshalImagePrototypeImageByFile(m map[string]interface{}) (result *ImagePrototypeImageByFile, err error) {
	obj := new(ImagePrototypeImageByFile)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupIdentityAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.File, err = UnmarshalImageFilePrototypeAsProperty(m, "file")
	if err != nil {
		return
	}
	obj.OperatingSystem, err = UnmarshalOperatingSystemIdentityAsProperty(m, "operating_system")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalImagePrototypeImageByFileSlice unmarshals a slice of ImagePrototypeImageByFile instances from the specified list of maps.
func UnmarshalImagePrototypeImageByFileSlice(s []interface{}) (slice []ImagePrototypeImageByFile, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ImagePrototypeImageByFile'")
			return
		}
		obj, e := UnmarshalImagePrototypeImageByFile(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalImagePrototypeImageByFileAsProperty unmarshals an instance of ImagePrototypeImageByFile that is stored as a property
// within the specified map.
func UnmarshalImagePrototypeImageByFileAsProperty(m map[string]interface{}, propertyName string) (result *ImagePrototypeImageByFile, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ImagePrototypeImageByFile'", propertyName)
			return
		}
		result, err = UnmarshalImagePrototypeImageByFile(objMap)
	}
	return
}

// UnmarshalImagePrototypeImageByFileSliceAsProperty unmarshals a slice of ImagePrototypeImageByFile instances that are stored as a property
// within the specified map.
func UnmarshalImagePrototypeImageByFileSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ImagePrototypeImageByFile, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ImagePrototypeImageByFile'", propertyName)
			return
		}
		slice, err = UnmarshalImagePrototypeImageByFileSlice(vSlice)
	}
	return
}

// InstanceProfileBandwidthDependent : The total bandwidth shared across the network interfaces of an instance with this profile depends on its
// configuration.
// This model "extends" InstanceProfileBandwidth
type InstanceProfileBandwidthDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileBandwidthDependent.Type property.
// The type for this profile field.
const (
	InstanceProfileBandwidthDependent_Type_Dependent = "dependent"
)

func (*InstanceProfileBandwidthDependent) isaInstanceProfileBandwidth() bool {
	return true
}

// UnmarshalInstanceProfileBandwidthDependent constructs an instance of InstanceProfileBandwidthDependent from the specified map.
func UnmarshalInstanceProfileBandwidthDependent(m map[string]interface{}) (result *InstanceProfileBandwidthDependent, err error) {
	obj := new(InstanceProfileBandwidthDependent)
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileBandwidthDependentSlice unmarshals a slice of InstanceProfileBandwidthDependent instances from the specified list of maps.
func UnmarshalInstanceProfileBandwidthDependentSlice(s []interface{}) (slice []InstanceProfileBandwidthDependent, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileBandwidthDependent'")
			return
		}
		obj, e := UnmarshalInstanceProfileBandwidthDependent(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfileBandwidthDependentAsProperty unmarshals an instance of InstanceProfileBandwidthDependent that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileBandwidthDependentAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfileBandwidthDependent, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileBandwidthDependent'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileBandwidthDependent(objMap)
	}
	return
}

// UnmarshalInstanceProfileBandwidthDependentSliceAsProperty unmarshals a slice of InstanceProfileBandwidthDependent instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileBandwidthDependentSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileBandwidthDependent, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileBandwidthDependent'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileBandwidthDependentSlice(vSlice)
	}
	return
}

// InstanceProfileBandwidthEnum : The permitted total bandwidth values (in megabits per second) shared across the network interfaces of an instance
// with this profile.
// This model "extends" InstanceProfileBandwidth
type InstanceProfileBandwidthEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileBandwidthEnum.Type property.
// The type for this profile field.
const (
	InstanceProfileBandwidthEnum_Type_Enum = "enum"
)

func (*InstanceProfileBandwidthEnum) isaInstanceProfileBandwidth() bool {
	return true
}

// UnmarshalInstanceProfileBandwidthEnum constructs an instance of InstanceProfileBandwidthEnum from the specified map.
func UnmarshalInstanceProfileBandwidthEnum(m map[string]interface{}) (result *InstanceProfileBandwidthEnum, err error) {
	obj := new(InstanceProfileBandwidthEnum)
	obj.Default, err = core.UnmarshalInt64(m, "default")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.Values, err = core.UnmarshalInt64Slice(m, "values")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileBandwidthEnumSlice unmarshals a slice of InstanceProfileBandwidthEnum instances from the specified list of maps.
func UnmarshalInstanceProfileBandwidthEnumSlice(s []interface{}) (slice []InstanceProfileBandwidthEnum, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileBandwidthEnum'")
			return
		}
		obj, e := UnmarshalInstanceProfileBandwidthEnum(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfileBandwidthEnumAsProperty unmarshals an instance of InstanceProfileBandwidthEnum that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileBandwidthEnumAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfileBandwidthEnum, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileBandwidthEnum'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileBandwidthEnum(objMap)
	}
	return
}

// UnmarshalInstanceProfileBandwidthEnumSliceAsProperty unmarshals a slice of InstanceProfileBandwidthEnum instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileBandwidthEnumSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileBandwidthEnum, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileBandwidthEnum'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileBandwidthEnumSlice(vSlice)
	}
	return
}

// InstanceProfileBandwidthFixed : The total bandwidth (in megabits per second) shared across the network interfaces of an instance with this profile.
// This model "extends" InstanceProfileBandwidth
type InstanceProfileBandwidthFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileBandwidthFixed.Type property.
// The type for this profile field.
const (
	InstanceProfileBandwidthFixed_Type_Fixed = "fixed"
)

func (*InstanceProfileBandwidthFixed) isaInstanceProfileBandwidth() bool {
	return true
}

// UnmarshalInstanceProfileBandwidthFixed constructs an instance of InstanceProfileBandwidthFixed from the specified map.
func UnmarshalInstanceProfileBandwidthFixed(m map[string]interface{}) (result *InstanceProfileBandwidthFixed, err error) {
	obj := new(InstanceProfileBandwidthFixed)
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.Value, err = core.UnmarshalInt64(m, "value")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileBandwidthFixedSlice unmarshals a slice of InstanceProfileBandwidthFixed instances from the specified list of maps.
func UnmarshalInstanceProfileBandwidthFixedSlice(s []interface{}) (slice []InstanceProfileBandwidthFixed, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileBandwidthFixed'")
			return
		}
		obj, e := UnmarshalInstanceProfileBandwidthFixed(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfileBandwidthFixedAsProperty unmarshals an instance of InstanceProfileBandwidthFixed that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileBandwidthFixedAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfileBandwidthFixed, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileBandwidthFixed'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileBandwidthFixed(objMap)
	}
	return
}

// UnmarshalInstanceProfileBandwidthFixedSliceAsProperty unmarshals a slice of InstanceProfileBandwidthFixed instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileBandwidthFixedSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileBandwidthFixed, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileBandwidthFixed'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileBandwidthFixedSlice(vSlice)
	}
	return
}

// InstanceProfileBandwidthRange : The permitted total bandwidth range (in megabits per second) shared across the network interfaces of an instance with
// this profile.
// This model "extends" InstanceProfileBandwidth
type InstanceProfileBandwidthRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileBandwidthRange.Type property.
// The type for this profile field.
const (
	InstanceProfileBandwidthRange_Type_Range = "range"
)

func (*InstanceProfileBandwidthRange) isaInstanceProfileBandwidth() bool {
	return true
}

// UnmarshalInstanceProfileBandwidthRange constructs an instance of InstanceProfileBandwidthRange from the specified map.
func UnmarshalInstanceProfileBandwidthRange(m map[string]interface{}) (result *InstanceProfileBandwidthRange, err error) {
	obj := new(InstanceProfileBandwidthRange)
	obj.Default, err = core.UnmarshalInt64(m, "default")
	if err != nil {
		return
	}
	obj.Max, err = core.UnmarshalInt64(m, "max")
	if err != nil {
		return
	}
	obj.Min, err = core.UnmarshalInt64(m, "min")
	if err != nil {
		return
	}
	obj.Step, err = core.UnmarshalInt64(m, "step")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileBandwidthRangeSlice unmarshals a slice of InstanceProfileBandwidthRange instances from the specified list of maps.
func UnmarshalInstanceProfileBandwidthRangeSlice(s []interface{}) (slice []InstanceProfileBandwidthRange, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileBandwidthRange'")
			return
		}
		obj, e := UnmarshalInstanceProfileBandwidthRange(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfileBandwidthRangeAsProperty unmarshals an instance of InstanceProfileBandwidthRange that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileBandwidthRangeAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfileBandwidthRange, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileBandwidthRange'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileBandwidthRange(objMap)
	}
	return
}

// UnmarshalInstanceProfileBandwidthRangeSliceAsProperty unmarshals a slice of InstanceProfileBandwidthRange instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileBandwidthRangeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileBandwidthRange, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileBandwidthRange'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileBandwidthRangeSlice(vSlice)
	}
	return
}

// InstanceProfileIdentityByHref : InstanceProfileIdentityByHref struct
// This model "extends" InstanceProfileIdentity
type InstanceProfileIdentityByHref struct {
	// The URL for this virtual server instance profile.
	Href *string `json:"href" validate:"required"`
}

// NewInstanceProfileIdentityByHref : Instantiate InstanceProfileIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewInstanceProfileIdentityByHref(href string) (model *InstanceProfileIdentityByHref, err error) {
	model = &InstanceProfileIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstanceProfileIdentityByHref) isaInstanceProfileIdentity() bool {
	return true
}

// UnmarshalInstanceProfileIdentityByHref constructs an instance of InstanceProfileIdentityByHref from the specified map.
func UnmarshalInstanceProfileIdentityByHref(m map[string]interface{}) (result *InstanceProfileIdentityByHref, err error) {
	obj := new(InstanceProfileIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileIdentityByHrefSlice unmarshals a slice of InstanceProfileIdentityByHref instances from the specified list of maps.
func UnmarshalInstanceProfileIdentityByHrefSlice(s []interface{}) (slice []InstanceProfileIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileIdentityByHref'")
			return
		}
		obj, e := UnmarshalInstanceProfileIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfileIdentityByHrefAsProperty unmarshals an instance of InstanceProfileIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfileIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileIdentityByHref(objMap)
	}
	return
}

// UnmarshalInstanceProfileIdentityByHrefSliceAsProperty unmarshals a slice of InstanceProfileIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileIdentityByHrefSlice(vSlice)
	}
	return
}

// InstanceProfileIdentityByName : InstanceProfileIdentityByName struct
// This model "extends" InstanceProfileIdentity
type InstanceProfileIdentityByName struct {
	// The name for this virtual server instance profile.
	Name *string `json:"name" validate:"required"`
}

// NewInstanceProfileIdentityByName : Instantiate InstanceProfileIdentityByName (Generic Model Constructor)
func (*VpcV1) NewInstanceProfileIdentityByName(name string) (model *InstanceProfileIdentityByName, err error) {
	model = &InstanceProfileIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstanceProfileIdentityByName) isaInstanceProfileIdentity() bool {
	return true
}

// UnmarshalInstanceProfileIdentityByName constructs an instance of InstanceProfileIdentityByName from the specified map.
func UnmarshalInstanceProfileIdentityByName(m map[string]interface{}) (result *InstanceProfileIdentityByName, err error) {
	obj := new(InstanceProfileIdentityByName)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileIdentityByNameSlice unmarshals a slice of InstanceProfileIdentityByName instances from the specified list of maps.
func UnmarshalInstanceProfileIdentityByNameSlice(s []interface{}) (slice []InstanceProfileIdentityByName, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileIdentityByName'")
			return
		}
		obj, e := UnmarshalInstanceProfileIdentityByName(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfileIdentityByNameAsProperty unmarshals an instance of InstanceProfileIdentityByName that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileIdentityByNameAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfileIdentityByName, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileIdentityByName'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileIdentityByName(objMap)
	}
	return
}

// UnmarshalInstanceProfileIdentityByNameSliceAsProperty unmarshals a slice of InstanceProfileIdentityByName instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileIdentityByNameSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileIdentityByName, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileIdentityByName'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileIdentityByNameSlice(vSlice)
	}
	return
}

// InstanceProfileMemoryDependent : The memory value for an instance with this profile depends on its configuration.
// This model "extends" InstanceProfileMemory
type InstanceProfileMemoryDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileMemoryDependent.Type property.
// The type for this profile field.
const (
	InstanceProfileMemoryDependent_Type_Dependent = "dependent"
)

func (*InstanceProfileMemoryDependent) isaInstanceProfileMemory() bool {
	return true
}

// UnmarshalInstanceProfileMemoryDependent constructs an instance of InstanceProfileMemoryDependent from the specified map.
func UnmarshalInstanceProfileMemoryDependent(m map[string]interface{}) (result *InstanceProfileMemoryDependent, err error) {
	obj := new(InstanceProfileMemoryDependent)
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileMemoryDependentSlice unmarshals a slice of InstanceProfileMemoryDependent instances from the specified list of maps.
func UnmarshalInstanceProfileMemoryDependentSlice(s []interface{}) (slice []InstanceProfileMemoryDependent, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileMemoryDependent'")
			return
		}
		obj, e := UnmarshalInstanceProfileMemoryDependent(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfileMemoryDependentAsProperty unmarshals an instance of InstanceProfileMemoryDependent that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileMemoryDependentAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfileMemoryDependent, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileMemoryDependent'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileMemoryDependent(objMap)
	}
	return
}

// UnmarshalInstanceProfileMemoryDependentSliceAsProperty unmarshals a slice of InstanceProfileMemoryDependent instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileMemoryDependentSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileMemoryDependent, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileMemoryDependent'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileMemoryDependentSlice(vSlice)
	}
	return
}

// InstanceProfileMemoryEnum : The permitted memory values (in gigabytes) for an instance with this profile.
// This model "extends" InstanceProfileMemory
type InstanceProfileMemoryEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileMemoryEnum.Type property.
// The type for this profile field.
const (
	InstanceProfileMemoryEnum_Type_Enum = "enum"
)

func (*InstanceProfileMemoryEnum) isaInstanceProfileMemory() bool {
	return true
}

// UnmarshalInstanceProfileMemoryEnum constructs an instance of InstanceProfileMemoryEnum from the specified map.
func UnmarshalInstanceProfileMemoryEnum(m map[string]interface{}) (result *InstanceProfileMemoryEnum, err error) {
	obj := new(InstanceProfileMemoryEnum)
	obj.Default, err = core.UnmarshalInt64(m, "default")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.Values, err = core.UnmarshalInt64Slice(m, "values")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileMemoryEnumSlice unmarshals a slice of InstanceProfileMemoryEnum instances from the specified list of maps.
func UnmarshalInstanceProfileMemoryEnumSlice(s []interface{}) (slice []InstanceProfileMemoryEnum, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileMemoryEnum'")
			return
		}
		obj, e := UnmarshalInstanceProfileMemoryEnum(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfileMemoryEnumAsProperty unmarshals an instance of InstanceProfileMemoryEnum that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileMemoryEnumAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfileMemoryEnum, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileMemoryEnum'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileMemoryEnum(objMap)
	}
	return
}

// UnmarshalInstanceProfileMemoryEnumSliceAsProperty unmarshals a slice of InstanceProfileMemoryEnum instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileMemoryEnumSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileMemoryEnum, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileMemoryEnum'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileMemoryEnumSlice(vSlice)
	}
	return
}

// InstanceProfileMemoryFixed : The memory (in gigabytes) for an instance with this profile.
// This model "extends" InstanceProfileMemory
type InstanceProfileMemoryFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileMemoryFixed.Type property.
// The type for this profile field.
const (
	InstanceProfileMemoryFixed_Type_Fixed = "fixed"
)

func (*InstanceProfileMemoryFixed) isaInstanceProfileMemory() bool {
	return true
}

// UnmarshalInstanceProfileMemoryFixed constructs an instance of InstanceProfileMemoryFixed from the specified map.
func UnmarshalInstanceProfileMemoryFixed(m map[string]interface{}) (result *InstanceProfileMemoryFixed, err error) {
	obj := new(InstanceProfileMemoryFixed)
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.Value, err = core.UnmarshalInt64(m, "value")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileMemoryFixedSlice unmarshals a slice of InstanceProfileMemoryFixed instances from the specified list of maps.
func UnmarshalInstanceProfileMemoryFixedSlice(s []interface{}) (slice []InstanceProfileMemoryFixed, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileMemoryFixed'")
			return
		}
		obj, e := UnmarshalInstanceProfileMemoryFixed(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfileMemoryFixedAsProperty unmarshals an instance of InstanceProfileMemoryFixed that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileMemoryFixedAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfileMemoryFixed, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileMemoryFixed'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileMemoryFixed(objMap)
	}
	return
}

// UnmarshalInstanceProfileMemoryFixedSliceAsProperty unmarshals a slice of InstanceProfileMemoryFixed instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileMemoryFixedSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileMemoryFixed, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileMemoryFixed'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileMemoryFixedSlice(vSlice)
	}
	return
}

// InstanceProfileMemoryRange : The permitted memory range (in gigabytes) for an instance with this profile.
// This model "extends" InstanceProfileMemory
type InstanceProfileMemoryRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileMemoryRange.Type property.
// The type for this profile field.
const (
	InstanceProfileMemoryRange_Type_Range = "range"
)

func (*InstanceProfileMemoryRange) isaInstanceProfileMemory() bool {
	return true
}

// UnmarshalInstanceProfileMemoryRange constructs an instance of InstanceProfileMemoryRange from the specified map.
func UnmarshalInstanceProfileMemoryRange(m map[string]interface{}) (result *InstanceProfileMemoryRange, err error) {
	obj := new(InstanceProfileMemoryRange)
	obj.Default, err = core.UnmarshalInt64(m, "default")
	if err != nil {
		return
	}
	obj.Max, err = core.UnmarshalInt64(m, "max")
	if err != nil {
		return
	}
	obj.Min, err = core.UnmarshalInt64(m, "min")
	if err != nil {
		return
	}
	obj.Step, err = core.UnmarshalInt64(m, "step")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileMemoryRangeSlice unmarshals a slice of InstanceProfileMemoryRange instances from the specified list of maps.
func UnmarshalInstanceProfileMemoryRangeSlice(s []interface{}) (slice []InstanceProfileMemoryRange, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileMemoryRange'")
			return
		}
		obj, e := UnmarshalInstanceProfileMemoryRange(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfileMemoryRangeAsProperty unmarshals an instance of InstanceProfileMemoryRange that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileMemoryRangeAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfileMemoryRange, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileMemoryRange'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileMemoryRange(objMap)
	}
	return
}

// UnmarshalInstanceProfileMemoryRangeSliceAsProperty unmarshals a slice of InstanceProfileMemoryRange instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileMemoryRangeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileMemoryRange, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileMemoryRange'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileMemoryRangeSlice(vSlice)
	}
	return
}

// InstanceProfilePortSpeedDependent : The port speed of each network interface of an instance with this profile depends on its configuration.
// This model "extends" InstanceProfilePortSpeed
type InstanceProfilePortSpeedDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfilePortSpeedDependent.Type property.
// The type for this profile field.
const (
	InstanceProfilePortSpeedDependent_Type_Dependent = "dependent"
)

func (*InstanceProfilePortSpeedDependent) isaInstanceProfilePortSpeed() bool {
	return true
}

// UnmarshalInstanceProfilePortSpeedDependent constructs an instance of InstanceProfilePortSpeedDependent from the specified map.
func UnmarshalInstanceProfilePortSpeedDependent(m map[string]interface{}) (result *InstanceProfilePortSpeedDependent, err error) {
	obj := new(InstanceProfilePortSpeedDependent)
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfilePortSpeedDependentSlice unmarshals a slice of InstanceProfilePortSpeedDependent instances from the specified list of maps.
func UnmarshalInstanceProfilePortSpeedDependentSlice(s []interface{}) (slice []InstanceProfilePortSpeedDependent, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfilePortSpeedDependent'")
			return
		}
		obj, e := UnmarshalInstanceProfilePortSpeedDependent(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfilePortSpeedDependentAsProperty unmarshals an instance of InstanceProfilePortSpeedDependent that is stored as a property
// within the specified map.
func UnmarshalInstanceProfilePortSpeedDependentAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfilePortSpeedDependent, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfilePortSpeedDependent'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfilePortSpeedDependent(objMap)
	}
	return
}

// UnmarshalInstanceProfilePortSpeedDependentSliceAsProperty unmarshals a slice of InstanceProfilePortSpeedDependent instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfilePortSpeedDependentSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfilePortSpeedDependent, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfilePortSpeedDependent'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfilePortSpeedDependentSlice(vSlice)
	}
	return
}

// InstanceProfilePortSpeedFixed : The maximum speed (in megabits per second) of each network interface of an instance with this profile.
// This model "extends" InstanceProfilePortSpeed
type InstanceProfilePortSpeedFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfilePortSpeedFixed.Type property.
// The type for this profile field.
const (
	InstanceProfilePortSpeedFixed_Type_Fixed = "fixed"
)

func (*InstanceProfilePortSpeedFixed) isaInstanceProfilePortSpeed() bool {
	return true
}

// UnmarshalInstanceProfilePortSpeedFixed constructs an instance of InstanceProfilePortSpeedFixed from the specified map.
func UnmarshalInstanceProfilePortSpeedFixed(m map[string]interface{}) (result *InstanceProfilePortSpeedFixed, err error) {
	obj := new(InstanceProfilePortSpeedFixed)
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.Value, err = core.UnmarshalInt64(m, "value")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfilePortSpeedFixedSlice unmarshals a slice of InstanceProfilePortSpeedFixed instances from the specified list of maps.
func UnmarshalInstanceProfilePortSpeedFixedSlice(s []interface{}) (slice []InstanceProfilePortSpeedFixed, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfilePortSpeedFixed'")
			return
		}
		obj, e := UnmarshalInstanceProfilePortSpeedFixed(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfilePortSpeedFixedAsProperty unmarshals an instance of InstanceProfilePortSpeedFixed that is stored as a property
// within the specified map.
func UnmarshalInstanceProfilePortSpeedFixedAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfilePortSpeedFixed, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfilePortSpeedFixed'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfilePortSpeedFixed(objMap)
	}
	return
}

// UnmarshalInstanceProfilePortSpeedFixedSliceAsProperty unmarshals a slice of InstanceProfilePortSpeedFixed instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfilePortSpeedFixedSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfilePortSpeedFixed, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfilePortSpeedFixed'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfilePortSpeedFixedSlice(vSlice)
	}
	return
}

// InstanceProfileVCPUDependent : The VCPU count for an instance with this profile depends on its configuration.
// This model "extends" InstanceProfileVCPU
type InstanceProfileVCPUDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileVCPUDependent.Type property.
// The type for this profile field.
const (
	InstanceProfileVCPUDependent_Type_Dependent = "dependent"
)

func (*InstanceProfileVCPUDependent) isaInstanceProfileVCPU() bool {
	return true
}

// UnmarshalInstanceProfileVCPUDependent constructs an instance of InstanceProfileVCPUDependent from the specified map.
func UnmarshalInstanceProfileVCPUDependent(m map[string]interface{}) (result *InstanceProfileVCPUDependent, err error) {
	obj := new(InstanceProfileVCPUDependent)
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileVCPUDependentSlice unmarshals a slice of InstanceProfileVCPUDependent instances from the specified list of maps.
func UnmarshalInstanceProfileVCPUDependentSlice(s []interface{}) (slice []InstanceProfileVCPUDependent, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileVCPUDependent'")
			return
		}
		obj, e := UnmarshalInstanceProfileVCPUDependent(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfileVCPUDependentAsProperty unmarshals an instance of InstanceProfileVCPUDependent that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileVCPUDependentAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfileVCPUDependent, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileVCPUDependent'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileVCPUDependent(objMap)
	}
	return
}

// UnmarshalInstanceProfileVCPUDependentSliceAsProperty unmarshals a slice of InstanceProfileVCPUDependent instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileVCPUDependentSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileVCPUDependent, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileVCPUDependent'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileVCPUDependentSlice(vSlice)
	}
	return
}

// InstanceProfileVCPUEnum : The permitted values for VCPU count for an instance with this profile.
// This model "extends" InstanceProfileVCPU
type InstanceProfileVCPUEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileVCPUEnum.Type property.
// The type for this profile field.
const (
	InstanceProfileVCPUEnum_Type_Enum = "enum"
)

func (*InstanceProfileVCPUEnum) isaInstanceProfileVCPU() bool {
	return true
}

// UnmarshalInstanceProfileVCPUEnum constructs an instance of InstanceProfileVCPUEnum from the specified map.
func UnmarshalInstanceProfileVCPUEnum(m map[string]interface{}) (result *InstanceProfileVCPUEnum, err error) {
	obj := new(InstanceProfileVCPUEnum)
	obj.Default, err = core.UnmarshalInt64(m, "default")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.Values, err = core.UnmarshalInt64Slice(m, "values")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileVCPUEnumSlice unmarshals a slice of InstanceProfileVCPUEnum instances from the specified list of maps.
func UnmarshalInstanceProfileVCPUEnumSlice(s []interface{}) (slice []InstanceProfileVCPUEnum, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileVCPUEnum'")
			return
		}
		obj, e := UnmarshalInstanceProfileVCPUEnum(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfileVCPUEnumAsProperty unmarshals an instance of InstanceProfileVCPUEnum that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileVCPUEnumAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfileVCPUEnum, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileVCPUEnum'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileVCPUEnum(objMap)
	}
	return
}

// UnmarshalInstanceProfileVCPUEnumSliceAsProperty unmarshals a slice of InstanceProfileVCPUEnum instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileVCPUEnumSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileVCPUEnum, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileVCPUEnum'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileVCPUEnumSlice(vSlice)
	}
	return
}

// InstanceProfileVCPUFixed : The VCPU count for an instance with this profile.
// This model "extends" InstanceProfileVCPU
type InstanceProfileVCPUFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileVCPUFixed.Type property.
// The type for this profile field.
const (
	InstanceProfileVCPUFixed_Type_Fixed = "fixed"
)

func (*InstanceProfileVCPUFixed) isaInstanceProfileVCPU() bool {
	return true
}

// UnmarshalInstanceProfileVCPUFixed constructs an instance of InstanceProfileVCPUFixed from the specified map.
func UnmarshalInstanceProfileVCPUFixed(m map[string]interface{}) (result *InstanceProfileVCPUFixed, err error) {
	obj := new(InstanceProfileVCPUFixed)
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	obj.Value, err = core.UnmarshalInt64(m, "value")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileVCPUFixedSlice unmarshals a slice of InstanceProfileVCPUFixed instances from the specified list of maps.
func UnmarshalInstanceProfileVCPUFixedSlice(s []interface{}) (slice []InstanceProfileVCPUFixed, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileVCPUFixed'")
			return
		}
		obj, e := UnmarshalInstanceProfileVCPUFixed(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfileVCPUFixedAsProperty unmarshals an instance of InstanceProfileVCPUFixed that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileVCPUFixedAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfileVCPUFixed, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileVCPUFixed'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileVCPUFixed(objMap)
	}
	return
}

// UnmarshalInstanceProfileVCPUFixedSliceAsProperty unmarshals a slice of InstanceProfileVCPUFixed instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileVCPUFixedSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileVCPUFixed, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileVCPUFixed'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileVCPUFixedSlice(vSlice)
	}
	return
}

// InstanceProfileVCPURange : The permitted range for VCPU count for an instance with this profile.
// This model "extends" InstanceProfileVCPU
type InstanceProfileVCPURange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileVCPURange.Type property.
// The type for this profile field.
const (
	InstanceProfileVCPURange_Type_Range = "range"
)

func (*InstanceProfileVCPURange) isaInstanceProfileVCPU() bool {
	return true
}

// UnmarshalInstanceProfileVCPURange constructs an instance of InstanceProfileVCPURange from the specified map.
func UnmarshalInstanceProfileVCPURange(m map[string]interface{}) (result *InstanceProfileVCPURange, err error) {
	obj := new(InstanceProfileVCPURange)
	obj.Default, err = core.UnmarshalInt64(m, "default")
	if err != nil {
		return
	}
	obj.Max, err = core.UnmarshalInt64(m, "max")
	if err != nil {
		return
	}
	obj.Min, err = core.UnmarshalInt64(m, "min")
	if err != nil {
		return
	}
	obj.Step, err = core.UnmarshalInt64(m, "step")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalString(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstanceProfileVCPURangeSlice unmarshals a slice of InstanceProfileVCPURange instances from the specified list of maps.
func UnmarshalInstanceProfileVCPURangeSlice(s []interface{}) (slice []InstanceProfileVCPURange, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstanceProfileVCPURange'")
			return
		}
		obj, e := UnmarshalInstanceProfileVCPURange(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstanceProfileVCPURangeAsProperty unmarshals an instance of InstanceProfileVCPURange that is stored as a property
// within the specified map.
func UnmarshalInstanceProfileVCPURangeAsProperty(m map[string]interface{}, propertyName string) (result *InstanceProfileVCPURange, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstanceProfileVCPURange'", propertyName)
			return
		}
		result, err = UnmarshalInstanceProfileVCPURange(objMap)
	}
	return
}

// UnmarshalInstanceProfileVCPURangeSliceAsProperty unmarshals a slice of InstanceProfileVCPURange instances that are stored as a property
// within the specified map.
func UnmarshalInstanceProfileVCPURangeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstanceProfileVCPURange, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstanceProfileVCPURange'", propertyName)
			return
		}
		slice, err = UnmarshalInstanceProfileVCPURangeSlice(vSlice)
	}
	return
}

// InstancePrototypeInstanceByImage : InstancePrototypeInstanceByImage struct
// This model "extends" InstancePrototype
type InstancePrototypeInstanceByImage struct {
	// The public SSH keys to install on the virtual server instance. Up to 10 keys may be provided; if no keys are
	// provided the instance will be inaccessible unless the image used provides a means of access. For Windows instances,
	// one of the keys will be used to encrypt the administrator password.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	// The unique user-defined name for this virtual server instance (and default system hostname). If unspecified, the
	// name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Collection of additional network interfaces to create for the virtual server instance.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The profile to use for this virtual server instance.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// User data to be made available when setting up the virtual server instance.
	UserData *string `json:"user_data,omitempty"`

	// Collection of volume attachments.
	VolumeAttachments []VolumeAttachmentPrototypeInstanceContext `json:"volume_attachments,omitempty"`

	// The VPC the virtual server instance is to be a part of. If provided, must match the
	// VPC tied to the subnets of the instance's network interfaces.
	Vpc VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The identity of the image to be used when provisioning the virtual server instance.
	Image ImageIdentityIntf `json:"image" validate:"required"`

	// Primary network interface.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface" validate:"required"`

	// The identity of the zone to provision the virtual server instance in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// NewInstancePrototypeInstanceByImage : Instantiate InstancePrototypeInstanceByImage (Generic Model Constructor)
func (*VpcV1) NewInstancePrototypeInstanceByImage(image ImageIdentityIntf, primaryNetworkInterface *NetworkInterfacePrototype, zone ZoneIdentityIntf) (model *InstancePrototypeInstanceByImage, err error) {
	model = &InstancePrototypeInstanceByImage{
		Image:                   image,
		PrimaryNetworkInterface: primaryNetworkInterface,
		Zone:                    zone,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstancePrototypeInstanceByImage) isaInstancePrototype() bool {
	return true
}

// UnmarshalInstancePrototypeInstanceByImage constructs an instance of InstancePrototypeInstanceByImage from the specified map.
func UnmarshalInstancePrototypeInstanceByImage(m map[string]interface{}) (result *InstancePrototypeInstanceByImage, err error) {
	obj := new(InstancePrototypeInstanceByImage)
	obj.Keys, err = UnmarshalKeyIdentitySliceAsProperty(m, "keys")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.NetworkInterfaces, err = UnmarshalNetworkInterfacePrototypeSliceAsProperty(m, "network_interfaces")
	if err != nil {
		return
	}
	obj.Profile, err = UnmarshalInstanceProfileIdentityAsProperty(m, "profile")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupIdentityAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.UserData, err = core.UnmarshalString(m, "user_data")
	if err != nil {
		return
	}
	obj.VolumeAttachments, err = UnmarshalVolumeAttachmentPrototypeInstanceContextSliceAsProperty(m, "volume_attachments")
	if err != nil {
		return
	}
	obj.Vpc, err = UnmarshalVPCIdentityAsProperty(m, "vpc")
	if err != nil {
		return
	}
	obj.BootVolumeAttachment, err = UnmarshalVolumeAttachmentPrototypeInstanceByImageContextAsProperty(m, "boot_volume_attachment")
	if err != nil {
		return
	}
	obj.Image, err = UnmarshalImageIdentityAsProperty(m, "image")
	if err != nil {
		return
	}
	obj.PrimaryNetworkInterface, err = UnmarshalNetworkInterfacePrototypeAsProperty(m, "primary_network_interface")
	if err != nil {
		return
	}
	obj.Zone, err = UnmarshalZoneIdentityAsProperty(m, "zone")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalInstancePrototypeInstanceByImageSlice unmarshals a slice of InstancePrototypeInstanceByImage instances from the specified list of maps.
func UnmarshalInstancePrototypeInstanceByImageSlice(s []interface{}) (slice []InstancePrototypeInstanceByImage, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'InstancePrototypeInstanceByImage'")
			return
		}
		obj, e := UnmarshalInstancePrototypeInstanceByImage(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalInstancePrototypeInstanceByImageAsProperty unmarshals an instance of InstancePrototypeInstanceByImage that is stored as a property
// within the specified map.
func UnmarshalInstancePrototypeInstanceByImageAsProperty(m map[string]interface{}, propertyName string) (result *InstancePrototypeInstanceByImage, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'InstancePrototypeInstanceByImage'", propertyName)
			return
		}
		result, err = UnmarshalInstancePrototypeInstanceByImage(objMap)
	}
	return
}

// UnmarshalInstancePrototypeInstanceByImageSliceAsProperty unmarshals a slice of InstancePrototypeInstanceByImage instances that are stored as a property
// within the specified map.
func UnmarshalInstancePrototypeInstanceByImageSliceAsProperty(m map[string]interface{}, propertyName string) (slice []InstancePrototypeInstanceByImage, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'InstancePrototypeInstanceByImage'", propertyName)
			return
		}
		slice, err = UnmarshalInstancePrototypeInstanceByImageSlice(vSlice)
	}
	return
}

// KeyIdentityByCRN : KeyIdentityByCRN struct
// This model "extends" KeyIdentity
type KeyIdentityByCRN struct {
	// The CRN for this key.
	Crn *string `json:"crn" validate:"required"`
}

// NewKeyIdentityByCRN : Instantiate KeyIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewKeyIdentityByCRN(crn string) (model *KeyIdentityByCRN, err error) {
	model = &KeyIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*KeyIdentityByCRN) isaKeyIdentity() bool {
	return true
}

// UnmarshalKeyIdentityByCRN constructs an instance of KeyIdentityByCRN from the specified map.
func UnmarshalKeyIdentityByCRN(m map[string]interface{}) (result *KeyIdentityByCRN, err error) {
	obj := new(KeyIdentityByCRN)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalKeyIdentityByCRNSlice unmarshals a slice of KeyIdentityByCRN instances from the specified list of maps.
func UnmarshalKeyIdentityByCRNSlice(s []interface{}) (slice []KeyIdentityByCRN, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'KeyIdentityByCRN'")
			return
		}
		obj, e := UnmarshalKeyIdentityByCRN(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalKeyIdentityByCRNAsProperty unmarshals an instance of KeyIdentityByCRN that is stored as a property
// within the specified map.
func UnmarshalKeyIdentityByCRNAsProperty(m map[string]interface{}, propertyName string) (result *KeyIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'KeyIdentityByCRN'", propertyName)
			return
		}
		result, err = UnmarshalKeyIdentityByCRN(objMap)
	}
	return
}

// UnmarshalKeyIdentityByCRNSliceAsProperty unmarshals a slice of KeyIdentityByCRN instances that are stored as a property
// within the specified map.
func UnmarshalKeyIdentityByCRNSliceAsProperty(m map[string]interface{}, propertyName string) (slice []KeyIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'KeyIdentityByCRN'", propertyName)
			return
		}
		slice, err = UnmarshalKeyIdentityByCRNSlice(vSlice)
	}
	return
}

// KeyIdentityByFingerprint : KeyIdentityByFingerprint struct
// This model "extends" KeyIdentity
type KeyIdentityByFingerprint struct {
	// The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm (always
	// `SHA256`).
	Fingerprint *string `json:"fingerprint" validate:"required"`
}

// NewKeyIdentityByFingerprint : Instantiate KeyIdentityByFingerprint (Generic Model Constructor)
func (*VpcV1) NewKeyIdentityByFingerprint(fingerprint string) (model *KeyIdentityByFingerprint, err error) {
	model = &KeyIdentityByFingerprint{
		Fingerprint: core.StringPtr(fingerprint),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*KeyIdentityByFingerprint) isaKeyIdentity() bool {
	return true
}

// UnmarshalKeyIdentityByFingerprint constructs an instance of KeyIdentityByFingerprint from the specified map.
func UnmarshalKeyIdentityByFingerprint(m map[string]interface{}) (result *KeyIdentityByFingerprint, err error) {
	obj := new(KeyIdentityByFingerprint)
	obj.Fingerprint, err = core.UnmarshalString(m, "fingerprint")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalKeyIdentityByFingerprintSlice unmarshals a slice of KeyIdentityByFingerprint instances from the specified list of maps.
func UnmarshalKeyIdentityByFingerprintSlice(s []interface{}) (slice []KeyIdentityByFingerprint, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'KeyIdentityByFingerprint'")
			return
		}
		obj, e := UnmarshalKeyIdentityByFingerprint(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalKeyIdentityByFingerprintAsProperty unmarshals an instance of KeyIdentityByFingerprint that is stored as a property
// within the specified map.
func UnmarshalKeyIdentityByFingerprintAsProperty(m map[string]interface{}, propertyName string) (result *KeyIdentityByFingerprint, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'KeyIdentityByFingerprint'", propertyName)
			return
		}
		result, err = UnmarshalKeyIdentityByFingerprint(objMap)
	}
	return
}

// UnmarshalKeyIdentityByFingerprintSliceAsProperty unmarshals a slice of KeyIdentityByFingerprint instances that are stored as a property
// within the specified map.
func UnmarshalKeyIdentityByFingerprintSliceAsProperty(m map[string]interface{}, propertyName string) (slice []KeyIdentityByFingerprint, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'KeyIdentityByFingerprint'", propertyName)
			return
		}
		slice, err = UnmarshalKeyIdentityByFingerprintSlice(vSlice)
	}
	return
}

// KeyIdentityByHref : KeyIdentityByHref struct
// This model "extends" KeyIdentity
type KeyIdentityByHref struct {
	// The URL for this key.
	Href *string `json:"href" validate:"required"`
}

// NewKeyIdentityByHref : Instantiate KeyIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewKeyIdentityByHref(href string) (model *KeyIdentityByHref, err error) {
	model = &KeyIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*KeyIdentityByHref) isaKeyIdentity() bool {
	return true
}

// UnmarshalKeyIdentityByHref constructs an instance of KeyIdentityByHref from the specified map.
func UnmarshalKeyIdentityByHref(m map[string]interface{}) (result *KeyIdentityByHref, err error) {
	obj := new(KeyIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalKeyIdentityByHrefSlice unmarshals a slice of KeyIdentityByHref instances from the specified list of maps.
func UnmarshalKeyIdentityByHrefSlice(s []interface{}) (slice []KeyIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'KeyIdentityByHref'")
			return
		}
		obj, e := UnmarshalKeyIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalKeyIdentityByHrefAsProperty unmarshals an instance of KeyIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalKeyIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *KeyIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'KeyIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalKeyIdentityByHref(objMap)
	}
	return
}

// UnmarshalKeyIdentityByHrefSliceAsProperty unmarshals a slice of KeyIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalKeyIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []KeyIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'KeyIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalKeyIdentityByHrefSlice(vSlice)
	}
	return
}

// KeyIdentityByID : KeyIdentityByID struct
// This model "extends" KeyIdentity
type KeyIdentityByID struct {
	// The unique identifier for this key.
	ID *string `json:"id" validate:"required"`
}

// NewKeyIdentityByID : Instantiate KeyIdentityByID (Generic Model Constructor)
func (*VpcV1) NewKeyIdentityByID(id string) (model *KeyIdentityByID, err error) {
	model = &KeyIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*KeyIdentityByID) isaKeyIdentity() bool {
	return true
}

// UnmarshalKeyIdentityByID constructs an instance of KeyIdentityByID from the specified map.
func UnmarshalKeyIdentityByID(m map[string]interface{}) (result *KeyIdentityByID, err error) {
	obj := new(KeyIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalKeyIdentityByIDSlice unmarshals a slice of KeyIdentityByID instances from the specified list of maps.
func UnmarshalKeyIdentityByIDSlice(s []interface{}) (slice []KeyIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'KeyIdentityByID'")
			return
		}
		obj, e := UnmarshalKeyIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalKeyIdentityByIDAsProperty unmarshals an instance of KeyIdentityByID that is stored as a property
// within the specified map.
func UnmarshalKeyIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *KeyIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'KeyIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalKeyIdentityByID(objMap)
	}
	return
}

// UnmarshalKeyIdentityByIDSliceAsProperty unmarshals a slice of KeyIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalKeyIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []KeyIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'KeyIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalKeyIdentityByIDSlice(vSlice)
	}
	return
}

// KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint : KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint struct
// This model "extends" KeyReferenceInstanceInitializationContext
type KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint struct {
	// The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm (always
	// `SHA256`).
	Fingerprint *string `json:"fingerprint" validate:"required"`
}

func (*KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint) isaKeyReferenceInstanceInitializationContext() bool {
	return true
}

// UnmarshalKeyReferenceInstanceInitializationContextKeyIdentityByFingerprint constructs an instance of KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint from the specified map.
func UnmarshalKeyReferenceInstanceInitializationContextKeyIdentityByFingerprint(m map[string]interface{}) (result *KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint, err error) {
	obj := new(KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint)
	obj.Fingerprint, err = core.UnmarshalString(m, "fingerprint")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalKeyReferenceInstanceInitializationContextKeyIdentityByFingerprintSlice unmarshals a slice of KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint instances from the specified list of maps.
func UnmarshalKeyReferenceInstanceInitializationContextKeyIdentityByFingerprintSlice(s []interface{}) (slice []KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint'")
			return
		}
		obj, e := UnmarshalKeyReferenceInstanceInitializationContextKeyIdentityByFingerprint(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalKeyReferenceInstanceInitializationContextKeyIdentityByFingerprintAsProperty unmarshals an instance of KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint that is stored as a property
// within the specified map.
func UnmarshalKeyReferenceInstanceInitializationContextKeyIdentityByFingerprintAsProperty(m map[string]interface{}, propertyName string) (result *KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint'", propertyName)
			return
		}
		result, err = UnmarshalKeyReferenceInstanceInitializationContextKeyIdentityByFingerprint(objMap)
	}
	return
}

// UnmarshalKeyReferenceInstanceInitializationContextKeyIdentityByFingerprintSliceAsProperty unmarshals a slice of KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint instances that are stored as a property
// within the specified map.
func UnmarshalKeyReferenceInstanceInitializationContextKeyIdentityByFingerprintSliceAsProperty(m map[string]interface{}, propertyName string) (slice []KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint'", propertyName)
			return
		}
		slice, err = UnmarshalKeyReferenceInstanceInitializationContextKeyIdentityByFingerprintSlice(vSlice)
	}
	return
}

// KeyReferenceInstanceInitializationContextKeyReference : KeyReferenceInstanceInitializationContextKeyReference struct
// This model "extends" KeyReferenceInstanceInitializationContext
type KeyReferenceInstanceInitializationContextKeyReference struct {
	// The CRN for this key.
	Crn *string `json:"crn" validate:"required"`

	// The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm (always
	// `SHA256`).
	Fingerprint *string `json:"fingerprint" validate:"required"`

	// The URL for this key.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this key.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this key.
	Name *string `json:"name" validate:"required"`
}

func (*KeyReferenceInstanceInitializationContextKeyReference) isaKeyReferenceInstanceInitializationContext() bool {
	return true
}

// UnmarshalKeyReferenceInstanceInitializationContextKeyReference constructs an instance of KeyReferenceInstanceInitializationContextKeyReference from the specified map.
func UnmarshalKeyReferenceInstanceInitializationContextKeyReference(m map[string]interface{}) (result *KeyReferenceInstanceInitializationContextKeyReference, err error) {
	obj := new(KeyReferenceInstanceInitializationContextKeyReference)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Fingerprint, err = core.UnmarshalString(m, "fingerprint")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalKeyReferenceInstanceInitializationContextKeyReferenceSlice unmarshals a slice of KeyReferenceInstanceInitializationContextKeyReference instances from the specified list of maps.
func UnmarshalKeyReferenceInstanceInitializationContextKeyReferenceSlice(s []interface{}) (slice []KeyReferenceInstanceInitializationContextKeyReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'KeyReferenceInstanceInitializationContextKeyReference'")
			return
		}
		obj, e := UnmarshalKeyReferenceInstanceInitializationContextKeyReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalKeyReferenceInstanceInitializationContextKeyReferenceAsProperty unmarshals an instance of KeyReferenceInstanceInitializationContextKeyReference that is stored as a property
// within the specified map.
func UnmarshalKeyReferenceInstanceInitializationContextKeyReferenceAsProperty(m map[string]interface{}, propertyName string) (result *KeyReferenceInstanceInitializationContextKeyReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'KeyReferenceInstanceInitializationContextKeyReference'", propertyName)
			return
		}
		result, err = UnmarshalKeyReferenceInstanceInitializationContextKeyReference(objMap)
	}
	return
}

// UnmarshalKeyReferenceInstanceInitializationContextKeyReferenceSliceAsProperty unmarshals a slice of KeyReferenceInstanceInitializationContextKeyReference instances that are stored as a property
// within the specified map.
func UnmarshalKeyReferenceInstanceInitializationContextKeyReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []KeyReferenceInstanceInitializationContextKeyReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'KeyReferenceInstanceInitializationContextKeyReference'", propertyName)
			return
		}
		slice, err = UnmarshalKeyReferenceInstanceInitializationContextKeyReferenceSlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch : LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch struct
// This model "extends" LoadBalancerListenerPolicyPatchTarget
type LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch struct {
	// The http status code in the redirect response.
	HttpStatusCode *int64 `json:"http_status_code,omitempty"`

	// The redirect target URL.
	URL *string `json:"url,omitempty"`
}

func (*LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch) isaLoadBalancerListenerPolicyPatchTarget() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch constructs an instance of LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch from the specified map.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch(m map[string]interface{}) (result *LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch, err error) {
	obj := new(LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch)
	obj.HttpStatusCode, err = core.UnmarshalInt64(m, "http_status_code")
	if err != nil {
		return
	}
	obj.URL, err = core.UnmarshalString(m, "url")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatchSlice unmarshals a slice of LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatchSlice(s []interface{}) (slice []LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatchAsProperty unmarshals an instance of LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatchAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatchSliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatchSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatchSlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity : Identifies a load balancer pool by a unique property.
// Models which "extend" this model:
// - LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID
// - LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref
// This model "extends" LoadBalancerListenerPolicyPatchTarget
type LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id,omitempty"`

	// The pool's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity) isaLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity() bool {
	return true
}

type LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityIntf interface {
	LoadBalancerListenerPolicyPatchTargetIntf
	isaLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity() bool
}

func (*LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity) isaLoadBalancerListenerPolicyPatchTarget() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity constructs an instance of LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity from the specified map.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity(m map[string]interface{}) (result LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityIntf, err error) {
	obj := new(LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentitySlice unmarshals a slice of LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentitySlice(s []interface{}) (slice []LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityAsProperty unmarshals an instance of LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityAsProperty(m map[string]interface{}, propertyName string) (result LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentitySliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentitySlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype : LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype struct
// This model "extends" LoadBalancerListenerPolicyPrototypeTarget
type LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype struct {
	// The http status code in the redirect response.
	HttpStatusCode *int64 `json:"http_status_code" validate:"required"`

	// The redirect target URL.
	URL *string `json:"url" validate:"required"`
}

// NewLoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype : Instantiate LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype(httpStatusCode int64, url string) (model *LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype, err error) {
	model = &LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype{
		HttpStatusCode: core.Int64Ptr(httpStatusCode),
		URL:            core.StringPtr(url),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype) isaLoadBalancerListenerPolicyPrototypeTarget() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype constructs an instance of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype from the specified map.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype(m map[string]interface{}) (result *LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype, err error) {
	obj := new(LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype)
	obj.HttpStatusCode, err = core.UnmarshalInt64(m, "http_status_code")
	if err != nil {
		return
	}
	obj.URL, err = core.UnmarshalString(m, "url")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototypeSlice unmarshals a slice of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototypeSlice(s []interface{}) (slice []LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototypeAsProperty unmarshals an instance of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototypeAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototypeSliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototypeSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototypeSlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity : Identifies a load balancer pool by a unique property.
// Models which "extend" this model:
// - LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID
// - LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref
// This model "extends" LoadBalancerListenerPolicyPrototypeTarget
type LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id,omitempty"`

	// The pool's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity) isaLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity() bool {
	return true
}

type LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityIntf interface {
	LoadBalancerListenerPolicyPrototypeTargetIntf
	isaLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity() bool
}

func (*LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity) isaLoadBalancerListenerPolicyPrototypeTarget() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity constructs an instance of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity from the specified map.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity(m map[string]interface{}) (result LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityIntf, err error) {
	obj := new(LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentitySlice unmarshals a slice of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentitySlice(s []interface{}) (slice []LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityAsProperty unmarshals an instance of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityAsProperty(m map[string]interface{}, propertyName string) (result LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentitySliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentitySlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL : LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL struct
// This model "extends" LoadBalancerListenerPolicyTargetReference
type LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL struct {
	// The http status code in the redirect response.
	HttpStatusCode *int64 `json:"http_status_code" validate:"required"`

	// The redirect target URL.
	URL *string `json:"url" validate:"required"`
}

func (*LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL) isaLoadBalancerListenerPolicyTargetReference() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL constructs an instance of LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL from the specified map.
func UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL(m map[string]interface{}) (result *LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL, err error) {
	obj := new(LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL)
	obj.HttpStatusCode, err = core.UnmarshalInt64(m, "http_status_code")
	if err != nil {
		return
	}
	obj.URL, err = core.UnmarshalString(m, "url")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURLSlice unmarshals a slice of LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURLSlice(s []interface{}) (slice []LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURLAsProperty unmarshals an instance of LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURLAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURLSliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURLSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURLSlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference : LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference struct
// This model "extends" LoadBalancerListenerPolicyTargetReference
type LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference struct {
	// The pool's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer pool.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this load balancer pool.
	Name *string `json:"name" validate:"required"`
}

func (*LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference) isaLoadBalancerListenerPolicyTargetReference() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference constructs an instance of LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference from the specified map.
func UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference(m map[string]interface{}) (result *LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference, err error) {
	obj := new(LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReferenceSlice unmarshals a slice of LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReferenceSlice(s []interface{}) (slice []LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReferenceAsProperty unmarshals an instance of LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReferenceAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReferenceSliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReferenceSlice(vSlice)
	}
	return
}

// LoadBalancerPoolIdentityByHref : LoadBalancerPoolIdentityByHref struct
// This model "extends" LoadBalancerPoolIdentity
type LoadBalancerPoolIdentityByHref struct {
	// The pool's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewLoadBalancerPoolIdentityByHref : Instantiate LoadBalancerPoolIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolIdentityByHref(href string) (model *LoadBalancerPoolIdentityByHref, err error) {
	model = &LoadBalancerPoolIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerPoolIdentityByHref) isaLoadBalancerPoolIdentity() bool {
	return true
}

// UnmarshalLoadBalancerPoolIdentityByHref constructs an instance of LoadBalancerPoolIdentityByHref from the specified map.
func UnmarshalLoadBalancerPoolIdentityByHref(m map[string]interface{}) (result *LoadBalancerPoolIdentityByHref, err error) {
	obj := new(LoadBalancerPoolIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolIdentityByHrefSlice unmarshals a slice of LoadBalancerPoolIdentityByHref instances from the specified list of maps.
func UnmarshalLoadBalancerPoolIdentityByHrefSlice(s []interface{}) (slice []LoadBalancerPoolIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolIdentityByHref'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerPoolIdentityByHrefAsProperty unmarshals an instance of LoadBalancerPoolIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerPoolIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolIdentityByHref(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolIdentityByHrefSliceAsProperty unmarshals a slice of LoadBalancerPoolIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolIdentityByHrefSlice(vSlice)
	}
	return
}

// LoadBalancerPoolIdentityByID : LoadBalancerPoolIdentityByID struct
// This model "extends" LoadBalancerPoolIdentity
type LoadBalancerPoolIdentityByID struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id" validate:"required"`
}

// NewLoadBalancerPoolIdentityByID : Instantiate LoadBalancerPoolIdentityByID (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolIdentityByID(id string) (model *LoadBalancerPoolIdentityByID, err error) {
	model = &LoadBalancerPoolIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerPoolIdentityByID) isaLoadBalancerPoolIdentity() bool {
	return true
}

// UnmarshalLoadBalancerPoolIdentityByID constructs an instance of LoadBalancerPoolIdentityByID from the specified map.
func UnmarshalLoadBalancerPoolIdentityByID(m map[string]interface{}) (result *LoadBalancerPoolIdentityByID, err error) {
	obj := new(LoadBalancerPoolIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolIdentityByIDSlice unmarshals a slice of LoadBalancerPoolIdentityByID instances from the specified list of maps.
func UnmarshalLoadBalancerPoolIdentityByIDSlice(s []interface{}) (slice []LoadBalancerPoolIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolIdentityByID'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerPoolIdentityByIDAsProperty unmarshals an instance of LoadBalancerPoolIdentityByID that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerPoolIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolIdentityByID(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolIdentityByIDSliceAsProperty unmarshals a slice of LoadBalancerPoolIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolIdentityByIDSlice(vSlice)
	}
	return
}

// LoadBalancerPoolMemberTargetByAddress : The IP address targeted by the pool member.
// This model "extends" LoadBalancerPoolMemberTarget
type LoadBalancerPoolMemberTargetByAddress struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

func (*LoadBalancerPoolMemberTargetByAddress) isaLoadBalancerPoolMemberTarget() bool {
	return true
}

// UnmarshalLoadBalancerPoolMemberTargetByAddress constructs an instance of LoadBalancerPoolMemberTargetByAddress from the specified map.
func UnmarshalLoadBalancerPoolMemberTargetByAddress(m map[string]interface{}) (result *LoadBalancerPoolMemberTargetByAddress, err error) {
	obj := new(LoadBalancerPoolMemberTargetByAddress)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolMemberTargetByAddressSlice unmarshals a slice of LoadBalancerPoolMemberTargetByAddress instances from the specified list of maps.
func UnmarshalLoadBalancerPoolMemberTargetByAddressSlice(s []interface{}) (slice []LoadBalancerPoolMemberTargetByAddress, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolMemberTargetByAddress'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolMemberTargetByAddress(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerPoolMemberTargetByAddressAsProperty unmarshals an instance of LoadBalancerPoolMemberTargetByAddress that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolMemberTargetByAddressAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerPoolMemberTargetByAddress, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolMemberTargetByAddress'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolMemberTargetByAddress(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolMemberTargetByAddressSliceAsProperty unmarshals a slice of LoadBalancerPoolMemberTargetByAddress instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolMemberTargetByAddressSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolMemberTargetByAddress, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolMemberTargetByAddress'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolMemberTargetByAddressSlice(vSlice)
	}
	return
}

// LoadBalancerPoolMemberTargetPrototypeByAddress : The IP address to be targeted by the pool member.
// This model "extends" LoadBalancerPoolMemberTargetPrototype
type LoadBalancerPoolMemberTargetPrototypeByAddress struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewLoadBalancerPoolMemberTargetPrototypeByAddress : Instantiate LoadBalancerPoolMemberTargetPrototypeByAddress (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolMemberTargetPrototypeByAddress(address string) (model *LoadBalancerPoolMemberTargetPrototypeByAddress, err error) {
	model = &LoadBalancerPoolMemberTargetPrototypeByAddress{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerPoolMemberTargetPrototypeByAddress) isaLoadBalancerPoolMemberTargetPrototype() bool {
	return true
}

// UnmarshalLoadBalancerPoolMemberTargetPrototypeByAddress constructs an instance of LoadBalancerPoolMemberTargetPrototypeByAddress from the specified map.
func UnmarshalLoadBalancerPoolMemberTargetPrototypeByAddress(m map[string]interface{}) (result *LoadBalancerPoolMemberTargetPrototypeByAddress, err error) {
	obj := new(LoadBalancerPoolMemberTargetPrototypeByAddress)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerPoolMemberTargetPrototypeByAddressSlice unmarshals a slice of LoadBalancerPoolMemberTargetPrototypeByAddress instances from the specified list of maps.
func UnmarshalLoadBalancerPoolMemberTargetPrototypeByAddressSlice(s []interface{}) (slice []LoadBalancerPoolMemberTargetPrototypeByAddress, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerPoolMemberTargetPrototypeByAddress'")
			return
		}
		obj, e := UnmarshalLoadBalancerPoolMemberTargetPrototypeByAddress(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerPoolMemberTargetPrototypeByAddressAsProperty unmarshals an instance of LoadBalancerPoolMemberTargetPrototypeByAddress that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolMemberTargetPrototypeByAddressAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerPoolMemberTargetPrototypeByAddress, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerPoolMemberTargetPrototypeByAddress'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerPoolMemberTargetPrototypeByAddress(objMap)
	}
	return
}

// UnmarshalLoadBalancerPoolMemberTargetPrototypeByAddressSliceAsProperty unmarshals a slice of LoadBalancerPoolMemberTargetPrototypeByAddress instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerPoolMemberTargetPrototypeByAddressSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerPoolMemberTargetPrototypeByAddress, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerPoolMemberTargetPrototypeByAddress'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerPoolMemberTargetPrototypeByAddressSlice(vSlice)
	}
	return
}

// NetworkACLIdentityByCRN : NetworkACLIdentityByCRN struct
// This model "extends" NetworkACLIdentity
type NetworkACLIdentityByCRN struct {
	// The CRN for this network ACL.
	Crn *string `json:"crn" validate:"required"`
}

// NewNetworkACLIdentityByCRN : Instantiate NetworkACLIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewNetworkACLIdentityByCRN(crn string) (model *NetworkACLIdentityByCRN, err error) {
	model = &NetworkACLIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLIdentityByCRN) isaNetworkACLIdentity() bool {
	return true
}

// UnmarshalNetworkACLIdentityByCRN constructs an instance of NetworkACLIdentityByCRN from the specified map.
func UnmarshalNetworkACLIdentityByCRN(m map[string]interface{}) (result *NetworkACLIdentityByCRN, err error) {
	obj := new(NetworkACLIdentityByCRN)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLIdentityByCRNSlice unmarshals a slice of NetworkACLIdentityByCRN instances from the specified list of maps.
func UnmarshalNetworkACLIdentityByCRNSlice(s []interface{}) (slice []NetworkACLIdentityByCRN, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLIdentityByCRN'")
			return
		}
		obj, e := UnmarshalNetworkACLIdentityByCRN(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLIdentityByCRNAsProperty unmarshals an instance of NetworkACLIdentityByCRN that is stored as a property
// within the specified map.
func UnmarshalNetworkACLIdentityByCRNAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLIdentityByCRN'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLIdentityByCRN(objMap)
	}
	return
}

// UnmarshalNetworkACLIdentityByCRNSliceAsProperty unmarshals a slice of NetworkACLIdentityByCRN instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLIdentityByCRNSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLIdentityByCRN'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLIdentityByCRNSlice(vSlice)
	}
	return
}

// NetworkACLIdentityByHref : NetworkACLIdentityByHref struct
// This model "extends" NetworkACLIdentity
type NetworkACLIdentityByHref struct {
	// The URL for this network ACL.
	Href *string `json:"href" validate:"required"`
}

// NewNetworkACLIdentityByHref : Instantiate NetworkACLIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewNetworkACLIdentityByHref(href string) (model *NetworkACLIdentityByHref, err error) {
	model = &NetworkACLIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLIdentityByHref) isaNetworkACLIdentity() bool {
	return true
}

// UnmarshalNetworkACLIdentityByHref constructs an instance of NetworkACLIdentityByHref from the specified map.
func UnmarshalNetworkACLIdentityByHref(m map[string]interface{}) (result *NetworkACLIdentityByHref, err error) {
	obj := new(NetworkACLIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLIdentityByHrefSlice unmarshals a slice of NetworkACLIdentityByHref instances from the specified list of maps.
func UnmarshalNetworkACLIdentityByHrefSlice(s []interface{}) (slice []NetworkACLIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLIdentityByHref'")
			return
		}
		obj, e := UnmarshalNetworkACLIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLIdentityByHrefAsProperty unmarshals an instance of NetworkACLIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalNetworkACLIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLIdentityByHref(objMap)
	}
	return
}

// UnmarshalNetworkACLIdentityByHrefSliceAsProperty unmarshals a slice of NetworkACLIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLIdentityByHrefSlice(vSlice)
	}
	return
}

// NetworkACLIdentityByID : NetworkACLIdentityByID struct
// This model "extends" NetworkACLIdentity
type NetworkACLIdentityByID struct {
	// The unique identifier for this network ACL.
	ID *string `json:"id" validate:"required"`
}

// NewNetworkACLIdentityByID : Instantiate NetworkACLIdentityByID (Generic Model Constructor)
func (*VpcV1) NewNetworkACLIdentityByID(id string) (model *NetworkACLIdentityByID, err error) {
	model = &NetworkACLIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLIdentityByID) isaNetworkACLIdentity() bool {
	return true
}

// UnmarshalNetworkACLIdentityByID constructs an instance of NetworkACLIdentityByID from the specified map.
func UnmarshalNetworkACLIdentityByID(m map[string]interface{}) (result *NetworkACLIdentityByID, err error) {
	obj := new(NetworkACLIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLIdentityByIDSlice unmarshals a slice of NetworkACLIdentityByID instances from the specified list of maps.
func UnmarshalNetworkACLIdentityByIDSlice(s []interface{}) (slice []NetworkACLIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLIdentityByID'")
			return
		}
		obj, e := UnmarshalNetworkACLIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLIdentityByIDAsProperty unmarshals an instance of NetworkACLIdentityByID that is stored as a property
// within the specified map.
func UnmarshalNetworkACLIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLIdentityByID(objMap)
	}
	return
}

// UnmarshalNetworkACLIdentityByIDSliceAsProperty unmarshals a slice of NetworkACLIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLIdentityByIDSlice(vSlice)
	}
	return
}

// NetworkACLPrototypeNetworkACLByRules : NetworkACLPrototypeNetworkACLByRules struct
// This model "extends" NetworkACLPrototype
type NetworkACLPrototypeNetworkACLByRules struct {
	// The user-defined name for this network ACL. Names must be unique within the VPC the Network ACL resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The VPC this network ACL is to be a part of.
	Vpc VPCIdentityIntf `json:"vpc" validate:"required"`

	// Array of prototype objects for rules to create along with this network ACL. If unspecified, no rules will be
	// created, resulting in all traffic being denied.
	Rules []NetworkACLRulePrototypeNetworkACLContextIntf `json:"rules,omitempty"`
}

// NewNetworkACLPrototypeNetworkACLByRules : Instantiate NetworkACLPrototypeNetworkACLByRules (Generic Model Constructor)
func (*VpcV1) NewNetworkACLPrototypeNetworkACLByRules(vpc VPCIdentityIntf) (model *NetworkACLPrototypeNetworkACLByRules, err error) {
	model = &NetworkACLPrototypeNetworkACLByRules{
		Vpc: vpc,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLPrototypeNetworkACLByRules) isaNetworkACLPrototype() bool {
	return true
}

// UnmarshalNetworkACLPrototypeNetworkACLByRules constructs an instance of NetworkACLPrototypeNetworkACLByRules from the specified map.
func UnmarshalNetworkACLPrototypeNetworkACLByRules(m map[string]interface{}) (result *NetworkACLPrototypeNetworkACLByRules, err error) {
	obj := new(NetworkACLPrototypeNetworkACLByRules)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupIdentityAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Vpc, err = UnmarshalVPCIdentityAsProperty(m, "vpc")
	if err != nil {
		return
	}
	obj.Rules, err = UnmarshalNetworkACLRulePrototypeNetworkACLContextSliceAsProperty(m, "rules")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLPrototypeNetworkACLByRulesSlice unmarshals a slice of NetworkACLPrototypeNetworkACLByRules instances from the specified list of maps.
func UnmarshalNetworkACLPrototypeNetworkACLByRulesSlice(s []interface{}) (slice []NetworkACLPrototypeNetworkACLByRules, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLPrototypeNetworkACLByRules'")
			return
		}
		obj, e := UnmarshalNetworkACLPrototypeNetworkACLByRules(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLPrototypeNetworkACLByRulesAsProperty unmarshals an instance of NetworkACLPrototypeNetworkACLByRules that is stored as a property
// within the specified map.
func UnmarshalNetworkACLPrototypeNetworkACLByRulesAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLPrototypeNetworkACLByRules, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLPrototypeNetworkACLByRules'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLPrototypeNetworkACLByRules(objMap)
	}
	return
}

// UnmarshalNetworkACLPrototypeNetworkACLByRulesSliceAsProperty unmarshals a slice of NetworkACLPrototypeNetworkACLByRules instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLPrototypeNetworkACLByRulesSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLPrototypeNetworkACLByRules, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLPrototypeNetworkACLByRules'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLPrototypeNetworkACLByRulesSlice(vSlice)
	}
	return
}

// NetworkACLPrototypeNetworkACLBySourceNetworkACL : NetworkACLPrototypeNetworkACLBySourceNetworkACL struct
// This model "extends" NetworkACLPrototype
type NetworkACLPrototypeNetworkACLBySourceNetworkACL struct {
	// The user-defined name for this network ACL. Names must be unique within the VPC the Network ACL resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The VPC this network ACL is to be a part of.
	Vpc VPCIdentityIntf `json:"vpc" validate:"required"`

	// Network ACL to copy rules from.
	SourceNetworkAcl NetworkACLIdentityIntf `json:"source_network_acl" validate:"required"`
}

// NewNetworkACLPrototypeNetworkACLBySourceNetworkACL : Instantiate NetworkACLPrototypeNetworkACLBySourceNetworkACL (Generic Model Constructor)
func (*VpcV1) NewNetworkACLPrototypeNetworkACLBySourceNetworkACL(vpc VPCIdentityIntf, sourceNetworkAcl NetworkACLIdentityIntf) (model *NetworkACLPrototypeNetworkACLBySourceNetworkACL, err error) {
	model = &NetworkACLPrototypeNetworkACLBySourceNetworkACL{
		Vpc:              vpc,
		SourceNetworkAcl: sourceNetworkAcl,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLPrototypeNetworkACLBySourceNetworkACL) isaNetworkACLPrototype() bool {
	return true
}

// UnmarshalNetworkACLPrototypeNetworkACLBySourceNetworkACL constructs an instance of NetworkACLPrototypeNetworkACLBySourceNetworkACL from the specified map.
func UnmarshalNetworkACLPrototypeNetworkACLBySourceNetworkACL(m map[string]interface{}) (result *NetworkACLPrototypeNetworkACLBySourceNetworkACL, err error) {
	obj := new(NetworkACLPrototypeNetworkACLBySourceNetworkACL)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupIdentityAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Vpc, err = UnmarshalVPCIdentityAsProperty(m, "vpc")
	if err != nil {
		return
	}
	obj.SourceNetworkAcl, err = UnmarshalNetworkACLIdentityAsProperty(m, "source_network_acl")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLPrototypeNetworkACLBySourceNetworkACLSlice unmarshals a slice of NetworkACLPrototypeNetworkACLBySourceNetworkACL instances from the specified list of maps.
func UnmarshalNetworkACLPrototypeNetworkACLBySourceNetworkACLSlice(s []interface{}) (slice []NetworkACLPrototypeNetworkACLBySourceNetworkACL, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLPrototypeNetworkACLBySourceNetworkACL'")
			return
		}
		obj, e := UnmarshalNetworkACLPrototypeNetworkACLBySourceNetworkACL(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLPrototypeNetworkACLBySourceNetworkACLAsProperty unmarshals an instance of NetworkACLPrototypeNetworkACLBySourceNetworkACL that is stored as a property
// within the specified map.
func UnmarshalNetworkACLPrototypeNetworkACLBySourceNetworkACLAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLPrototypeNetworkACLBySourceNetworkACL, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLPrototypeNetworkACLBySourceNetworkACL'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLPrototypeNetworkACLBySourceNetworkACL(objMap)
	}
	return
}

// UnmarshalNetworkACLPrototypeNetworkACLBySourceNetworkACLSliceAsProperty unmarshals a slice of NetworkACLPrototypeNetworkACLBySourceNetworkACL instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLPrototypeNetworkACLBySourceNetworkACLSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLPrototypeNetworkACLBySourceNetworkACL, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLPrototypeNetworkACLBySourceNetworkACL'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLPrototypeNetworkACLBySourceNetworkACLSlice(vSlice)
	}
	return
}

// NetworkACLRuleItemNetworkACLRuleProtocolAll : NetworkACLRuleItemNetworkACLRuleProtocolAll struct
// This model "extends" NetworkACLRuleItem
type NetworkACLRuleItemNetworkACLRuleProtocolAll struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IpVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`
}

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolAll.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolAll_Action_Allow = "allow"
	NetworkACLRuleItemNetworkACLRuleProtocolAll_Action_Deny  = "deny"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolAll.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolAll_Direction_Inbound  = "inbound"
	NetworkACLRuleItemNetworkACLRuleProtocolAll_Direction_Outbound = "outbound"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolAll.IpVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolAll_IpVersion_Ipv4 = "ipv4"
	NetworkACLRuleItemNetworkACLRuleProtocolAll_IpVersion_Ipv6 = "ipv6"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolAll.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolAll_Protocol_All  = "all"
	NetworkACLRuleItemNetworkACLRuleProtocolAll_Protocol_Icmp = "icmp"
	NetworkACLRuleItemNetworkACLRuleProtocolAll_Protocol_Tcp  = "tcp"
	NetworkACLRuleItemNetworkACLRuleProtocolAll_Protocol_Udp  = "udp"
)

func (*NetworkACLRuleItemNetworkACLRuleProtocolAll) isaNetworkACLRuleItem() bool {
	return true
}

// UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolAll constructs an instance of NetworkACLRuleItemNetworkACLRuleProtocolAll from the specified map.
func UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolAll(m map[string]interface{}) (result *NetworkACLRuleItemNetworkACLRuleProtocolAll, err error) {
	obj := new(NetworkACLRuleItemNetworkACLRuleProtocolAll)
	obj.Action, err = core.UnmarshalString(m, "action")
	if err != nil {
		return
	}
	obj.Before, err = UnmarshalNetworkACLRuleReferenceAsProperty(m, "before")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Destination, err = core.UnmarshalString(m, "destination")
	if err != nil {
		return
	}
	obj.Direction, err = core.UnmarshalString(m, "direction")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.Source, err = core.UnmarshalString(m, "source")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolAllSlice unmarshals a slice of NetworkACLRuleItemNetworkACLRuleProtocolAll instances from the specified list of maps.
func UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolAllSlice(s []interface{}) (slice []NetworkACLRuleItemNetworkACLRuleProtocolAll, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRuleItemNetworkACLRuleProtocolAll'")
			return
		}
		obj, e := UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolAll(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolAllAsProperty unmarshals an instance of NetworkACLRuleItemNetworkACLRuleProtocolAll that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolAllAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRuleItemNetworkACLRuleProtocolAll, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRuleItemNetworkACLRuleProtocolAll'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolAll(objMap)
	}
	return
}

// UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolAllSliceAsProperty unmarshals a slice of NetworkACLRuleItemNetworkACLRuleProtocolAll instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolAllSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRuleItemNetworkACLRuleProtocolAll, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRuleItemNetworkACLRuleProtocolAll'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolAllSlice(vSlice)
	}
	return
}

// NetworkACLRuleItemNetworkACLRuleProtocolICMP : NetworkACLRuleItemNetworkACLRuleProtocolICMP struct
// This model "extends" NetworkACLRuleItem
type NetworkACLRuleItemNetworkACLRuleProtocolICMP struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IpVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The ICMP traffic code to allow. If unspecified, all codes are allowed. This can only be specified if type is also
	// specified.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow. If unspecified, all types are allowed by this rule.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolICMP.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolICMP_Action_Allow = "allow"
	NetworkACLRuleItemNetworkACLRuleProtocolICMP_Action_Deny  = "deny"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolICMP.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolICMP_Direction_Inbound  = "inbound"
	NetworkACLRuleItemNetworkACLRuleProtocolICMP_Direction_Outbound = "outbound"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolICMP.IpVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolICMP_IpVersion_Ipv4 = "ipv4"
	NetworkACLRuleItemNetworkACLRuleProtocolICMP_IpVersion_Ipv6 = "ipv6"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolICMP.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolICMP_Protocol_All  = "all"
	NetworkACLRuleItemNetworkACLRuleProtocolICMP_Protocol_Icmp = "icmp"
	NetworkACLRuleItemNetworkACLRuleProtocolICMP_Protocol_Tcp  = "tcp"
	NetworkACLRuleItemNetworkACLRuleProtocolICMP_Protocol_Udp  = "udp"
)

func (*NetworkACLRuleItemNetworkACLRuleProtocolICMP) isaNetworkACLRuleItem() bool {
	return true
}

// UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolICMP constructs an instance of NetworkACLRuleItemNetworkACLRuleProtocolICMP from the specified map.
func UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolICMP(m map[string]interface{}) (result *NetworkACLRuleItemNetworkACLRuleProtocolICMP, err error) {
	obj := new(NetworkACLRuleItemNetworkACLRuleProtocolICMP)
	obj.Action, err = core.UnmarshalString(m, "action")
	if err != nil {
		return
	}
	obj.Before, err = UnmarshalNetworkACLRuleReferenceAsProperty(m, "before")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Destination, err = core.UnmarshalString(m, "destination")
	if err != nil {
		return
	}
	obj.Direction, err = core.UnmarshalString(m, "direction")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.Source, err = core.UnmarshalString(m, "source")
	if err != nil {
		return
	}
	obj.Code, err = core.UnmarshalInt64(m, "code")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalInt64(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolICMPSlice unmarshals a slice of NetworkACLRuleItemNetworkACLRuleProtocolICMP instances from the specified list of maps.
func UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolICMPSlice(s []interface{}) (slice []NetworkACLRuleItemNetworkACLRuleProtocolICMP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRuleItemNetworkACLRuleProtocolICMP'")
			return
		}
		obj, e := UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolICMP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolICMPAsProperty unmarshals an instance of NetworkACLRuleItemNetworkACLRuleProtocolICMP that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolICMPAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRuleItemNetworkACLRuleProtocolICMP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRuleItemNetworkACLRuleProtocolICMP'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolICMP(objMap)
	}
	return
}

// UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolICMPSliceAsProperty unmarshals a slice of NetworkACLRuleItemNetworkACLRuleProtocolICMP instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolICMPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRuleItemNetworkACLRuleProtocolICMP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRuleItemNetworkACLRuleProtocolICMP'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolICMPSlice(vSlice)
	}
	return
}

// NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP : NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP struct
// This model "extends" NetworkACLRuleItem
type NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IpVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`
}

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP_Action_Allow = "allow"
	NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP_Action_Deny  = "deny"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP_Direction_Inbound  = "inbound"
	NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP_Direction_Outbound = "outbound"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP.IpVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP_IpVersion_Ipv4 = "ipv4"
	NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP_IpVersion_Ipv6 = "ipv6"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP_Protocol_All  = "all"
	NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP_Protocol_Icmp = "icmp"
	NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP_Protocol_Tcp  = "tcp"
	NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP_Protocol_Udp  = "udp"
)

func (*NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP) isaNetworkACLRuleItem() bool {
	return true
}

// UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTCPUDP constructs an instance of NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP from the specified map.
func UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTCPUDP(m map[string]interface{}) (result *NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP, err error) {
	obj := new(NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP)
	obj.Action, err = core.UnmarshalString(m, "action")
	if err != nil {
		return
	}
	obj.Before, err = UnmarshalNetworkACLRuleReferenceAsProperty(m, "before")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Destination, err = core.UnmarshalString(m, "destination")
	if err != nil {
		return
	}
	obj.Direction, err = core.UnmarshalString(m, "direction")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.Source, err = core.UnmarshalString(m, "source")
	if err != nil {
		return
	}
	obj.DestinationPortMax, err = core.UnmarshalInt64(m, "destination_port_max")
	if err != nil {
		return
	}
	obj.DestinationPortMin, err = core.UnmarshalInt64(m, "destination_port_min")
	if err != nil {
		return
	}
	obj.SourcePortMax, err = core.UnmarshalInt64(m, "source_port_max")
	if err != nil {
		return
	}
	obj.SourcePortMin, err = core.UnmarshalInt64(m, "source_port_min")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTCPUDPSlice unmarshals a slice of NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP instances from the specified list of maps.
func UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTCPUDPSlice(s []interface{}) (slice []NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP'")
			return
		}
		obj, e := UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTCPUDP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTCPUDPAsProperty unmarshals an instance of NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTCPUDPAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTCPUDP(objMap)
	}
	return
}

// UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTCPUDPSliceAsProperty unmarshals a slice of NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTCPUDPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTCPUDPSlice(vSlice)
	}
	return
}

// NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref : NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref struct
// This model "extends" NetworkACLRulePatchBefore
type NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref struct {
	// The URL for this rule.
	Href *string `json:"href" validate:"required"`
}

// NewNetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref : Instantiate NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref(href string) (model *NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref, err error) {
	model = &NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref) isaNetworkACLRulePatchBefore() bool {
	return true
}

// UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref constructs an instance of NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref from the specified map.
func UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref(m map[string]interface{}) (result *NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref, err error) {
	obj := new(NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByHrefSlice unmarshals a slice of NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref instances from the specified list of maps.
func UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByHrefSlice(s []interface{}) (slice []NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref'")
			return
		}
		obj, e := UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByHrefAsProperty unmarshals an instance of NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref(objMap)
	}
	return
}

// UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByHrefSliceAsProperty unmarshals a slice of NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByHrefSlice(vSlice)
	}
	return
}

// NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID : NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID struct
// This model "extends" NetworkACLRulePatchBefore
type NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID struct {
	// The unique identifier for this rule.
	ID *string `json:"id" validate:"required"`
}

// NewNetworkACLRulePatchBeforeNetworkACLRuleIdentityByID : Instantiate NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePatchBeforeNetworkACLRuleIdentityByID(id string) (model *NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID, err error) {
	model = &NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID) isaNetworkACLRulePatchBefore() bool {
	return true
}

// UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByID constructs an instance of NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID from the specified map.
func UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByID(m map[string]interface{}) (result *NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID, err error) {
	obj := new(NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByIDSlice unmarshals a slice of NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID instances from the specified list of maps.
func UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByIDSlice(s []interface{}) (slice []NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID'")
			return
		}
		obj, e := UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByIDAsProperty unmarshals an instance of NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByID(objMap)
	}
	return
}

// UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByIDSliceAsProperty unmarshals a slice of NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByIDSlice(vSlice)
	}
	return
}

// NetworkACLRuleProtocolAll : NetworkACLRuleProtocolAll struct
// This model "extends" NetworkACLRule
type NetworkACLRuleProtocolAll struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IpVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`
}

// Constants associated with the NetworkACLRuleProtocolAll.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRuleProtocolAll_Action_Allow = "allow"
	NetworkACLRuleProtocolAll_Action_Deny  = "deny"
)

// Constants associated with the NetworkACLRuleProtocolAll.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRuleProtocolAll_Direction_Inbound  = "inbound"
	NetworkACLRuleProtocolAll_Direction_Outbound = "outbound"
)

// Constants associated with the NetworkACLRuleProtocolAll.IpVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleProtocolAll_IpVersion_Ipv4 = "ipv4"
	NetworkACLRuleProtocolAll_IpVersion_Ipv6 = "ipv6"
)

// Constants associated with the NetworkACLRuleProtocolAll.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleProtocolAll_Protocol_All  = "all"
	NetworkACLRuleProtocolAll_Protocol_Icmp = "icmp"
	NetworkACLRuleProtocolAll_Protocol_Tcp  = "tcp"
	NetworkACLRuleProtocolAll_Protocol_Udp  = "udp"
)

func (*NetworkACLRuleProtocolAll) isaNetworkACLRule() bool {
	return true
}

// UnmarshalNetworkACLRuleProtocolAll constructs an instance of NetworkACLRuleProtocolAll from the specified map.
func UnmarshalNetworkACLRuleProtocolAll(m map[string]interface{}) (result *NetworkACLRuleProtocolAll, err error) {
	obj := new(NetworkACLRuleProtocolAll)
	obj.Action, err = core.UnmarshalString(m, "action")
	if err != nil {
		return
	}
	obj.Before, err = UnmarshalNetworkACLRuleReferenceAsProperty(m, "before")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Destination, err = core.UnmarshalString(m, "destination")
	if err != nil {
		return
	}
	obj.Direction, err = core.UnmarshalString(m, "direction")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.Source, err = core.UnmarshalString(m, "source")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRuleProtocolAllSlice unmarshals a slice of NetworkACLRuleProtocolAll instances from the specified list of maps.
func UnmarshalNetworkACLRuleProtocolAllSlice(s []interface{}) (slice []NetworkACLRuleProtocolAll, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRuleProtocolAll'")
			return
		}
		obj, e := UnmarshalNetworkACLRuleProtocolAll(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRuleProtocolAllAsProperty unmarshals an instance of NetworkACLRuleProtocolAll that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleProtocolAllAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRuleProtocolAll, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRuleProtocolAll'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRuleProtocolAll(objMap)
	}
	return
}

// UnmarshalNetworkACLRuleProtocolAllSliceAsProperty unmarshals a slice of NetworkACLRuleProtocolAll instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleProtocolAllSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRuleProtocolAll, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRuleProtocolAll'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRuleProtocolAllSlice(vSlice)
	}
	return
}

// NetworkACLRuleProtocolICMP : NetworkACLRuleProtocolICMP struct
// This model "extends" NetworkACLRule
type NetworkACLRuleProtocolICMP struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IpVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The ICMP traffic code to allow. If unspecified, all codes are allowed. This can only be specified if type is also
	// specified.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow. If unspecified, all types are allowed by this rule.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRuleProtocolICMP.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRuleProtocolICMP_Action_Allow = "allow"
	NetworkACLRuleProtocolICMP_Action_Deny  = "deny"
)

// Constants associated with the NetworkACLRuleProtocolICMP.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRuleProtocolICMP_Direction_Inbound  = "inbound"
	NetworkACLRuleProtocolICMP_Direction_Outbound = "outbound"
)

// Constants associated with the NetworkACLRuleProtocolICMP.IpVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleProtocolICMP_IpVersion_Ipv4 = "ipv4"
	NetworkACLRuleProtocolICMP_IpVersion_Ipv6 = "ipv6"
)

// Constants associated with the NetworkACLRuleProtocolICMP.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleProtocolICMP_Protocol_All  = "all"
	NetworkACLRuleProtocolICMP_Protocol_Icmp = "icmp"
	NetworkACLRuleProtocolICMP_Protocol_Tcp  = "tcp"
	NetworkACLRuleProtocolICMP_Protocol_Udp  = "udp"
)

func (*NetworkACLRuleProtocolICMP) isaNetworkACLRule() bool {
	return true
}

// UnmarshalNetworkACLRuleProtocolICMP constructs an instance of NetworkACLRuleProtocolICMP from the specified map.
func UnmarshalNetworkACLRuleProtocolICMP(m map[string]interface{}) (result *NetworkACLRuleProtocolICMP, err error) {
	obj := new(NetworkACLRuleProtocolICMP)
	obj.Action, err = core.UnmarshalString(m, "action")
	if err != nil {
		return
	}
	obj.Before, err = UnmarshalNetworkACLRuleReferenceAsProperty(m, "before")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Destination, err = core.UnmarshalString(m, "destination")
	if err != nil {
		return
	}
	obj.Direction, err = core.UnmarshalString(m, "direction")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.Source, err = core.UnmarshalString(m, "source")
	if err != nil {
		return
	}
	obj.Code, err = core.UnmarshalInt64(m, "code")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalInt64(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRuleProtocolICMPSlice unmarshals a slice of NetworkACLRuleProtocolICMP instances from the specified list of maps.
func UnmarshalNetworkACLRuleProtocolICMPSlice(s []interface{}) (slice []NetworkACLRuleProtocolICMP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRuleProtocolICMP'")
			return
		}
		obj, e := UnmarshalNetworkACLRuleProtocolICMP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRuleProtocolICMPAsProperty unmarshals an instance of NetworkACLRuleProtocolICMP that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleProtocolICMPAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRuleProtocolICMP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRuleProtocolICMP'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRuleProtocolICMP(objMap)
	}
	return
}

// UnmarshalNetworkACLRuleProtocolICMPSliceAsProperty unmarshals a slice of NetworkACLRuleProtocolICMP instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleProtocolICMPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRuleProtocolICMP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRuleProtocolICMP'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRuleProtocolICMPSlice(vSlice)
	}
	return
}

// NetworkACLRuleProtocolTCPUDP : NetworkACLRuleProtocolTCPUDP struct
// This model "extends" NetworkACLRule
type NetworkACLRuleProtocolTCPUDP struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IpVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`
}

// Constants associated with the NetworkACLRuleProtocolTCPUDP.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRuleProtocolTCPUDP_Action_Allow = "allow"
	NetworkACLRuleProtocolTCPUDP_Action_Deny  = "deny"
)

// Constants associated with the NetworkACLRuleProtocolTCPUDP.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRuleProtocolTCPUDP_Direction_Inbound  = "inbound"
	NetworkACLRuleProtocolTCPUDP_Direction_Outbound = "outbound"
)

// Constants associated with the NetworkACLRuleProtocolTCPUDP.IpVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleProtocolTCPUDP_IpVersion_Ipv4 = "ipv4"
	NetworkACLRuleProtocolTCPUDP_IpVersion_Ipv6 = "ipv6"
)

// Constants associated with the NetworkACLRuleProtocolTCPUDP.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleProtocolTCPUDP_Protocol_All  = "all"
	NetworkACLRuleProtocolTCPUDP_Protocol_Icmp = "icmp"
	NetworkACLRuleProtocolTCPUDP_Protocol_Tcp  = "tcp"
	NetworkACLRuleProtocolTCPUDP_Protocol_Udp  = "udp"
)

func (*NetworkACLRuleProtocolTCPUDP) isaNetworkACLRule() bool {
	return true
}

// UnmarshalNetworkACLRuleProtocolTCPUDP constructs an instance of NetworkACLRuleProtocolTCPUDP from the specified map.
func UnmarshalNetworkACLRuleProtocolTCPUDP(m map[string]interface{}) (result *NetworkACLRuleProtocolTCPUDP, err error) {
	obj := new(NetworkACLRuleProtocolTCPUDP)
	obj.Action, err = core.UnmarshalString(m, "action")
	if err != nil {
		return
	}
	obj.Before, err = UnmarshalNetworkACLRuleReferenceAsProperty(m, "before")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Destination, err = core.UnmarshalString(m, "destination")
	if err != nil {
		return
	}
	obj.Direction, err = core.UnmarshalString(m, "direction")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.Source, err = core.UnmarshalString(m, "source")
	if err != nil {
		return
	}
	obj.DestinationPortMax, err = core.UnmarshalInt64(m, "destination_port_max")
	if err != nil {
		return
	}
	obj.DestinationPortMin, err = core.UnmarshalInt64(m, "destination_port_min")
	if err != nil {
		return
	}
	obj.SourcePortMax, err = core.UnmarshalInt64(m, "source_port_max")
	if err != nil {
		return
	}
	obj.SourcePortMin, err = core.UnmarshalInt64(m, "source_port_min")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRuleProtocolTCPUDPSlice unmarshals a slice of NetworkACLRuleProtocolTCPUDP instances from the specified list of maps.
func UnmarshalNetworkACLRuleProtocolTCPUDPSlice(s []interface{}) (slice []NetworkACLRuleProtocolTCPUDP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRuleProtocolTCPUDP'")
			return
		}
		obj, e := UnmarshalNetworkACLRuleProtocolTCPUDP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRuleProtocolTCPUDPAsProperty unmarshals an instance of NetworkACLRuleProtocolTCPUDP that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleProtocolTCPUDPAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRuleProtocolTCPUDP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRuleProtocolTCPUDP'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRuleProtocolTCPUDP(objMap)
	}
	return
}

// UnmarshalNetworkACLRuleProtocolTCPUDPSliceAsProperty unmarshals a slice of NetworkACLRuleProtocolTCPUDP instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRuleProtocolTCPUDPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRuleProtocolTCPUDP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRuleProtocolTCPUDP'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRuleProtocolTCPUDPSlice(vSlice)
	}
	return
}

// NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref : NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref struct
// This model "extends" NetworkACLRulePrototypeBefore
type NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref struct {
	// The URL for this rule.
	Href *string `json:"href" validate:"required"`
}

// NewNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref : Instantiate NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref(href string) (model *NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref, err error) {
	model = &NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref) isaNetworkACLRulePrototypeBefore() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref constructs an instance of NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref from the specified map.
func UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref(m map[string]interface{}) (result *NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref, err error) {
	obj := new(NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHrefSlice unmarshals a slice of NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref instances from the specified list of maps.
func UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHrefSlice(s []interface{}) (slice []NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref'")
			return
		}
		obj, e := UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHrefAsProperty unmarshals an instance of NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref(objMap)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHrefSliceAsProperty unmarshals a slice of NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHrefSlice(vSlice)
	}
	return
}

// NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID : NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID struct
// This model "extends" NetworkACLRulePrototypeBefore
type NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID struct {
	// The unique identifier for this rule.
	ID *string `json:"id" validate:"required"`
}

// NewNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID : Instantiate NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID(id string) (model *NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID, err error) {
	model = &NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID) isaNetworkACLRulePrototypeBefore() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID constructs an instance of NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID from the specified map.
func UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID(m map[string]interface{}) (result *NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID, err error) {
	obj := new(NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByIDSlice unmarshals a slice of NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID instances from the specified list of maps.
func UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByIDSlice(s []interface{}) (slice []NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID'")
			return
		}
		obj, e := UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByIDAsProperty unmarshals an instance of NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID(objMap)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByIDSliceAsProperty unmarshals a slice of NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByIDSlice(vSlice)
	}
	return
}

// NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll : NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll struct
// This model "extends" NetworkACLRulePrototypeNetworkACLContext
type NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IpVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll_Action_Allow = "allow"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll_Action_Deny  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll_Direction_Inbound  = "inbound"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll_Direction_Outbound = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll.IpVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll_IpVersion_Ipv4 = "ipv4"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll_IpVersion_Ipv6 = "ipv6"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll_Protocol_All  = "all"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll_Protocol_Icmp = "icmp"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll_Protocol_Tcp  = "tcp"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll_Protocol_Udp  = "udp"
)

// NewNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll : Instantiate NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll(action string, createdAt *strfmt.DateTime, destination string, direction string, href string, id string, ipVersion string, name string, source string) (model *NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll, err error) {
	model = &NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll{
		Action:      core.StringPtr(action),
		CreatedAt:   createdAt,
		Destination: core.StringPtr(destination),
		Direction:   core.StringPtr(direction),
		Href:        core.StringPtr(href),
		ID:          core.StringPtr(id),
		IpVersion:   core.StringPtr(ipVersion),
		Name:        core.StringPtr(name),
		Source:      core.StringPtr(source),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll) isaNetworkACLRulePrototypeNetworkACLContext() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll constructs an instance of NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll from the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll(m map[string]interface{}) (result *NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll, err error) {
	obj := new(NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll)
	obj.Action, err = core.UnmarshalString(m, "action")
	if err != nil {
		return
	}
	obj.Before, err = UnmarshalNetworkACLRuleReferenceAsProperty(m, "before")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Destination, err = core.UnmarshalString(m, "destination")
	if err != nil {
		return
	}
	obj.Direction, err = core.UnmarshalString(m, "direction")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.Source, err = core.UnmarshalString(m, "source")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllSlice unmarshals a slice of NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll instances from the specified list of maps.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllSlice(s []interface{}) (slice []NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll'")
			return
		}
		obj, e := UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllAsProperty unmarshals an instance of NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll(objMap)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllSliceAsProperty unmarshals a slice of NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllSlice(vSlice)
	}
	return
}

// NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP : NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP struct
// This model "extends" NetworkACLRulePrototypeNetworkACLContext
type NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IpVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The ICMP traffic code to allow. If unspecified, all codes are allowed. This can only be specified if type is also
	// specified.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow. If unspecified, all types are allowed by this rule.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP_Action_Allow = "allow"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP_Action_Deny  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP_Direction_Inbound  = "inbound"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP_Direction_Outbound = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP.IpVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP_IpVersion_Ipv4 = "ipv4"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP_IpVersion_Ipv6 = "ipv6"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP_Protocol_All  = "all"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP_Protocol_Icmp = "icmp"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP_Protocol_Tcp  = "tcp"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP_Protocol_Udp  = "udp"
)

// NewNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP : Instantiate NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP(action string, createdAt *strfmt.DateTime, destination string, direction string, href string, id string, ipVersion string, name string, source string) (model *NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP, err error) {
	model = &NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP{
		Action:      core.StringPtr(action),
		CreatedAt:   createdAt,
		Destination: core.StringPtr(destination),
		Direction:   core.StringPtr(direction),
		Href:        core.StringPtr(href),
		ID:          core.StringPtr(id),
		IpVersion:   core.StringPtr(ipVersion),
		Name:        core.StringPtr(name),
		Source:      core.StringPtr(source),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP) isaNetworkACLRulePrototypeNetworkACLContext() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP constructs an instance of NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP from the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP(m map[string]interface{}) (result *NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP, err error) {
	obj := new(NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP)
	obj.Action, err = core.UnmarshalString(m, "action")
	if err != nil {
		return
	}
	obj.Before, err = UnmarshalNetworkACLRuleReferenceAsProperty(m, "before")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Destination, err = core.UnmarshalString(m, "destination")
	if err != nil {
		return
	}
	obj.Direction, err = core.UnmarshalString(m, "direction")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.Source, err = core.UnmarshalString(m, "source")
	if err != nil {
		return
	}
	obj.Code, err = core.UnmarshalInt64(m, "code")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalInt64(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMPSlice unmarshals a slice of NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP instances from the specified list of maps.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMPSlice(s []interface{}) (slice []NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP'")
			return
		}
		obj, e := UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMPAsProperty unmarshals an instance of NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMPAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP(objMap)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMPSliceAsProperty unmarshals a slice of NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMP'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMPSlice(vSlice)
	}
	return
}

// NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP : NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP struct
// This model "extends" NetworkACLRulePrototypeNetworkACLContext
type NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IpVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP_Action_Allow = "allow"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP_Action_Deny  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP_Direction_Inbound  = "inbound"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP_Direction_Outbound = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP.IpVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP_IpVersion_Ipv4 = "ipv4"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP_IpVersion_Ipv6 = "ipv6"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP_Protocol_All  = "all"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP_Protocol_Icmp = "icmp"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP_Protocol_Tcp  = "tcp"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP_Protocol_Udp  = "udp"
)

// NewNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP : Instantiate NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP(action string, createdAt *strfmt.DateTime, destination string, direction string, href string, id string, ipVersion string, name string, source string) (model *NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP, err error) {
	model = &NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP{
		Action:      core.StringPtr(action),
		CreatedAt:   createdAt,
		Destination: core.StringPtr(destination),
		Direction:   core.StringPtr(direction),
		Href:        core.StringPtr(href),
		ID:          core.StringPtr(id),
		IpVersion:   core.StringPtr(ipVersion),
		Name:        core.StringPtr(name),
		Source:      core.StringPtr(source),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP) isaNetworkACLRulePrototypeNetworkACLContext() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP constructs an instance of NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP from the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP(m map[string]interface{}) (result *NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP, err error) {
	obj := new(NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP)
	obj.Action, err = core.UnmarshalString(m, "action")
	if err != nil {
		return
	}
	obj.Before, err = UnmarshalNetworkACLRuleReferenceAsProperty(m, "before")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Destination, err = core.UnmarshalString(m, "destination")
	if err != nil {
		return
	}
	obj.Direction, err = core.UnmarshalString(m, "direction")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.Source, err = core.UnmarshalString(m, "source")
	if err != nil {
		return
	}
	obj.DestinationPortMax, err = core.UnmarshalInt64(m, "destination_port_max")
	if err != nil {
		return
	}
	obj.DestinationPortMin, err = core.UnmarshalInt64(m, "destination_port_min")
	if err != nil {
		return
	}
	obj.SourcePortMax, err = core.UnmarshalInt64(m, "source_port_max")
	if err != nil {
		return
	}
	obj.SourcePortMin, err = core.UnmarshalInt64(m, "source_port_min")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDPSlice unmarshals a slice of NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP instances from the specified list of maps.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDPSlice(s []interface{}) (slice []NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP'")
			return
		}
		obj, e := UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDPAsProperty unmarshals an instance of NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDPAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP(objMap)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDPSliceAsProperty unmarshals a slice of NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDP'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDPSlice(vSlice)
	}
	return
}

// NetworkACLRulePrototypeNetworkACLRuleProtocolAll : NetworkACLRulePrototypeNetworkACLRuleProtocolAll struct
// This model "extends" NetworkACLRulePrototype
type NetworkACLRulePrototypeNetworkACLRuleProtocolAll struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IpVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolAll.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolAll_Action_Allow = "allow"
	NetworkACLRulePrototypeNetworkACLRuleProtocolAll_Action_Deny  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolAll.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolAll_Direction_Inbound  = "inbound"
	NetworkACLRulePrototypeNetworkACLRuleProtocolAll_Direction_Outbound = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolAll.IpVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolAll_IpVersion_Ipv4 = "ipv4"
	NetworkACLRulePrototypeNetworkACLRuleProtocolAll_IpVersion_Ipv6 = "ipv6"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolAll.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolAll_Protocol_All  = "all"
	NetworkACLRulePrototypeNetworkACLRuleProtocolAll_Protocol_Icmp = "icmp"
	NetworkACLRulePrototypeNetworkACLRuleProtocolAll_Protocol_Tcp  = "tcp"
	NetworkACLRulePrototypeNetworkACLRuleProtocolAll_Protocol_Udp  = "udp"
)

// NewNetworkACLRulePrototypeNetworkACLRuleProtocolAll : Instantiate NetworkACLRulePrototypeNetworkACLRuleProtocolAll (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeNetworkACLRuleProtocolAll(action string, createdAt *strfmt.DateTime, destination string, direction string, href string, id string, ipVersion string, name string, source string) (model *NetworkACLRulePrototypeNetworkACLRuleProtocolAll, err error) {
	model = &NetworkACLRulePrototypeNetworkACLRuleProtocolAll{
		Action:      core.StringPtr(action),
		CreatedAt:   createdAt,
		Destination: core.StringPtr(destination),
		Direction:   core.StringPtr(direction),
		Href:        core.StringPtr(href),
		ID:          core.StringPtr(id),
		IpVersion:   core.StringPtr(ipVersion),
		Name:        core.StringPtr(name),
		Source:      core.StringPtr(source),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeNetworkACLRuleProtocolAll) isaNetworkACLRulePrototype() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolAll constructs an instance of NetworkACLRulePrototypeNetworkACLRuleProtocolAll from the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolAll(m map[string]interface{}) (result *NetworkACLRulePrototypeNetworkACLRuleProtocolAll, err error) {
	obj := new(NetworkACLRulePrototypeNetworkACLRuleProtocolAll)
	obj.Action, err = core.UnmarshalString(m, "action")
	if err != nil {
		return
	}
	obj.Before, err = UnmarshalNetworkACLRuleReferenceAsProperty(m, "before")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Destination, err = core.UnmarshalString(m, "destination")
	if err != nil {
		return
	}
	obj.Direction, err = core.UnmarshalString(m, "direction")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.Source, err = core.UnmarshalString(m, "source")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolAllSlice unmarshals a slice of NetworkACLRulePrototypeNetworkACLRuleProtocolAll instances from the specified list of maps.
func UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolAllSlice(s []interface{}) (slice []NetworkACLRulePrototypeNetworkACLRuleProtocolAll, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRulePrototypeNetworkACLRuleProtocolAll'")
			return
		}
		obj, e := UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolAll(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolAllAsProperty unmarshals an instance of NetworkACLRulePrototypeNetworkACLRuleProtocolAll that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolAllAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRulePrototypeNetworkACLRuleProtocolAll, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRulePrototypeNetworkACLRuleProtocolAll'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolAll(objMap)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolAllSliceAsProperty unmarshals a slice of NetworkACLRulePrototypeNetworkACLRuleProtocolAll instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolAllSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRulePrototypeNetworkACLRuleProtocolAll, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRulePrototypeNetworkACLRuleProtocolAll'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolAllSlice(vSlice)
	}
	return
}

// NetworkACLRulePrototypeNetworkACLRuleProtocolICMP : NetworkACLRulePrototypeNetworkACLRuleProtocolICMP struct
// This model "extends" NetworkACLRulePrototype
type NetworkACLRulePrototypeNetworkACLRuleProtocolICMP struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IpVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The ICMP traffic code to allow. If unspecified, all codes are allowed. This can only be specified if type is also
	// specified.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow. If unspecified, all types are allowed by this rule.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolICMP.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolICMP_Action_Allow = "allow"
	NetworkACLRulePrototypeNetworkACLRuleProtocolICMP_Action_Deny  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolICMP.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolICMP_Direction_Inbound  = "inbound"
	NetworkACLRulePrototypeNetworkACLRuleProtocolICMP_Direction_Outbound = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolICMP.IpVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolICMP_IpVersion_Ipv4 = "ipv4"
	NetworkACLRulePrototypeNetworkACLRuleProtocolICMP_IpVersion_Ipv6 = "ipv6"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolICMP.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolICMP_Protocol_All  = "all"
	NetworkACLRulePrototypeNetworkACLRuleProtocolICMP_Protocol_Icmp = "icmp"
	NetworkACLRulePrototypeNetworkACLRuleProtocolICMP_Protocol_Tcp  = "tcp"
	NetworkACLRulePrototypeNetworkACLRuleProtocolICMP_Protocol_Udp  = "udp"
)

// NewNetworkACLRulePrototypeNetworkACLRuleProtocolICMP : Instantiate NetworkACLRulePrototypeNetworkACLRuleProtocolICMP (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeNetworkACLRuleProtocolICMP(action string, createdAt *strfmt.DateTime, destination string, direction string, href string, id string, ipVersion string, name string, source string) (model *NetworkACLRulePrototypeNetworkACLRuleProtocolICMP, err error) {
	model = &NetworkACLRulePrototypeNetworkACLRuleProtocolICMP{
		Action:      core.StringPtr(action),
		CreatedAt:   createdAt,
		Destination: core.StringPtr(destination),
		Direction:   core.StringPtr(direction),
		Href:        core.StringPtr(href),
		ID:          core.StringPtr(id),
		IpVersion:   core.StringPtr(ipVersion),
		Name:        core.StringPtr(name),
		Source:      core.StringPtr(source),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeNetworkACLRuleProtocolICMP) isaNetworkACLRulePrototype() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolICMP constructs an instance of NetworkACLRulePrototypeNetworkACLRuleProtocolICMP from the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolICMP(m map[string]interface{}) (result *NetworkACLRulePrototypeNetworkACLRuleProtocolICMP, err error) {
	obj := new(NetworkACLRulePrototypeNetworkACLRuleProtocolICMP)
	obj.Action, err = core.UnmarshalString(m, "action")
	if err != nil {
		return
	}
	obj.Before, err = UnmarshalNetworkACLRuleReferenceAsProperty(m, "before")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Destination, err = core.UnmarshalString(m, "destination")
	if err != nil {
		return
	}
	obj.Direction, err = core.UnmarshalString(m, "direction")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.Source, err = core.UnmarshalString(m, "source")
	if err != nil {
		return
	}
	obj.Code, err = core.UnmarshalInt64(m, "code")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalInt64(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolICMPSlice unmarshals a slice of NetworkACLRulePrototypeNetworkACLRuleProtocolICMP instances from the specified list of maps.
func UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolICMPSlice(s []interface{}) (slice []NetworkACLRulePrototypeNetworkACLRuleProtocolICMP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRulePrototypeNetworkACLRuleProtocolICMP'")
			return
		}
		obj, e := UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolICMP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolICMPAsProperty unmarshals an instance of NetworkACLRulePrototypeNetworkACLRuleProtocolICMP that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolICMPAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRulePrototypeNetworkACLRuleProtocolICMP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRulePrototypeNetworkACLRuleProtocolICMP'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolICMP(objMap)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolICMPSliceAsProperty unmarshals a slice of NetworkACLRulePrototypeNetworkACLRuleProtocolICMP instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolICMPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRulePrototypeNetworkACLRuleProtocolICMP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRulePrototypeNetworkACLRuleProtocolICMP'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolICMPSlice(vSlice)
	}
	return
}

// NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP : NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP struct
// This model "extends" NetworkACLRulePrototype
type NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IpVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP_Action_Allow = "allow"
	NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP_Action_Deny  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP_Direction_Inbound  = "inbound"
	NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP_Direction_Outbound = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP.IpVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP_IpVersion_Ipv4 = "ipv4"
	NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP_IpVersion_Ipv6 = "ipv6"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP_Protocol_All  = "all"
	NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP_Protocol_Icmp = "icmp"
	NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP_Protocol_Tcp  = "tcp"
	NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP_Protocol_Udp  = "udp"
)

// NewNetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP : Instantiate NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP(action string, createdAt *strfmt.DateTime, destination string, direction string, href string, id string, ipVersion string, name string, source string) (model *NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP, err error) {
	model = &NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP{
		Action:      core.StringPtr(action),
		CreatedAt:   createdAt,
		Destination: core.StringPtr(destination),
		Direction:   core.StringPtr(direction),
		Href:        core.StringPtr(href),
		ID:          core.StringPtr(id),
		IpVersion:   core.StringPtr(ipVersion),
		Name:        core.StringPtr(name),
		Source:      core.StringPtr(source),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP) isaNetworkACLRulePrototype() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP constructs an instance of NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP from the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP(m map[string]interface{}) (result *NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP, err error) {
	obj := new(NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP)
	obj.Action, err = core.UnmarshalString(m, "action")
	if err != nil {
		return
	}
	obj.Before, err = UnmarshalNetworkACLRuleReferenceAsProperty(m, "before")
	if err != nil {
		return
	}
	obj.CreatedAt, err = core.UnmarshalDateTime(m, "created_at")
	if err != nil {
		return
	}
	obj.Destination, err = core.UnmarshalString(m, "destination")
	if err != nil {
		return
	}
	obj.Direction, err = core.UnmarshalString(m, "direction")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.Source, err = core.UnmarshalString(m, "source")
	if err != nil {
		return
	}
	obj.DestinationPortMax, err = core.UnmarshalInt64(m, "destination_port_max")
	if err != nil {
		return
	}
	obj.DestinationPortMin, err = core.UnmarshalInt64(m, "destination_port_min")
	if err != nil {
		return
	}
	obj.SourcePortMax, err = core.UnmarshalInt64(m, "source_port_max")
	if err != nil {
		return
	}
	obj.SourcePortMin, err = core.UnmarshalInt64(m, "source_port_min")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDPSlice unmarshals a slice of NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP instances from the specified list of maps.
func UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDPSlice(s []interface{}) (slice []NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP'")
			return
		}
		obj, e := UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDPAsProperty unmarshals an instance of NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP that is stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDPAsProperty(m map[string]interface{}, propertyName string) (result *NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP'", propertyName)
			return
		}
		result, err = UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP(objMap)
	}
	return
}

// UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDPSliceAsProperty unmarshals a slice of NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP instances that are stored as a property
// within the specified map.
func UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDP'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDPSlice(vSlice)
	}
	return
}

// NetworkInterfaceIdentityByHref : NetworkInterfaceIdentityByHref struct
// This model "extends" NetworkInterfaceIdentity
type NetworkInterfaceIdentityByHref struct {
	// The URL for this network interface.
	Href *string `json:"href" validate:"required"`
}

// NewNetworkInterfaceIdentityByHref : Instantiate NetworkInterfaceIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewNetworkInterfaceIdentityByHref(href string) (model *NetworkInterfaceIdentityByHref, err error) {
	model = &NetworkInterfaceIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkInterfaceIdentityByHref) isaNetworkInterfaceIdentity() bool {
	return true
}

// UnmarshalNetworkInterfaceIdentityByHref constructs an instance of NetworkInterfaceIdentityByHref from the specified map.
func UnmarshalNetworkInterfaceIdentityByHref(m map[string]interface{}) (result *NetworkInterfaceIdentityByHref, err error) {
	obj := new(NetworkInterfaceIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkInterfaceIdentityByHrefSlice unmarshals a slice of NetworkInterfaceIdentityByHref instances from the specified list of maps.
func UnmarshalNetworkInterfaceIdentityByHrefSlice(s []interface{}) (slice []NetworkInterfaceIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkInterfaceIdentityByHref'")
			return
		}
		obj, e := UnmarshalNetworkInterfaceIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkInterfaceIdentityByHrefAsProperty unmarshals an instance of NetworkInterfaceIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalNetworkInterfaceIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *NetworkInterfaceIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkInterfaceIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalNetworkInterfaceIdentityByHref(objMap)
	}
	return
}

// UnmarshalNetworkInterfaceIdentityByHrefSliceAsProperty unmarshals a slice of NetworkInterfaceIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalNetworkInterfaceIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkInterfaceIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkInterfaceIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkInterfaceIdentityByHrefSlice(vSlice)
	}
	return
}

// NetworkInterfaceIdentityByID : NetworkInterfaceIdentityByID struct
// This model "extends" NetworkInterfaceIdentity
type NetworkInterfaceIdentityByID struct {
	// The unique identifier for this network interface.
	ID *string `json:"id" validate:"required"`
}

// NewNetworkInterfaceIdentityByID : Instantiate NetworkInterfaceIdentityByID (Generic Model Constructor)
func (*VpcV1) NewNetworkInterfaceIdentityByID(id string) (model *NetworkInterfaceIdentityByID, err error) {
	model = &NetworkInterfaceIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkInterfaceIdentityByID) isaNetworkInterfaceIdentity() bool {
	return true
}

// UnmarshalNetworkInterfaceIdentityByID constructs an instance of NetworkInterfaceIdentityByID from the specified map.
func UnmarshalNetworkInterfaceIdentityByID(m map[string]interface{}) (result *NetworkInterfaceIdentityByID, err error) {
	obj := new(NetworkInterfaceIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalNetworkInterfaceIdentityByIDSlice unmarshals a slice of NetworkInterfaceIdentityByID instances from the specified list of maps.
func UnmarshalNetworkInterfaceIdentityByIDSlice(s []interface{}) (slice []NetworkInterfaceIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'NetworkInterfaceIdentityByID'")
			return
		}
		obj, e := UnmarshalNetworkInterfaceIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalNetworkInterfaceIdentityByIDAsProperty unmarshals an instance of NetworkInterfaceIdentityByID that is stored as a property
// within the specified map.
func UnmarshalNetworkInterfaceIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *NetworkInterfaceIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'NetworkInterfaceIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalNetworkInterfaceIdentityByID(objMap)
	}
	return
}

// UnmarshalNetworkInterfaceIdentityByIDSliceAsProperty unmarshals a slice of NetworkInterfaceIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalNetworkInterfaceIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []NetworkInterfaceIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'NetworkInterfaceIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalNetworkInterfaceIdentityByIDSlice(vSlice)
	}
	return
}

// OperatingSystemIdentityByHref : OperatingSystemIdentityByHref struct
// This model "extends" OperatingSystemIdentity
type OperatingSystemIdentityByHref struct {
	// The URL for this operating system.
	Href *string `json:"href" validate:"required"`
}

// NewOperatingSystemIdentityByHref : Instantiate OperatingSystemIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewOperatingSystemIdentityByHref(href string) (model *OperatingSystemIdentityByHref, err error) {
	model = &OperatingSystemIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*OperatingSystemIdentityByHref) isaOperatingSystemIdentity() bool {
	return true
}

// UnmarshalOperatingSystemIdentityByHref constructs an instance of OperatingSystemIdentityByHref from the specified map.
func UnmarshalOperatingSystemIdentityByHref(m map[string]interface{}) (result *OperatingSystemIdentityByHref, err error) {
	obj := new(OperatingSystemIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalOperatingSystemIdentityByHrefSlice unmarshals a slice of OperatingSystemIdentityByHref instances from the specified list of maps.
func UnmarshalOperatingSystemIdentityByHrefSlice(s []interface{}) (slice []OperatingSystemIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'OperatingSystemIdentityByHref'")
			return
		}
		obj, e := UnmarshalOperatingSystemIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalOperatingSystemIdentityByHrefAsProperty unmarshals an instance of OperatingSystemIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalOperatingSystemIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *OperatingSystemIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'OperatingSystemIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalOperatingSystemIdentityByHref(objMap)
	}
	return
}

// UnmarshalOperatingSystemIdentityByHrefSliceAsProperty unmarshals a slice of OperatingSystemIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalOperatingSystemIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []OperatingSystemIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'OperatingSystemIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalOperatingSystemIdentityByHrefSlice(vSlice)
	}
	return
}

// OperatingSystemIdentityByName : OperatingSystemIdentityByName struct
// This model "extends" OperatingSystemIdentity
type OperatingSystemIdentityByName struct {
	// The unique name of the operating system.
	Name *string `json:"name" validate:"required"`
}

// NewOperatingSystemIdentityByName : Instantiate OperatingSystemIdentityByName (Generic Model Constructor)
func (*VpcV1) NewOperatingSystemIdentityByName(name string) (model *OperatingSystemIdentityByName, err error) {
	model = &OperatingSystemIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*OperatingSystemIdentityByName) isaOperatingSystemIdentity() bool {
	return true
}

// UnmarshalOperatingSystemIdentityByName constructs an instance of OperatingSystemIdentityByName from the specified map.
func UnmarshalOperatingSystemIdentityByName(m map[string]interface{}) (result *OperatingSystemIdentityByName, err error) {
	obj := new(OperatingSystemIdentityByName)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalOperatingSystemIdentityByNameSlice unmarshals a slice of OperatingSystemIdentityByName instances from the specified list of maps.
func UnmarshalOperatingSystemIdentityByNameSlice(s []interface{}) (slice []OperatingSystemIdentityByName, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'OperatingSystemIdentityByName'")
			return
		}
		obj, e := UnmarshalOperatingSystemIdentityByName(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalOperatingSystemIdentityByNameAsProperty unmarshals an instance of OperatingSystemIdentityByName that is stored as a property
// within the specified map.
func UnmarshalOperatingSystemIdentityByNameAsProperty(m map[string]interface{}, propertyName string) (result *OperatingSystemIdentityByName, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'OperatingSystemIdentityByName'", propertyName)
			return
		}
		result, err = UnmarshalOperatingSystemIdentityByName(objMap)
	}
	return
}

// UnmarshalOperatingSystemIdentityByNameSliceAsProperty unmarshals a slice of OperatingSystemIdentityByName instances that are stored as a property
// within the specified map.
func UnmarshalOperatingSystemIdentityByNameSliceAsProperty(m map[string]interface{}, propertyName string) (slice []OperatingSystemIdentityByName, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'OperatingSystemIdentityByName'", propertyName)
			return
		}
		slice, err = UnmarshalOperatingSystemIdentityByNameSlice(vSlice)
	}
	return
}

// PublicGatewayIdentityByCRN : PublicGatewayIdentityByCRN struct
// This model "extends" PublicGatewayIdentity
type PublicGatewayIdentityByCRN struct {
	// The CRN for this public gateway.
	Crn *string `json:"crn" validate:"required"`
}

// NewPublicGatewayIdentityByCRN : Instantiate PublicGatewayIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayIdentityByCRN(crn string) (model *PublicGatewayIdentityByCRN, err error) {
	model = &PublicGatewayIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*PublicGatewayIdentityByCRN) isaPublicGatewayIdentity() bool {
	return true
}

// UnmarshalPublicGatewayIdentityByCRN constructs an instance of PublicGatewayIdentityByCRN from the specified map.
func UnmarshalPublicGatewayIdentityByCRN(m map[string]interface{}) (result *PublicGatewayIdentityByCRN, err error) {
	obj := new(PublicGatewayIdentityByCRN)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPublicGatewayIdentityByCRNSlice unmarshals a slice of PublicGatewayIdentityByCRN instances from the specified list of maps.
func UnmarshalPublicGatewayIdentityByCRNSlice(s []interface{}) (slice []PublicGatewayIdentityByCRN, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PublicGatewayIdentityByCRN'")
			return
		}
		obj, e := UnmarshalPublicGatewayIdentityByCRN(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalPublicGatewayIdentityByCRNAsProperty unmarshals an instance of PublicGatewayIdentityByCRN that is stored as a property
// within the specified map.
func UnmarshalPublicGatewayIdentityByCRNAsProperty(m map[string]interface{}, propertyName string) (result *PublicGatewayIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PublicGatewayIdentityByCRN'", propertyName)
			return
		}
		result, err = UnmarshalPublicGatewayIdentityByCRN(objMap)
	}
	return
}

// UnmarshalPublicGatewayIdentityByCRNSliceAsProperty unmarshals a slice of PublicGatewayIdentityByCRN instances that are stored as a property
// within the specified map.
func UnmarshalPublicGatewayIdentityByCRNSliceAsProperty(m map[string]interface{}, propertyName string) (slice []PublicGatewayIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PublicGatewayIdentityByCRN'", propertyName)
			return
		}
		slice, err = UnmarshalPublicGatewayIdentityByCRNSlice(vSlice)
	}
	return
}

// PublicGatewayIdentityByHref : PublicGatewayIdentityByHref struct
// This model "extends" PublicGatewayIdentity
type PublicGatewayIdentityByHref struct {
	// The URL for this gateway.
	Href *string `json:"href" validate:"required"`
}

// NewPublicGatewayIdentityByHref : Instantiate PublicGatewayIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayIdentityByHref(href string) (model *PublicGatewayIdentityByHref, err error) {
	model = &PublicGatewayIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*PublicGatewayIdentityByHref) isaPublicGatewayIdentity() bool {
	return true
}

// UnmarshalPublicGatewayIdentityByHref constructs an instance of PublicGatewayIdentityByHref from the specified map.
func UnmarshalPublicGatewayIdentityByHref(m map[string]interface{}) (result *PublicGatewayIdentityByHref, err error) {
	obj := new(PublicGatewayIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPublicGatewayIdentityByHrefSlice unmarshals a slice of PublicGatewayIdentityByHref instances from the specified list of maps.
func UnmarshalPublicGatewayIdentityByHrefSlice(s []interface{}) (slice []PublicGatewayIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PublicGatewayIdentityByHref'")
			return
		}
		obj, e := UnmarshalPublicGatewayIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalPublicGatewayIdentityByHrefAsProperty unmarshals an instance of PublicGatewayIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalPublicGatewayIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *PublicGatewayIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PublicGatewayIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalPublicGatewayIdentityByHref(objMap)
	}
	return
}

// UnmarshalPublicGatewayIdentityByHrefSliceAsProperty unmarshals a slice of PublicGatewayIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalPublicGatewayIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []PublicGatewayIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PublicGatewayIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalPublicGatewayIdentityByHrefSlice(vSlice)
	}
	return
}

// PublicGatewayIdentityByID : PublicGatewayIdentityByID struct
// This model "extends" PublicGatewayIdentity
type PublicGatewayIdentityByID struct {
	// The unique identifier for this public gateway.
	ID *string `json:"id" validate:"required"`
}

// NewPublicGatewayIdentityByID : Instantiate PublicGatewayIdentityByID (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayIdentityByID(id string) (model *PublicGatewayIdentityByID, err error) {
	model = &PublicGatewayIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*PublicGatewayIdentityByID) isaPublicGatewayIdentity() bool {
	return true
}

// UnmarshalPublicGatewayIdentityByID constructs an instance of PublicGatewayIdentityByID from the specified map.
func UnmarshalPublicGatewayIdentityByID(m map[string]interface{}) (result *PublicGatewayIdentityByID, err error) {
	obj := new(PublicGatewayIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPublicGatewayIdentityByIDSlice unmarshals a slice of PublicGatewayIdentityByID instances from the specified list of maps.
func UnmarshalPublicGatewayIdentityByIDSlice(s []interface{}) (slice []PublicGatewayIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PublicGatewayIdentityByID'")
			return
		}
		obj, e := UnmarshalPublicGatewayIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalPublicGatewayIdentityByIDAsProperty unmarshals an instance of PublicGatewayIdentityByID that is stored as a property
// within the specified map.
func UnmarshalPublicGatewayIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *PublicGatewayIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PublicGatewayIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalPublicGatewayIdentityByID(objMap)
	}
	return
}

// UnmarshalPublicGatewayIdentityByIDSliceAsProperty unmarshals a slice of PublicGatewayIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalPublicGatewayIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []PublicGatewayIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PublicGatewayIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalPublicGatewayIdentityByIDSlice(vSlice)
	}
	return
}

// PublicGatewayPrototypeFloatingIpFloatingIPIdentity : Identifies a floating IP by a unique property.
// Models which "extend" this model:
// - PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID
// - PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN
// - PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref
// - PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress
// This model "extends" PublicGatewayPrototypeFloatingIp
type PublicGatewayPrototypeFloatingIpFloatingIPIdentity struct {
	// The unique identifier for this floating IP.
	ID *string `json:"id,omitempty"`

	// The CRN for this floating IP.
	Crn *string `json:"crn,omitempty"`

	// The URL for this floating IPs.
	Href *string `json:"href,omitempty"`

	// The globally unique IP address.
	Address *string `json:"address,omitempty"`
}

func (*PublicGatewayPrototypeFloatingIpFloatingIPIdentity) isaPublicGatewayPrototypeFloatingIpFloatingIPIdentity() bool {
	return true
}

type PublicGatewayPrototypeFloatingIpFloatingIPIdentityIntf interface {
	PublicGatewayPrototypeFloatingIpIntf
	isaPublicGatewayPrototypeFloatingIpFloatingIPIdentity() bool
}

func (*PublicGatewayPrototypeFloatingIpFloatingIPIdentity) isaPublicGatewayPrototypeFloatingIp() bool {
	return true
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentity constructs an instance of PublicGatewayPrototypeFloatingIpFloatingIPIdentity from the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentity(m map[string]interface{}) (result PublicGatewayPrototypeFloatingIpFloatingIPIdentityIntf, err error) {
	obj := new(PublicGatewayPrototypeFloatingIpFloatingIPIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentitySlice unmarshals a slice of PublicGatewayPrototypeFloatingIpFloatingIPIdentity instances from the specified list of maps.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentitySlice(s []interface{}) (slice []PublicGatewayPrototypeFloatingIpFloatingIPIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PublicGatewayPrototypeFloatingIpFloatingIPIdentity'")
			return
		}
		obj, e := UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityAsProperty unmarshals an instance of PublicGatewayPrototypeFloatingIpFloatingIPIdentity that is stored as a property
// within the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityAsProperty(m map[string]interface{}, propertyName string) (result PublicGatewayPrototypeFloatingIpFloatingIPIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PublicGatewayPrototypeFloatingIpFloatingIPIdentity'", propertyName)
			return
		}
		result, err = UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentity(objMap)
	}
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentitySliceAsProperty unmarshals a slice of PublicGatewayPrototypeFloatingIpFloatingIPIdentity instances that are stored as a property
// within the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []PublicGatewayPrototypeFloatingIpFloatingIPIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PublicGatewayPrototypeFloatingIpFloatingIPIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentitySlice(vSlice)
	}
	return
}

// PublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext : PublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext struct
// This model "extends" PublicGatewayPrototypeFloatingIp
type PublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext struct {
	// The unique user-defined name for this floating IP. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`
}

func (*PublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext) isaPublicGatewayPrototypeFloatingIp() bool {
	return true
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext constructs an instance of PublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext from the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext(m map[string]interface{}) (result *PublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext, err error) {
	obj := new(PublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupIdentityAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContextSlice unmarshals a slice of PublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext instances from the specified list of maps.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContextSlice(s []interface{}) (slice []PublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext'")
			return
		}
		obj, e := UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContextAsProperty unmarshals an instance of PublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext that is stored as a property
// within the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContextAsProperty(m map[string]interface{}, propertyName string) (result *PublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext'", propertyName)
			return
		}
		result, err = UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext(objMap)
	}
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContextSliceAsProperty unmarshals a slice of PublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext instances that are stored as a property
// within the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []PublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContext'", propertyName)
			return
		}
		slice, err = UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPPrototypeTargetContextSlice(vSlice)
	}
	return
}

// ResourceGroupIdentityByID : ResourceGroupIdentityByID struct
// This model "extends" ResourceGroupIdentity
type ResourceGroupIdentityByID struct {
	// The unique identifier for this resource group.
	ID *string `json:"id" validate:"required"`
}

// NewResourceGroupIdentityByID : Instantiate ResourceGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewResourceGroupIdentityByID(id string) (model *ResourceGroupIdentityByID, err error) {
	model = &ResourceGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*ResourceGroupIdentityByID) isaResourceGroupIdentity() bool {
	return true
}

// UnmarshalResourceGroupIdentityByID constructs an instance of ResourceGroupIdentityByID from the specified map.
func UnmarshalResourceGroupIdentityByID(m map[string]interface{}) (result *ResourceGroupIdentityByID, err error) {
	obj := new(ResourceGroupIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalResourceGroupIdentityByIDSlice unmarshals a slice of ResourceGroupIdentityByID instances from the specified list of maps.
func UnmarshalResourceGroupIdentityByIDSlice(s []interface{}) (slice []ResourceGroupIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ResourceGroupIdentityByID'")
			return
		}
		obj, e := UnmarshalResourceGroupIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalResourceGroupIdentityByIDAsProperty unmarshals an instance of ResourceGroupIdentityByID that is stored as a property
// within the specified map.
func UnmarshalResourceGroupIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *ResourceGroupIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ResourceGroupIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalResourceGroupIdentityByID(objMap)
	}
	return
}

// UnmarshalResourceGroupIdentityByIDSliceAsProperty unmarshals a slice of ResourceGroupIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalResourceGroupIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ResourceGroupIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ResourceGroupIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalResourceGroupIdentityByIDSlice(vSlice)
	}
	return
}

// RouteNextHopIP : RouteNextHopIP struct
// This model "extends" RouteNextHop
type RouteNextHopIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

func (*RouteNextHopIP) isaRouteNextHop() bool {
	return true
}

// UnmarshalRouteNextHopIP constructs an instance of RouteNextHopIP from the specified map.
func UnmarshalRouteNextHopIP(m map[string]interface{}) (result *RouteNextHopIP, err error) {
	obj := new(RouteNextHopIP)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalRouteNextHopIPSlice unmarshals a slice of RouteNextHopIP instances from the specified list of maps.
func UnmarshalRouteNextHopIPSlice(s []interface{}) (slice []RouteNextHopIP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'RouteNextHopIP'")
			return
		}
		obj, e := UnmarshalRouteNextHopIP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalRouteNextHopIPAsProperty unmarshals an instance of RouteNextHopIP that is stored as a property
// within the specified map.
func UnmarshalRouteNextHopIPAsProperty(m map[string]interface{}, propertyName string) (result *RouteNextHopIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'RouteNextHopIP'", propertyName)
			return
		}
		result, err = UnmarshalRouteNextHopIP(objMap)
	}
	return
}

// UnmarshalRouteNextHopIPSliceAsProperty unmarshals a slice of RouteNextHopIP instances that are stored as a property
// within the specified map.
func UnmarshalRouteNextHopIPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []RouteNextHopIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'RouteNextHopIP'", propertyName)
			return
		}
		slice, err = UnmarshalRouteNextHopIPSlice(vSlice)
	}
	return
}

// RouteNextHopPrototypeRouteNextHopIP : The IP address of the next hop to which to route packets. Must be an IP address within a subnet assigned to `zone`.
// Must be unique within the VPC the route resides in.
// This model "extends" RouteNextHopPrototype
type RouteNextHopPrototypeRouteNextHopIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewRouteNextHopPrototypeRouteNextHopIP : Instantiate RouteNextHopPrototypeRouteNextHopIP (Generic Model Constructor)
func (*VpcV1) NewRouteNextHopPrototypeRouteNextHopIP(address string) (model *RouteNextHopPrototypeRouteNextHopIP, err error) {
	model = &RouteNextHopPrototypeRouteNextHopIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*RouteNextHopPrototypeRouteNextHopIP) isaRouteNextHopPrototype() bool {
	return true
}

// UnmarshalRouteNextHopPrototypeRouteNextHopIP constructs an instance of RouteNextHopPrototypeRouteNextHopIP from the specified map.
func UnmarshalRouteNextHopPrototypeRouteNextHopIP(m map[string]interface{}) (result *RouteNextHopPrototypeRouteNextHopIP, err error) {
	obj := new(RouteNextHopPrototypeRouteNextHopIP)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalRouteNextHopPrototypeRouteNextHopIPSlice unmarshals a slice of RouteNextHopPrototypeRouteNextHopIP instances from the specified list of maps.
func UnmarshalRouteNextHopPrototypeRouteNextHopIPSlice(s []interface{}) (slice []RouteNextHopPrototypeRouteNextHopIP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'RouteNextHopPrototypeRouteNextHopIP'")
			return
		}
		obj, e := UnmarshalRouteNextHopPrototypeRouteNextHopIP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalRouteNextHopPrototypeRouteNextHopIPAsProperty unmarshals an instance of RouteNextHopPrototypeRouteNextHopIP that is stored as a property
// within the specified map.
func UnmarshalRouteNextHopPrototypeRouteNextHopIPAsProperty(m map[string]interface{}, propertyName string) (result *RouteNextHopPrototypeRouteNextHopIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'RouteNextHopPrototypeRouteNextHopIP'", propertyName)
			return
		}
		result, err = UnmarshalRouteNextHopPrototypeRouteNextHopIP(objMap)
	}
	return
}

// UnmarshalRouteNextHopPrototypeRouteNextHopIPSliceAsProperty unmarshals a slice of RouteNextHopPrototypeRouteNextHopIP instances that are stored as a property
// within the specified map.
func UnmarshalRouteNextHopPrototypeRouteNextHopIPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []RouteNextHopPrototypeRouteNextHopIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'RouteNextHopPrototypeRouteNextHopIP'", propertyName)
			return
		}
		slice, err = UnmarshalRouteNextHopPrototypeRouteNextHopIPSlice(vSlice)
	}
	return
}

// SecurityGroupIdentityByCRN : SecurityGroupIdentityByCRN struct
// This model "extends" SecurityGroupIdentity
type SecurityGroupIdentityByCRN struct {
	// The security group's CRN.
	Crn *string `json:"crn" validate:"required"`
}

// NewSecurityGroupIdentityByCRN : Instantiate SecurityGroupIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupIdentityByCRN(crn string) (model *SecurityGroupIdentityByCRN, err error) {
	model = &SecurityGroupIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupIdentityByCRN) isaSecurityGroupIdentity() bool {
	return true
}

// UnmarshalSecurityGroupIdentityByCRN constructs an instance of SecurityGroupIdentityByCRN from the specified map.
func UnmarshalSecurityGroupIdentityByCRN(m map[string]interface{}) (result *SecurityGroupIdentityByCRN, err error) {
	obj := new(SecurityGroupIdentityByCRN)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupIdentityByCRNSlice unmarshals a slice of SecurityGroupIdentityByCRN instances from the specified list of maps.
func UnmarshalSecurityGroupIdentityByCRNSlice(s []interface{}) (slice []SecurityGroupIdentityByCRN, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupIdentityByCRN'")
			return
		}
		obj, e := UnmarshalSecurityGroupIdentityByCRN(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupIdentityByCRNAsProperty unmarshals an instance of SecurityGroupIdentityByCRN that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupIdentityByCRNAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupIdentityByCRN'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupIdentityByCRN(objMap)
	}
	return
}

// UnmarshalSecurityGroupIdentityByCRNSliceAsProperty unmarshals a slice of SecurityGroupIdentityByCRN instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupIdentityByCRNSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupIdentityByCRN'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupIdentityByCRNSlice(vSlice)
	}
	return
}

// SecurityGroupIdentityByHref : SecurityGroupIdentityByHref struct
// This model "extends" SecurityGroupIdentity
type SecurityGroupIdentityByHref struct {
	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewSecurityGroupIdentityByHref : Instantiate SecurityGroupIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupIdentityByHref(href string) (model *SecurityGroupIdentityByHref, err error) {
	model = &SecurityGroupIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupIdentityByHref) isaSecurityGroupIdentity() bool {
	return true
}

// UnmarshalSecurityGroupIdentityByHref constructs an instance of SecurityGroupIdentityByHref from the specified map.
func UnmarshalSecurityGroupIdentityByHref(m map[string]interface{}) (result *SecurityGroupIdentityByHref, err error) {
	obj := new(SecurityGroupIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupIdentityByHrefSlice unmarshals a slice of SecurityGroupIdentityByHref instances from the specified list of maps.
func UnmarshalSecurityGroupIdentityByHrefSlice(s []interface{}) (slice []SecurityGroupIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupIdentityByHref'")
			return
		}
		obj, e := UnmarshalSecurityGroupIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupIdentityByHrefAsProperty unmarshals an instance of SecurityGroupIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupIdentityByHref(objMap)
	}
	return
}

// UnmarshalSecurityGroupIdentityByHrefSliceAsProperty unmarshals a slice of SecurityGroupIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupIdentityByHrefSlice(vSlice)
	}
	return
}

// SecurityGroupIdentityByID : SecurityGroupIdentityByID struct
// This model "extends" SecurityGroupIdentity
type SecurityGroupIdentityByID struct {
	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`
}

// NewSecurityGroupIdentityByID : Instantiate SecurityGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupIdentityByID(id string) (model *SecurityGroupIdentityByID, err error) {
	model = &SecurityGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupIdentityByID) isaSecurityGroupIdentity() bool {
	return true
}

// UnmarshalSecurityGroupIdentityByID constructs an instance of SecurityGroupIdentityByID from the specified map.
func UnmarshalSecurityGroupIdentityByID(m map[string]interface{}) (result *SecurityGroupIdentityByID, err error) {
	obj := new(SecurityGroupIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupIdentityByIDSlice unmarshals a slice of SecurityGroupIdentityByID instances from the specified list of maps.
func UnmarshalSecurityGroupIdentityByIDSlice(s []interface{}) (slice []SecurityGroupIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupIdentityByID'")
			return
		}
		obj, e := UnmarshalSecurityGroupIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupIdentityByIDAsProperty unmarshals an instance of SecurityGroupIdentityByID that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupIdentityByID(objMap)
	}
	return
}

// UnmarshalSecurityGroupIdentityByIDSliceAsProperty unmarshals a slice of SecurityGroupIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupIdentityByIDSlice(vSlice)
	}
	return
}

// SecurityGroupRulePatchRemoteCIDR : SecurityGroupRulePatchRemoteCIDR struct
// This model "extends" SecurityGroupRulePatchRemote
type SecurityGroupRulePatchRemoteCIDR struct {
	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CidrBlock *string `json:"cidr_block" validate:"required"`
}

// NewSecurityGroupRulePatchRemoteCIDR : Instantiate SecurityGroupRulePatchRemoteCIDR (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePatchRemoteCIDR(cidrBlock string) (model *SecurityGroupRulePatchRemoteCIDR, err error) {
	model = &SecurityGroupRulePatchRemoteCIDR{
		CidrBlock: core.StringPtr(cidrBlock),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePatchRemoteCIDR) isaSecurityGroupRulePatchRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePatchRemoteCIDR constructs an instance of SecurityGroupRulePatchRemoteCIDR from the specified map.
func UnmarshalSecurityGroupRulePatchRemoteCIDR(m map[string]interface{}) (result *SecurityGroupRulePatchRemoteCIDR, err error) {
	obj := new(SecurityGroupRulePatchRemoteCIDR)
	obj.CidrBlock, err = core.UnmarshalString(m, "cidr_block")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePatchRemoteCIDRSlice unmarshals a slice of SecurityGroupRulePatchRemoteCIDR instances from the specified list of maps.
func UnmarshalSecurityGroupRulePatchRemoteCIDRSlice(s []interface{}) (slice []SecurityGroupRulePatchRemoteCIDR, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePatchRemoteCIDR'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePatchRemoteCIDR(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePatchRemoteCIDRAsProperty unmarshals an instance of SecurityGroupRulePatchRemoteCIDR that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePatchRemoteCIDRAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePatchRemoteCIDR, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePatchRemoteCIDR'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePatchRemoteCIDR(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePatchRemoteCIDRSliceAsProperty unmarshals a slice of SecurityGroupRulePatchRemoteCIDR instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePatchRemoteCIDRSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePatchRemoteCIDR, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePatchRemoteCIDR'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePatchRemoteCIDRSlice(vSlice)
	}
	return
}

// SecurityGroupRulePatchRemoteIP : SecurityGroupRulePatchRemoteIP struct
// This model "extends" SecurityGroupRulePatchRemote
type SecurityGroupRulePatchRemoteIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewSecurityGroupRulePatchRemoteIP : Instantiate SecurityGroupRulePatchRemoteIP (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePatchRemoteIP(address string) (model *SecurityGroupRulePatchRemoteIP, err error) {
	model = &SecurityGroupRulePatchRemoteIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePatchRemoteIP) isaSecurityGroupRulePatchRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePatchRemoteIP constructs an instance of SecurityGroupRulePatchRemoteIP from the specified map.
func UnmarshalSecurityGroupRulePatchRemoteIP(m map[string]interface{}) (result *SecurityGroupRulePatchRemoteIP, err error) {
	obj := new(SecurityGroupRulePatchRemoteIP)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePatchRemoteIPSlice unmarshals a slice of SecurityGroupRulePatchRemoteIP instances from the specified list of maps.
func UnmarshalSecurityGroupRulePatchRemoteIPSlice(s []interface{}) (slice []SecurityGroupRulePatchRemoteIP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePatchRemoteIP'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePatchRemoteIP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePatchRemoteIPAsProperty unmarshals an instance of SecurityGroupRulePatchRemoteIP that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePatchRemoteIPAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePatchRemoteIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePatchRemoteIP'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePatchRemoteIP(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePatchRemoteIPSliceAsProperty unmarshals a slice of SecurityGroupRulePatchRemoteIP instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePatchRemoteIPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePatchRemoteIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePatchRemoteIP'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePatchRemoteIPSlice(vSlice)
	}
	return
}

// SecurityGroupRulePatchRemoteSecurityGroupIdentity : Identifies a security group by a unique property.
// Models which "extend" this model:
// - SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID
// - SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN
// - SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref
// This model "extends" SecurityGroupRulePatchRemote
type SecurityGroupRulePatchRemoteSecurityGroupIdentity struct {
	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	Crn *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupRulePatchRemoteSecurityGroupIdentity) isaSecurityGroupRulePatchRemoteSecurityGroupIdentity() bool {
	return true
}

type SecurityGroupRulePatchRemoteSecurityGroupIdentityIntf interface {
	SecurityGroupRulePatchRemoteIntf
	isaSecurityGroupRulePatchRemoteSecurityGroupIdentity() bool
}

func (*SecurityGroupRulePatchRemoteSecurityGroupIdentity) isaSecurityGroupRulePatchRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentity constructs an instance of SecurityGroupRulePatchRemoteSecurityGroupIdentity from the specified map.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentity(m map[string]interface{}) (result SecurityGroupRulePatchRemoteSecurityGroupIdentityIntf, err error) {
	obj := new(SecurityGroupRulePatchRemoteSecurityGroupIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySlice unmarshals a slice of SecurityGroupRulePatchRemoteSecurityGroupIdentity instances from the specified list of maps.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySlice(s []interface{}) (slice []SecurityGroupRulePatchRemoteSecurityGroupIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePatchRemoteSecurityGroupIdentity'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentityAsProperty unmarshals an instance of SecurityGroupRulePatchRemoteSecurityGroupIdentity that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentityAsProperty(m map[string]interface{}, propertyName string) (result SecurityGroupRulePatchRemoteSecurityGroupIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePatchRemoteSecurityGroupIdentity'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentity(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySliceAsProperty unmarshals a slice of SecurityGroupRulePatchRemoteSecurityGroupIdentity instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePatchRemoteSecurityGroupIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePatchRemoteSecurityGroupIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySlice(vSlice)
	}
	return
}

// SecurityGroupRuleProtocolAll : When `protocol` is `all`, then it's invalid to specify `port_min`, `port_max`, `type` or
// `code`.
// This model "extends" SecurityGroupRule
type SecurityGroupRuleProtocolAll struct {
	// The direction of traffic to enforce, either `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this security group rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group rule.
	ID *string `json:"id" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
	// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
	// interfaces) in that group matching this IP version.
	IpVersion *string `json:"ip_version,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The IP addresses or security groups from which this rule allows traffic (or to which, for outbound rules). Can be
	// specified as an IP address, a CIDR block, or a security group. A CIDR block of `0.0.0.0/0` allows traffic from any
	// source (or to any source, for outbound rules).
	Remote interface{} `json:"remote" validate:"required"`
}

// Constants associated with the SecurityGroupRuleProtocolAll.Direction property.
// The direction of traffic to enforce, either `inbound` or `outbound`.
const (
	SecurityGroupRuleProtocolAll_Direction_Inbound  = "inbound"
	SecurityGroupRuleProtocolAll_Direction_Outbound = "outbound"
)

// Constants associated with the SecurityGroupRuleProtocolAll.IpVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
// interfaces) in that group matching this IP version.
const (
	SecurityGroupRuleProtocolAll_IpVersion_Ipv4 = "ipv4"
)

// Constants associated with the SecurityGroupRuleProtocolAll.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRuleProtocolAll_Protocol_All  = "all"
	SecurityGroupRuleProtocolAll_Protocol_Icmp = "icmp"
	SecurityGroupRuleProtocolAll_Protocol_Tcp  = "tcp"
	SecurityGroupRuleProtocolAll_Protocol_Udp  = "udp"
)

func (*SecurityGroupRuleProtocolAll) isaSecurityGroupRule() bool {
	return true
}

// UnmarshalSecurityGroupRuleProtocolAll constructs an instance of SecurityGroupRuleProtocolAll from the specified map.
func UnmarshalSecurityGroupRuleProtocolAll(m map[string]interface{}) (result *SecurityGroupRuleProtocolAll, err error) {
	obj := new(SecurityGroupRuleProtocolAll)
	obj.Direction, err = core.UnmarshalString(m, "direction")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.Remote, err = core.UnmarshalAny(m, "remote")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRuleProtocolAllSlice unmarshals a slice of SecurityGroupRuleProtocolAll instances from the specified list of maps.
func UnmarshalSecurityGroupRuleProtocolAllSlice(s []interface{}) (slice []SecurityGroupRuleProtocolAll, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRuleProtocolAll'")
			return
		}
		obj, e := UnmarshalSecurityGroupRuleProtocolAll(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRuleProtocolAllAsProperty unmarshals an instance of SecurityGroupRuleProtocolAll that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRuleProtocolAllAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRuleProtocolAll, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRuleProtocolAll'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRuleProtocolAll(objMap)
	}
	return
}

// UnmarshalSecurityGroupRuleProtocolAllSliceAsProperty unmarshals a slice of SecurityGroupRuleProtocolAll instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRuleProtocolAllSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRuleProtocolAll, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRuleProtocolAll'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRuleProtocolAllSlice(vSlice)
	}
	return
}

// SecurityGroupRuleProtocolICMP : When `protocol` is `icmp`, then the rule may also contain fields to specify an ICMP `type` and `code`. Field `code`
// may only be specified if `type` is also specified. If type is not specified, then traffic is allowed for all types
// and codes. If type is specified and code is not specified, then traffic is allowed with the specified type for all
// codes.
// This model "extends" SecurityGroupRule
type SecurityGroupRuleProtocolICMP struct {
	// The direction of traffic to enforce, either `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this security group rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group rule.
	ID *string `json:"id" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
	// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
	// interfaces) in that group matching this IP version.
	IpVersion *string `json:"ip_version,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The IP addresses or security groups from which this rule allows traffic (or to which, for outbound rules). Can be
	// specified as an IP address, a CIDR block, or a security group. A CIDR block of `0.0.0.0/0` allows traffic from any
	// source (or to any source, for outbound rules).
	Remote interface{} `json:"remote" validate:"required"`

	// The ICMP traffic code to allow.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the SecurityGroupRuleProtocolICMP.Direction property.
// The direction of traffic to enforce, either `inbound` or `outbound`.
const (
	SecurityGroupRuleProtocolICMP_Direction_Inbound  = "inbound"
	SecurityGroupRuleProtocolICMP_Direction_Outbound = "outbound"
)

// Constants associated with the SecurityGroupRuleProtocolICMP.IpVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
// interfaces) in that group matching this IP version.
const (
	SecurityGroupRuleProtocolICMP_IpVersion_Ipv4 = "ipv4"
)

// Constants associated with the SecurityGroupRuleProtocolICMP.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRuleProtocolICMP_Protocol_All  = "all"
	SecurityGroupRuleProtocolICMP_Protocol_Icmp = "icmp"
	SecurityGroupRuleProtocolICMP_Protocol_Tcp  = "tcp"
	SecurityGroupRuleProtocolICMP_Protocol_Udp  = "udp"
)

func (*SecurityGroupRuleProtocolICMP) isaSecurityGroupRule() bool {
	return true
}

// UnmarshalSecurityGroupRuleProtocolICMP constructs an instance of SecurityGroupRuleProtocolICMP from the specified map.
func UnmarshalSecurityGroupRuleProtocolICMP(m map[string]interface{}) (result *SecurityGroupRuleProtocolICMP, err error) {
	obj := new(SecurityGroupRuleProtocolICMP)
	obj.Direction, err = core.UnmarshalString(m, "direction")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.Remote, err = core.UnmarshalAny(m, "remote")
	if err != nil {
		return
	}
	obj.Code, err = core.UnmarshalInt64(m, "code")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalInt64(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRuleProtocolICMPSlice unmarshals a slice of SecurityGroupRuleProtocolICMP instances from the specified list of maps.
func UnmarshalSecurityGroupRuleProtocolICMPSlice(s []interface{}) (slice []SecurityGroupRuleProtocolICMP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRuleProtocolICMP'")
			return
		}
		obj, e := UnmarshalSecurityGroupRuleProtocolICMP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRuleProtocolICMPAsProperty unmarshals an instance of SecurityGroupRuleProtocolICMP that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRuleProtocolICMPAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRuleProtocolICMP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRuleProtocolICMP'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRuleProtocolICMP(objMap)
	}
	return
}

// UnmarshalSecurityGroupRuleProtocolICMPSliceAsProperty unmarshals a slice of SecurityGroupRuleProtocolICMP instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRuleProtocolICMPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRuleProtocolICMP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRuleProtocolICMP'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRuleProtocolICMPSlice(vSlice)
	}
	return
}

// SecurityGroupRuleProtocolTCPUDP : If `protocol` is either `tcp` or `udp`, then the rule may also contain `port_min` and
// `port_max`. Either both should be set, or neither. When neither is set then traffic is allowed on all ports. For a
// single port, set both to the same value.
// This model "extends" SecurityGroupRule
type SecurityGroupRuleProtocolTCPUDP struct {
	// The direction of traffic to enforce, either `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this security group rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group rule.
	ID *string `json:"id" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
	// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
	// interfaces) in that group matching this IP version.
	IpVersion *string `json:"ip_version,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The IP addresses or security groups from which this rule allows traffic (or to which, for outbound rules). Can be
	// specified as an IP address, a CIDR block, or a security group. A CIDR block of `0.0.0.0/0` allows traffic from any
	// source (or to any source, for outbound rules).
	Remote interface{} `json:"remote" validate:"required"`

	// The inclusive upper bound of TCP/UDP port range.
	PortMax *int64 `json:"port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP port range.
	PortMin *int64 `json:"port_min,omitempty"`
}

// Constants associated with the SecurityGroupRuleProtocolTCPUDP.Direction property.
// The direction of traffic to enforce, either `inbound` or `outbound`.
const (
	SecurityGroupRuleProtocolTCPUDP_Direction_Inbound  = "inbound"
	SecurityGroupRuleProtocolTCPUDP_Direction_Outbound = "outbound"
)

// Constants associated with the SecurityGroupRuleProtocolTCPUDP.IpVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
// interfaces) in that group matching this IP version.
const (
	SecurityGroupRuleProtocolTCPUDP_IpVersion_Ipv4 = "ipv4"
)

// Constants associated with the SecurityGroupRuleProtocolTCPUDP.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRuleProtocolTCPUDP_Protocol_All  = "all"
	SecurityGroupRuleProtocolTCPUDP_Protocol_Icmp = "icmp"
	SecurityGroupRuleProtocolTCPUDP_Protocol_Tcp  = "tcp"
	SecurityGroupRuleProtocolTCPUDP_Protocol_Udp  = "udp"
)

func (*SecurityGroupRuleProtocolTCPUDP) isaSecurityGroupRule() bool {
	return true
}

// UnmarshalSecurityGroupRuleProtocolTCPUDP constructs an instance of SecurityGroupRuleProtocolTCPUDP from the specified map.
func UnmarshalSecurityGroupRuleProtocolTCPUDP(m map[string]interface{}) (result *SecurityGroupRuleProtocolTCPUDP, err error) {
	obj := new(SecurityGroupRuleProtocolTCPUDP)
	obj.Direction, err = core.UnmarshalString(m, "direction")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.Remote, err = core.UnmarshalAny(m, "remote")
	if err != nil {
		return
	}
	obj.PortMax, err = core.UnmarshalInt64(m, "port_max")
	if err != nil {
		return
	}
	obj.PortMin, err = core.UnmarshalInt64(m, "port_min")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRuleProtocolTCPUDPSlice unmarshals a slice of SecurityGroupRuleProtocolTCPUDP instances from the specified list of maps.
func UnmarshalSecurityGroupRuleProtocolTCPUDPSlice(s []interface{}) (slice []SecurityGroupRuleProtocolTCPUDP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRuleProtocolTCPUDP'")
			return
		}
		obj, e := UnmarshalSecurityGroupRuleProtocolTCPUDP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRuleProtocolTCPUDPAsProperty unmarshals an instance of SecurityGroupRuleProtocolTCPUDP that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRuleProtocolTCPUDPAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRuleProtocolTCPUDP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRuleProtocolTCPUDP'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRuleProtocolTCPUDP(objMap)
	}
	return
}

// UnmarshalSecurityGroupRuleProtocolTCPUDPSliceAsProperty unmarshals a slice of SecurityGroupRuleProtocolTCPUDP instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRuleProtocolTCPUDPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRuleProtocolTCPUDP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRuleProtocolTCPUDP'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRuleProtocolTCPUDPSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeRemoteCIDR : SecurityGroupRulePrototypeRemoteCIDR struct
// This model "extends" SecurityGroupRulePrototypeRemote
type SecurityGroupRulePrototypeRemoteCIDR struct {
	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CidrBlock *string `json:"cidr_block" validate:"required"`
}

// NewSecurityGroupRulePrototypeRemoteCIDR : Instantiate SecurityGroupRulePrototypeRemoteCIDR (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeRemoteCIDR(cidrBlock string) (model *SecurityGroupRulePrototypeRemoteCIDR, err error) {
	model = &SecurityGroupRulePrototypeRemoteCIDR{
		CidrBlock: core.StringPtr(cidrBlock),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeRemoteCIDR) isaSecurityGroupRulePrototypeRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeRemoteCIDR constructs an instance of SecurityGroupRulePrototypeRemoteCIDR from the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteCIDR(m map[string]interface{}) (result *SecurityGroupRulePrototypeRemoteCIDR, err error) {
	obj := new(SecurityGroupRulePrototypeRemoteCIDR)
	obj.CidrBlock, err = core.UnmarshalString(m, "cidr_block")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteCIDRSlice unmarshals a slice of SecurityGroupRulePrototypeRemoteCIDR instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeRemoteCIDRSlice(s []interface{}) (slice []SecurityGroupRulePrototypeRemoteCIDR, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeRemoteCIDR'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeRemoteCIDR(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteCIDRAsProperty unmarshals an instance of SecurityGroupRulePrototypeRemoteCIDR that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteCIDRAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeRemoteCIDR, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeRemoteCIDR'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeRemoteCIDR(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteCIDRSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeRemoteCIDR instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteCIDRSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeRemoteCIDR, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeRemoteCIDR'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeRemoteCIDRSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeRemoteIP : SecurityGroupRulePrototypeRemoteIP struct
// This model "extends" SecurityGroupRulePrototypeRemote
type SecurityGroupRulePrototypeRemoteIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewSecurityGroupRulePrototypeRemoteIP : Instantiate SecurityGroupRulePrototypeRemoteIP (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeRemoteIP(address string) (model *SecurityGroupRulePrototypeRemoteIP, err error) {
	model = &SecurityGroupRulePrototypeRemoteIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeRemoteIP) isaSecurityGroupRulePrototypeRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeRemoteIP constructs an instance of SecurityGroupRulePrototypeRemoteIP from the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteIP(m map[string]interface{}) (result *SecurityGroupRulePrototypeRemoteIP, err error) {
	obj := new(SecurityGroupRulePrototypeRemoteIP)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteIPSlice unmarshals a slice of SecurityGroupRulePrototypeRemoteIP instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeRemoteIPSlice(s []interface{}) (slice []SecurityGroupRulePrototypeRemoteIP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeRemoteIP'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeRemoteIP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteIPAsProperty unmarshals an instance of SecurityGroupRulePrototypeRemoteIP that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteIPAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeRemoteIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeRemoteIP'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeRemoteIP(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteIPSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeRemoteIP instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteIPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeRemoteIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeRemoteIP'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeRemoteIPSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeRemoteSecurityGroupIdentity : Identifies a security group by a unique property.
// Models which "extend" this model:
// - SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID
// - SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN
// - SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref
// This model "extends" SecurityGroupRulePrototypeRemote
type SecurityGroupRulePrototypeRemoteSecurityGroupIdentity struct {
	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	Crn *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupRulePrototypeRemoteSecurityGroupIdentity) isaSecurityGroupRulePrototypeRemoteSecurityGroupIdentity() bool {
	return true
}

type SecurityGroupRulePrototypeRemoteSecurityGroupIdentityIntf interface {
	SecurityGroupRulePrototypeRemoteIntf
	isaSecurityGroupRulePrototypeRemoteSecurityGroupIdentity() bool
}

func (*SecurityGroupRulePrototypeRemoteSecurityGroupIdentity) isaSecurityGroupRulePrototypeRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentity constructs an instance of SecurityGroupRulePrototypeRemoteSecurityGroupIdentity from the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentity(m map[string]interface{}) (result SecurityGroupRulePrototypeRemoteSecurityGroupIdentityIntf, err error) {
	obj := new(SecurityGroupRulePrototypeRemoteSecurityGroupIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySlice unmarshals a slice of SecurityGroupRulePrototypeRemoteSecurityGroupIdentity instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySlice(s []interface{}) (slice []SecurityGroupRulePrototypeRemoteSecurityGroupIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeRemoteSecurityGroupIdentity'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentityAsProperty unmarshals an instance of SecurityGroupRulePrototypeRemoteSecurityGroupIdentity that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentityAsProperty(m map[string]interface{}, propertyName string) (result SecurityGroupRulePrototypeRemoteSecurityGroupIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeRemoteSecurityGroupIdentity'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentity(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeRemoteSecurityGroupIdentity instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeRemoteSecurityGroupIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeRemoteSecurityGroupIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR : SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR struct {
	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CidrBlock *string `json:"cidr_block" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR(cidrBlock string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR{
		CidrBlock: core.StringPtr(cidrBlock),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR(m map[string]interface{}) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR)
	obj.CidrBlock, err = core.UnmarshalString(m, "cidr_block")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDRSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDRSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDRAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDRAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDRSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDRSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDRSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP : SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP(address string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP(m map[string]interface{}) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIPSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIPSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIPAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIPAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIPSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIPSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity : Identifies a security group by a unique property.
// Models which "extend" this model:
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity struct {
	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	Crn *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity() bool {
	return true
}

type SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentityIntf interface {
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIntf
	isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity() bool
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity(m map[string]interface{}) (result SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentityIntf, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentityAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentityAsProperty(m map[string]interface{}, propertyName string) (result SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR : SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR struct {
	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CidrBlock *string `json:"cidr_block" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR(cidrBlock string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR{
		CidrBlock: core.StringPtr(cidrBlock),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR(m map[string]interface{}) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR)
	obj.CidrBlock, err = core.UnmarshalString(m, "cidr_block")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDRSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDRSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDRAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDRAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDRSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDRSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDR'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteCIDRSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP : SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP(address string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP(m map[string]interface{}) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIPSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIPSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIPAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIPAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIPSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIP'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIPSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity : Identifies a security group by a unique property.
// Models which "extend" this model:
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity struct {
	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	Crn *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity() bool {
	return true
}

type SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentityIntf interface {
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIntf
	isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity() bool
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity(m map[string]interface{}) (result SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentityIntf, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentityAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentityAsProperty(m map[string]interface{}, propertyName string) (result SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR : SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR struct {
	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CidrBlock *string `json:"cidr_block" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR(cidrBlock string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR{
		CidrBlock: core.StringPtr(cidrBlock),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR(m map[string]interface{}) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR)
	obj.CidrBlock, err = core.UnmarshalString(m, "cidr_block")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDRSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDRSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDRAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDRAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDRSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDRSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDR'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteCIDRSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP : SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP(address string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP(m map[string]interface{}) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIPSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIPSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIPAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIPAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIPSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIP'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIPSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity : Identifies a security group by a unique property.
// Models which "extend" this model:
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity struct {
	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	Crn *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity() bool {
	return true
}

type SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentityIntf interface {
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIntf
	isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity() bool
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity(m map[string]interface{}) (result SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentityIntf, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentityAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentityAsProperty(m map[string]interface{}, propertyName string) (result SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll : When `protocol` is `all`, then it's invalid to specify `port_min`, `port_max`, `type` or
// `code`.
// This model "extends" SecurityGroupRulePrototype
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll struct {
	// The direction of traffic to enforce, either `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
	// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
	// interfaces) in that group matching this IP version.
	IpVersion *string `json:"ip_version,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The IP addresses or security groups from which this rule will allow traffic (or to
	// which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
	// security group. If omitted, a CIDR block of `0.0.0.0/0` will be used to allow traffic
	// from any source (or to any source, for outbound rules).
	Remote SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIntf `json:"remote,omitempty"`
}

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll.Direction property.
// The direction of traffic to enforce, either `inbound` or `outbound`.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll_Direction_Inbound  = "inbound"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll_Direction_Outbound = "outbound"
)

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll.IpVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
// interfaces) in that group matching this IP version.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll_IpVersion_Ipv4 = "ipv4"
)

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll_Protocol_All  = "all"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll_Protocol_Icmp = "icmp"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll_Protocol_Tcp  = "tcp"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll_Protocol_Udp  = "udp"
)

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAll : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAll(direction string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll{
		Direction: core.StringPtr(direction),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll) isaSecurityGroupRulePrototype() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAll constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAll(m map[string]interface{}) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll)
	obj.Direction, err = core.UnmarshalString(m, "direction")
	if err != nil {
		return
	}
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.Remote, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteAsProperty(m, "remote")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAll(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAll(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP : When `protocol` is `icmp`, then the rule may also contain fields to specify an ICMP `type` and `code`. Field `code`
// may only be specified if `type` is also specified. If type is not specified, then traffic is allowed for all types
// and codes. If type is specified and code is not specified, then traffic is allowed with the specified type for all
// codes.
// This model "extends" SecurityGroupRulePrototype
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP struct {
	// The direction of traffic to enforce, either `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
	// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
	// interfaces) in that group matching this IP version.
	IpVersion *string `json:"ip_version,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The IP addresses or security groups from which this rule will allow traffic (or to
	// which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
	// security group. If omitted, a CIDR block of `0.0.0.0/0` will be used to allow traffic
	// from any source (or to any source, for outbound rules).
	Remote SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteIntf `json:"remote,omitempty"`

	// The ICMP traffic code to allow.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP.Direction property.
// The direction of traffic to enforce, either `inbound` or `outbound`.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP_Direction_Inbound  = "inbound"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP_Direction_Outbound = "outbound"
)

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP.IpVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
// interfaces) in that group matching this IP version.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP_IpVersion_Ipv4 = "ipv4"
)

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP_Protocol_All  = "all"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP_Protocol_Icmp = "icmp"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP_Protocol_Tcp  = "tcp"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP_Protocol_Udp  = "udp"
)

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP(direction string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP{
		Direction: core.StringPtr(direction),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP) isaSecurityGroupRulePrototype() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP(m map[string]interface{}) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP)
	obj.Direction, err = core.UnmarshalString(m, "direction")
	if err != nil {
		return
	}
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.Remote, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteAsProperty(m, "remote")
	if err != nil {
		return
	}
	obj.Code, err = core.UnmarshalInt64(m, "code")
	if err != nil {
		return
	}
	obj.Type, err = core.UnmarshalInt64(m, "type")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP : If `protocol` is either `tcp` or `udp`, then the rule may also contain `port_min` and
// `port_max`. Either both should be set, or neither. When neither is set then traffic is allowed on all ports. For a
// single port, set both to the same value.
// This model "extends" SecurityGroupRulePrototype
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP struct {
	// The direction of traffic to enforce, either `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
	// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
	// interfaces) in that group matching this IP version.
	IpVersion *string `json:"ip_version,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The IP addresses or security groups from which this rule will allow traffic (or to
	// which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
	// security group. If omitted, a CIDR block of `0.0.0.0/0` will be used to allow traffic
	// from any source (or to any source, for outbound rules).
	Remote SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteIntf `json:"remote,omitempty"`

	// The inclusive upper bound of TCP/UDP port range.
	PortMax *int64 `json:"port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP port range.
	PortMin *int64 `json:"port_min,omitempty"`
}

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP.Direction property.
// The direction of traffic to enforce, either `inbound` or `outbound`.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP_Direction_Inbound  = "inbound"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP_Direction_Outbound = "outbound"
)

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP.IpVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
// interfaces) in that group matching this IP version.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP_IpVersion_Ipv4 = "ipv4"
)

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP_Protocol_All  = "all"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP_Protocol_Icmp = "icmp"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP_Protocol_Tcp  = "tcp"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP_Protocol_Udp  = "udp"
)

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP(direction string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP{
		Direction: core.StringPtr(direction),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP) isaSecurityGroupRulePrototype() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP(m map[string]interface{}) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP)
	obj.Direction, err = core.UnmarshalString(m, "direction")
	if err != nil {
		return
	}
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Protocol, err = core.UnmarshalString(m, "protocol")
	if err != nil {
		return
	}
	obj.Remote, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteAsProperty(m, "remote")
	if err != nil {
		return
	}
	obj.PortMax, err = core.UnmarshalInt64(m, "port_max")
	if err != nil {
		return
	}
	obj.PortMin, err = core.UnmarshalInt64(m, "port_min")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPSlice(vSlice)
	}
	return
}

// SecurityGroupRuleRemoteCIDR : SecurityGroupRuleRemoteCIDR struct
// This model "extends" SecurityGroupRuleRemote
type SecurityGroupRuleRemoteCIDR struct {
	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CidrBlock *string `json:"cidr_block" validate:"required"`
}

func (*SecurityGroupRuleRemoteCIDR) isaSecurityGroupRuleRemote() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemoteCIDR constructs an instance of SecurityGroupRuleRemoteCIDR from the specified map.
func UnmarshalSecurityGroupRuleRemoteCIDR(m map[string]interface{}) (result *SecurityGroupRuleRemoteCIDR, err error) {
	obj := new(SecurityGroupRuleRemoteCIDR)
	obj.CidrBlock, err = core.UnmarshalString(m, "cidr_block")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRuleRemoteCIDRSlice unmarshals a slice of SecurityGroupRuleRemoteCIDR instances from the specified list of maps.
func UnmarshalSecurityGroupRuleRemoteCIDRSlice(s []interface{}) (slice []SecurityGroupRuleRemoteCIDR, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRuleRemoteCIDR'")
			return
		}
		obj, e := UnmarshalSecurityGroupRuleRemoteCIDR(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRuleRemoteCIDRAsProperty unmarshals an instance of SecurityGroupRuleRemoteCIDR that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRuleRemoteCIDRAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRuleRemoteCIDR, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRuleRemoteCIDR'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRuleRemoteCIDR(objMap)
	}
	return
}

// UnmarshalSecurityGroupRuleRemoteCIDRSliceAsProperty unmarshals a slice of SecurityGroupRuleRemoteCIDR instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRuleRemoteCIDRSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRuleRemoteCIDR, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRuleRemoteCIDR'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRuleRemoteCIDRSlice(vSlice)
	}
	return
}

// SecurityGroupRuleRemoteIP : SecurityGroupRuleRemoteIP struct
// This model "extends" SecurityGroupRuleRemote
type SecurityGroupRuleRemoteIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

func (*SecurityGroupRuleRemoteIP) isaSecurityGroupRuleRemote() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemoteIP constructs an instance of SecurityGroupRuleRemoteIP from the specified map.
func UnmarshalSecurityGroupRuleRemoteIP(m map[string]interface{}) (result *SecurityGroupRuleRemoteIP, err error) {
	obj := new(SecurityGroupRuleRemoteIP)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRuleRemoteIPSlice unmarshals a slice of SecurityGroupRuleRemoteIP instances from the specified list of maps.
func UnmarshalSecurityGroupRuleRemoteIPSlice(s []interface{}) (slice []SecurityGroupRuleRemoteIP, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRuleRemoteIP'")
			return
		}
		obj, e := UnmarshalSecurityGroupRuleRemoteIP(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRuleRemoteIPAsProperty unmarshals an instance of SecurityGroupRuleRemoteIP that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRuleRemoteIPAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRuleRemoteIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRuleRemoteIP'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRuleRemoteIP(objMap)
	}
	return
}

// UnmarshalSecurityGroupRuleRemoteIPSliceAsProperty unmarshals a slice of SecurityGroupRuleRemoteIP instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRuleRemoteIPSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRuleRemoteIP, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRuleRemoteIP'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRuleRemoteIPSlice(vSlice)
	}
	return
}

// SecurityGroupRuleRemoteSecurityGroupReference : SecurityGroupRuleRemoteSecurityGroupReference struct
// This model "extends" SecurityGroupRuleRemote
type SecurityGroupRuleRemoteSecurityGroupReference struct {
	// The security group's CRN.
	Crn *string `json:"crn" validate:"required"`

	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name" validate:"required"`
}

func (*SecurityGroupRuleRemoteSecurityGroupReference) isaSecurityGroupRuleRemote() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemoteSecurityGroupReference constructs an instance of SecurityGroupRuleRemoteSecurityGroupReference from the specified map.
func UnmarshalSecurityGroupRuleRemoteSecurityGroupReference(m map[string]interface{}) (result *SecurityGroupRuleRemoteSecurityGroupReference, err error) {
	obj := new(SecurityGroupRuleRemoteSecurityGroupReference)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRuleRemoteSecurityGroupReferenceSlice unmarshals a slice of SecurityGroupRuleRemoteSecurityGroupReference instances from the specified list of maps.
func UnmarshalSecurityGroupRuleRemoteSecurityGroupReferenceSlice(s []interface{}) (slice []SecurityGroupRuleRemoteSecurityGroupReference, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRuleRemoteSecurityGroupReference'")
			return
		}
		obj, e := UnmarshalSecurityGroupRuleRemoteSecurityGroupReference(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRuleRemoteSecurityGroupReferenceAsProperty unmarshals an instance of SecurityGroupRuleRemoteSecurityGroupReference that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRuleRemoteSecurityGroupReferenceAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRuleRemoteSecurityGroupReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRuleRemoteSecurityGroupReference'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRuleRemoteSecurityGroupReference(objMap)
	}
	return
}

// UnmarshalSecurityGroupRuleRemoteSecurityGroupReferenceSliceAsProperty unmarshals a slice of SecurityGroupRuleRemoteSecurityGroupReference instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRuleRemoteSecurityGroupReferenceSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRuleRemoteSecurityGroupReference, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRuleRemoteSecurityGroupReference'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRuleRemoteSecurityGroupReferenceSlice(vSlice)
	}
	return
}

// SubnetIdentityByCRN : SubnetIdentityByCRN struct
// This model "extends" SubnetIdentity
type SubnetIdentityByCRN struct {
	// The CRN for this subnet.
	Crn *string `json:"crn" validate:"required"`
}

// NewSubnetIdentityByCRN : Instantiate SubnetIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewSubnetIdentityByCRN(crn string) (model *SubnetIdentityByCRN, err error) {
	model = &SubnetIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SubnetIdentityByCRN) isaSubnetIdentity() bool {
	return true
}

// UnmarshalSubnetIdentityByCRN constructs an instance of SubnetIdentityByCRN from the specified map.
func UnmarshalSubnetIdentityByCRN(m map[string]interface{}) (result *SubnetIdentityByCRN, err error) {
	obj := new(SubnetIdentityByCRN)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSubnetIdentityByCRNSlice unmarshals a slice of SubnetIdentityByCRN instances from the specified list of maps.
func UnmarshalSubnetIdentityByCRNSlice(s []interface{}) (slice []SubnetIdentityByCRN, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SubnetIdentityByCRN'")
			return
		}
		obj, e := UnmarshalSubnetIdentityByCRN(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSubnetIdentityByCRNAsProperty unmarshals an instance of SubnetIdentityByCRN that is stored as a property
// within the specified map.
func UnmarshalSubnetIdentityByCRNAsProperty(m map[string]interface{}, propertyName string) (result *SubnetIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SubnetIdentityByCRN'", propertyName)
			return
		}
		result, err = UnmarshalSubnetIdentityByCRN(objMap)
	}
	return
}

// UnmarshalSubnetIdentityByCRNSliceAsProperty unmarshals a slice of SubnetIdentityByCRN instances that are stored as a property
// within the specified map.
func UnmarshalSubnetIdentityByCRNSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SubnetIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SubnetIdentityByCRN'", propertyName)
			return
		}
		slice, err = UnmarshalSubnetIdentityByCRNSlice(vSlice)
	}
	return
}

// SubnetIdentityByHref : SubnetIdentityByHref struct
// This model "extends" SubnetIdentity
type SubnetIdentityByHref struct {
	// The URL for this subnet.
	Href *string `json:"href" validate:"required"`
}

// NewSubnetIdentityByHref : Instantiate SubnetIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewSubnetIdentityByHref(href string) (model *SubnetIdentityByHref, err error) {
	model = &SubnetIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SubnetIdentityByHref) isaSubnetIdentity() bool {
	return true
}

// UnmarshalSubnetIdentityByHref constructs an instance of SubnetIdentityByHref from the specified map.
func UnmarshalSubnetIdentityByHref(m map[string]interface{}) (result *SubnetIdentityByHref, err error) {
	obj := new(SubnetIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSubnetIdentityByHrefSlice unmarshals a slice of SubnetIdentityByHref instances from the specified list of maps.
func UnmarshalSubnetIdentityByHrefSlice(s []interface{}) (slice []SubnetIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SubnetIdentityByHref'")
			return
		}
		obj, e := UnmarshalSubnetIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSubnetIdentityByHrefAsProperty unmarshals an instance of SubnetIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalSubnetIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *SubnetIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SubnetIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalSubnetIdentityByHref(objMap)
	}
	return
}

// UnmarshalSubnetIdentityByHrefSliceAsProperty unmarshals a slice of SubnetIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalSubnetIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SubnetIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SubnetIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalSubnetIdentityByHrefSlice(vSlice)
	}
	return
}

// SubnetIdentityByID : SubnetIdentityByID struct
// This model "extends" SubnetIdentity
type SubnetIdentityByID struct {
	// The unique identifier for this subnet.
	ID *string `json:"id" validate:"required"`
}

// NewSubnetIdentityByID : Instantiate SubnetIdentityByID (Generic Model Constructor)
func (*VpcV1) NewSubnetIdentityByID(id string) (model *SubnetIdentityByID, err error) {
	model = &SubnetIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SubnetIdentityByID) isaSubnetIdentity() bool {
	return true
}

// UnmarshalSubnetIdentityByID constructs an instance of SubnetIdentityByID from the specified map.
func UnmarshalSubnetIdentityByID(m map[string]interface{}) (result *SubnetIdentityByID, err error) {
	obj := new(SubnetIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSubnetIdentityByIDSlice unmarshals a slice of SubnetIdentityByID instances from the specified list of maps.
func UnmarshalSubnetIdentityByIDSlice(s []interface{}) (slice []SubnetIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SubnetIdentityByID'")
			return
		}
		obj, e := UnmarshalSubnetIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSubnetIdentityByIDAsProperty unmarshals an instance of SubnetIdentityByID that is stored as a property
// within the specified map.
func UnmarshalSubnetIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *SubnetIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SubnetIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalSubnetIdentityByID(objMap)
	}
	return
}

// UnmarshalSubnetIdentityByIDSliceAsProperty unmarshals a slice of SubnetIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalSubnetIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SubnetIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SubnetIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalSubnetIdentityByIDSlice(vSlice)
	}
	return
}

// SubnetPrototypeSubnetByCIDR : SubnetPrototypeSubnetByCIDR struct
// This model "extends" SubnetPrototype
type SubnetPrototypeSubnetByCIDR struct {
	// The IP version(s) supported by this subnet; if unspecified, `ipv4` is used.
	IpVersion *string `json:"ip_version,omitempty"`

	// The user-defined name for this subnet. Names must be unique within the VPC the subnet resides in. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The network ACL to use for this subnet.
	NetworkAcl NetworkACLIdentityIntf `json:"network_acl,omitempty"`

	// The public gateway to handle internet bound traffic for this subnet.
	PublicGateway PublicGatewayIdentityIntf `json:"public_gateway,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The VPC the subnet is to be a part of.
	Vpc VPCIdentityIntf `json:"vpc" validate:"required"`

	// The IPv4 range of the subnet, expressed in CIDR format. The prefix length of the subnet's CIDR must be between 8 and
	// 29. The IPv4 range of the subnet's CIDR must fall within an existing address prefix in the VPC. The subnet will be
	// created in the zone of the address prefix that contains the IPv4 CIDR. If zone is specified, it must match the zone
	// of the address prefix that contains the subnet's IPv4 CIDR.
	Ipv4CidrBlock *string `json:"ipv4_cidr_block" validate:"required"`

	// The zone the subnet is to reside in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`
}

// Constants associated with the SubnetPrototypeSubnetByCIDR.IpVersion property.
// The IP version(s) supported by this subnet; if unspecified, `ipv4` is used.
const (
	SubnetPrototypeSubnetByCIDR_IpVersion_Both = "both"
	SubnetPrototypeSubnetByCIDR_IpVersion_Ipv4 = "ipv4"
	SubnetPrototypeSubnetByCIDR_IpVersion_Ipv6 = "ipv6"
)

// NewSubnetPrototypeSubnetByCIDR : Instantiate SubnetPrototypeSubnetByCIDR (Generic Model Constructor)
func (*VpcV1) NewSubnetPrototypeSubnetByCIDR(vpc VPCIdentityIntf, ipv4CidrBlock string) (model *SubnetPrototypeSubnetByCIDR, err error) {
	model = &SubnetPrototypeSubnetByCIDR{
		Vpc:           vpc,
		Ipv4CidrBlock: core.StringPtr(ipv4CidrBlock),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SubnetPrototypeSubnetByCIDR) isaSubnetPrototype() bool {
	return true
}

// UnmarshalSubnetPrototypeSubnetByCIDR constructs an instance of SubnetPrototypeSubnetByCIDR from the specified map.
func UnmarshalSubnetPrototypeSubnetByCIDR(m map[string]interface{}) (result *SubnetPrototypeSubnetByCIDR, err error) {
	obj := new(SubnetPrototypeSubnetByCIDR)
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.NetworkAcl, err = UnmarshalNetworkACLIdentityAsProperty(m, "network_acl")
	if err != nil {
		return
	}
	obj.PublicGateway, err = UnmarshalPublicGatewayIdentityAsProperty(m, "public_gateway")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupIdentityAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Vpc, err = UnmarshalVPCIdentityAsProperty(m, "vpc")
	if err != nil {
		return
	}
	obj.Ipv4CidrBlock, err = core.UnmarshalString(m, "ipv4_cidr_block")
	if err != nil {
		return
	}
	obj.Zone, err = UnmarshalZoneIdentityAsProperty(m, "zone")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSubnetPrototypeSubnetByCIDRSlice unmarshals a slice of SubnetPrototypeSubnetByCIDR instances from the specified list of maps.
func UnmarshalSubnetPrototypeSubnetByCIDRSlice(s []interface{}) (slice []SubnetPrototypeSubnetByCIDR, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SubnetPrototypeSubnetByCIDR'")
			return
		}
		obj, e := UnmarshalSubnetPrototypeSubnetByCIDR(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSubnetPrototypeSubnetByCIDRAsProperty unmarshals an instance of SubnetPrototypeSubnetByCIDR that is stored as a property
// within the specified map.
func UnmarshalSubnetPrototypeSubnetByCIDRAsProperty(m map[string]interface{}, propertyName string) (result *SubnetPrototypeSubnetByCIDR, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SubnetPrototypeSubnetByCIDR'", propertyName)
			return
		}
		result, err = UnmarshalSubnetPrototypeSubnetByCIDR(objMap)
	}
	return
}

// UnmarshalSubnetPrototypeSubnetByCIDRSliceAsProperty unmarshals a slice of SubnetPrototypeSubnetByCIDR instances that are stored as a property
// within the specified map.
func UnmarshalSubnetPrototypeSubnetByCIDRSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SubnetPrototypeSubnetByCIDR, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SubnetPrototypeSubnetByCIDR'", propertyName)
			return
		}
		slice, err = UnmarshalSubnetPrototypeSubnetByCIDRSlice(vSlice)
	}
	return
}

// SubnetPrototypeSubnetByTotalCount : SubnetPrototypeSubnetByTotalCount struct
// This model "extends" SubnetPrototype
type SubnetPrototypeSubnetByTotalCount struct {
	// The IP version(s) supported by this subnet; if unspecified, `ipv4` is used.
	IpVersion *string `json:"ip_version,omitempty"`

	// The user-defined name for this subnet. Names must be unique within the VPC the subnet resides in. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The network ACL to use for this subnet.
	NetworkAcl NetworkACLIdentityIntf `json:"network_acl,omitempty"`

	// The public gateway to handle internet bound traffic for this subnet.
	PublicGateway PublicGatewayIdentityIntf `json:"public_gateway,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The VPC the subnet is to be a part of.
	Vpc VPCIdentityIntf `json:"vpc" validate:"required"`

	// The total number of IPv4 addresses required. Must be a power of 2. The VPC must have a default address prefix in the
	// specified zone, and that prefix must have a free CIDR range with at least this number of addresses.
	TotalIpv4AddressCount *int64 `json:"total_ipv4_address_count" validate:"required"`

	// The zone the subnet is to reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// Constants associated with the SubnetPrototypeSubnetByTotalCount.IpVersion property.
// The IP version(s) supported by this subnet; if unspecified, `ipv4` is used.
const (
	SubnetPrototypeSubnetByTotalCount_IpVersion_Both = "both"
	SubnetPrototypeSubnetByTotalCount_IpVersion_Ipv4 = "ipv4"
	SubnetPrototypeSubnetByTotalCount_IpVersion_Ipv6 = "ipv6"
)

// NewSubnetPrototypeSubnetByTotalCount : Instantiate SubnetPrototypeSubnetByTotalCount (Generic Model Constructor)
func (*VpcV1) NewSubnetPrototypeSubnetByTotalCount(vpc VPCIdentityIntf, totalIpv4AddressCount int64, zone ZoneIdentityIntf) (model *SubnetPrototypeSubnetByTotalCount, err error) {
	model = &SubnetPrototypeSubnetByTotalCount{
		Vpc:                   vpc,
		TotalIpv4AddressCount: core.Int64Ptr(totalIpv4AddressCount),
		Zone:                  zone,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SubnetPrototypeSubnetByTotalCount) isaSubnetPrototype() bool {
	return true
}

// UnmarshalSubnetPrototypeSubnetByTotalCount constructs an instance of SubnetPrototypeSubnetByTotalCount from the specified map.
func UnmarshalSubnetPrototypeSubnetByTotalCount(m map[string]interface{}) (result *SubnetPrototypeSubnetByTotalCount, err error) {
	obj := new(SubnetPrototypeSubnetByTotalCount)
	obj.IpVersion, err = core.UnmarshalString(m, "ip_version")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.NetworkAcl, err = UnmarshalNetworkACLIdentityAsProperty(m, "network_acl")
	if err != nil {
		return
	}
	obj.PublicGateway, err = UnmarshalPublicGatewayIdentityAsProperty(m, "public_gateway")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupIdentityAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Vpc, err = UnmarshalVPCIdentityAsProperty(m, "vpc")
	if err != nil {
		return
	}
	obj.TotalIpv4AddressCount, err = core.UnmarshalInt64(m, "total_ipv4_address_count")
	if err != nil {
		return
	}
	obj.Zone, err = UnmarshalZoneIdentityAsProperty(m, "zone")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSubnetPrototypeSubnetByTotalCountSlice unmarshals a slice of SubnetPrototypeSubnetByTotalCount instances from the specified list of maps.
func UnmarshalSubnetPrototypeSubnetByTotalCountSlice(s []interface{}) (slice []SubnetPrototypeSubnetByTotalCount, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SubnetPrototypeSubnetByTotalCount'")
			return
		}
		obj, e := UnmarshalSubnetPrototypeSubnetByTotalCount(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSubnetPrototypeSubnetByTotalCountAsProperty unmarshals an instance of SubnetPrototypeSubnetByTotalCount that is stored as a property
// within the specified map.
func UnmarshalSubnetPrototypeSubnetByTotalCountAsProperty(m map[string]interface{}, propertyName string) (result *SubnetPrototypeSubnetByTotalCount, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SubnetPrototypeSubnetByTotalCount'", propertyName)
			return
		}
		result, err = UnmarshalSubnetPrototypeSubnetByTotalCount(objMap)
	}
	return
}

// UnmarshalSubnetPrototypeSubnetByTotalCountSliceAsProperty unmarshals a slice of SubnetPrototypeSubnetByTotalCount instances that are stored as a property
// within the specified map.
func UnmarshalSubnetPrototypeSubnetByTotalCountSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SubnetPrototypeSubnetByTotalCount, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SubnetPrototypeSubnetByTotalCount'", propertyName)
			return
		}
		slice, err = UnmarshalSubnetPrototypeSubnetByTotalCountSlice(vSlice)
	}
	return
}

// VPCIdentityByCRN : VPCIdentityByCRN struct
// This model "extends" VPCIdentity
type VPCIdentityByCRN struct {
	// The CRN for this VPC.
	Crn *string `json:"crn" validate:"required"`
}

// NewVPCIdentityByCRN : Instantiate VPCIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewVPCIdentityByCRN(crn string) (model *VPCIdentityByCRN, err error) {
	model = &VPCIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VPCIdentityByCRN) isaVPCIdentity() bool {
	return true
}

// UnmarshalVPCIdentityByCRN constructs an instance of VPCIdentityByCRN from the specified map.
func UnmarshalVPCIdentityByCRN(m map[string]interface{}) (result *VPCIdentityByCRN, err error) {
	obj := new(VPCIdentityByCRN)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPCIdentityByCRNSlice unmarshals a slice of VPCIdentityByCRN instances from the specified list of maps.
func UnmarshalVPCIdentityByCRNSlice(s []interface{}) (slice []VPCIdentityByCRN, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPCIdentityByCRN'")
			return
		}
		obj, e := UnmarshalVPCIdentityByCRN(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPCIdentityByCRNAsProperty unmarshals an instance of VPCIdentityByCRN that is stored as a property
// within the specified map.
func UnmarshalVPCIdentityByCRNAsProperty(m map[string]interface{}, propertyName string) (result *VPCIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPCIdentityByCRN'", propertyName)
			return
		}
		result, err = UnmarshalVPCIdentityByCRN(objMap)
	}
	return
}

// UnmarshalVPCIdentityByCRNSliceAsProperty unmarshals a slice of VPCIdentityByCRN instances that are stored as a property
// within the specified map.
func UnmarshalVPCIdentityByCRNSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPCIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPCIdentityByCRN'", propertyName)
			return
		}
		slice, err = UnmarshalVPCIdentityByCRNSlice(vSlice)
	}
	return
}

// VPCIdentityByHref : VPCIdentityByHref struct
// This model "extends" VPCIdentity
type VPCIdentityByHref struct {
	// The URL for this VPC.
	Href *string `json:"href" validate:"required"`
}

// NewVPCIdentityByHref : Instantiate VPCIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewVPCIdentityByHref(href string) (model *VPCIdentityByHref, err error) {
	model = &VPCIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VPCIdentityByHref) isaVPCIdentity() bool {
	return true
}

// UnmarshalVPCIdentityByHref constructs an instance of VPCIdentityByHref from the specified map.
func UnmarshalVPCIdentityByHref(m map[string]interface{}) (result *VPCIdentityByHref, err error) {
	obj := new(VPCIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPCIdentityByHrefSlice unmarshals a slice of VPCIdentityByHref instances from the specified list of maps.
func UnmarshalVPCIdentityByHrefSlice(s []interface{}) (slice []VPCIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPCIdentityByHref'")
			return
		}
		obj, e := UnmarshalVPCIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPCIdentityByHrefAsProperty unmarshals an instance of VPCIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalVPCIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *VPCIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPCIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalVPCIdentityByHref(objMap)
	}
	return
}

// UnmarshalVPCIdentityByHrefSliceAsProperty unmarshals a slice of VPCIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalVPCIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPCIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPCIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalVPCIdentityByHrefSlice(vSlice)
	}
	return
}

// VPCIdentityByID : VPCIdentityByID struct
// This model "extends" VPCIdentity
type VPCIdentityByID struct {
	// The unique identifier for this VPC.
	ID *string `json:"id" validate:"required"`
}

// NewVPCIdentityByID : Instantiate VPCIdentityByID (Generic Model Constructor)
func (*VpcV1) NewVPCIdentityByID(id string) (model *VPCIdentityByID, err error) {
	model = &VPCIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VPCIdentityByID) isaVPCIdentity() bool {
	return true
}

// UnmarshalVPCIdentityByID constructs an instance of VPCIdentityByID from the specified map.
func UnmarshalVPCIdentityByID(m map[string]interface{}) (result *VPCIdentityByID, err error) {
	obj := new(VPCIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVPCIdentityByIDSlice unmarshals a slice of VPCIdentityByID instances from the specified list of maps.
func UnmarshalVPCIdentityByIDSlice(s []interface{}) (slice []VPCIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VPCIdentityByID'")
			return
		}
		obj, e := UnmarshalVPCIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVPCIdentityByIDAsProperty unmarshals an instance of VPCIdentityByID that is stored as a property
// within the specified map.
func UnmarshalVPCIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *VPCIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VPCIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalVPCIdentityByID(objMap)
	}
	return
}

// UnmarshalVPCIdentityByIDSliceAsProperty unmarshals a slice of VPCIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalVPCIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VPCIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VPCIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalVPCIdentityByIDSlice(vSlice)
	}
	return
}

// VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity : Identifies a volume by a unique property.
// Models which "extend" this model:
// - VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID
// - VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN
// - VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref
// This model "extends" VolumeAttachmentPrototypeInstanceContextVolume
type VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity struct {
	// The unique identifier for this volume.
	ID *string `json:"id,omitempty"`

	// The CRN for this volume.
	Crn *string `json:"crn,omitempty"`

	// The URL for this volume.
	Href *string `json:"href,omitempty"`
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity) isaVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity() bool {
	return true
}

type VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityIntf interface {
	VolumeAttachmentPrototypeInstanceContextVolumeIntf
	isaVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity() bool
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity) isaVolumeAttachmentPrototypeInstanceContextVolume() bool {
	return true
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity constructs an instance of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity from the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity(m map[string]interface{}) (result VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityIntf, err error) {
	obj := new(VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentitySlice unmarshals a slice of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity instances from the specified list of maps.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentitySlice(s []interface{}) (slice []VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity'")
			return
		}
		obj, e := UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityAsProperty unmarshals an instance of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity that is stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityAsProperty(m map[string]interface{}, propertyName string) (result VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity'", propertyName)
			return
		}
		result, err = UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity(objMap)
	}
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentitySliceAsProperty unmarshals a slice of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity instances that are stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentitySlice(vSlice)
	}
	return
}

// VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext : VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext struct
// Models which "extend" this model:
// - VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity
// This model "extends" VolumeAttachmentPrototypeInstanceContextVolume
type VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext struct {
	// The bandwidth for the volume.
	Iops *int64 `json:"iops,omitempty"`

	// The unique user-defined name for this volume.
	Name *string `json:"name,omitempty"`

	// The profile to use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile" validate:"required"`

	// The capacity of the volume in gigabytes.
	Capacity *int64 `json:"capacity,omitempty"`
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext) isaVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext() bool {
	return true
}

type VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextIntf interface {
	VolumeAttachmentPrototypeInstanceContextVolumeIntf
	isaVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext() bool
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext) isaVolumeAttachmentPrototypeInstanceContextVolume() bool {
	return true
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext constructs an instance of VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext from the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext(m map[string]interface{}) (result VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextIntf, err error) {
	obj := new(VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext)
	obj.Iops, err = core.UnmarshalInt64(m, "iops")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Profile, err = UnmarshalVolumeProfileIdentityAsProperty(m, "profile")
	if err != nil {
		return
	}
	obj.Capacity, err = core.UnmarshalInt64(m, "capacity")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextSlice unmarshals a slice of VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext instances from the specified list of maps.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextSlice(s []interface{}) (slice []VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextIntf, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext'")
			return
		}
		obj, e := UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, obj)
	}
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextAsProperty unmarshals an instance of VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext that is stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextAsProperty(m map[string]interface{}, propertyName string) (result VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext'", propertyName)
			return
		}
		result, err = UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext(objMap)
	}
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextSliceAsProperty unmarshals a slice of VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext instances that are stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextIntf, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextSlice(vSlice)
	}
	return
}

// VolumeIdentityByCRN : VolumeIdentityByCRN struct
// This model "extends" VolumeIdentity
type VolumeIdentityByCRN struct {
	// The CRN for this volume.
	Crn *string `json:"crn" validate:"required"`
}

// NewVolumeIdentityByCRN : Instantiate VolumeIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewVolumeIdentityByCRN(crn string) (model *VolumeIdentityByCRN, err error) {
	model = &VolumeIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumeIdentityByCRN) isaVolumeIdentity() bool {
	return true
}

// UnmarshalVolumeIdentityByCRN constructs an instance of VolumeIdentityByCRN from the specified map.
func UnmarshalVolumeIdentityByCRN(m map[string]interface{}) (result *VolumeIdentityByCRN, err error) {
	obj := new(VolumeIdentityByCRN)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeIdentityByCRNSlice unmarshals a slice of VolumeIdentityByCRN instances from the specified list of maps.
func UnmarshalVolumeIdentityByCRNSlice(s []interface{}) (slice []VolumeIdentityByCRN, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeIdentityByCRN'")
			return
		}
		obj, e := UnmarshalVolumeIdentityByCRN(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeIdentityByCRNAsProperty unmarshals an instance of VolumeIdentityByCRN that is stored as a property
// within the specified map.
func UnmarshalVolumeIdentityByCRNAsProperty(m map[string]interface{}, propertyName string) (result *VolumeIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeIdentityByCRN'", propertyName)
			return
		}
		result, err = UnmarshalVolumeIdentityByCRN(objMap)
	}
	return
}

// UnmarshalVolumeIdentityByCRNSliceAsProperty unmarshals a slice of VolumeIdentityByCRN instances that are stored as a property
// within the specified map.
func UnmarshalVolumeIdentityByCRNSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeIdentityByCRN'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeIdentityByCRNSlice(vSlice)
	}
	return
}

// VolumeIdentityByHref : VolumeIdentityByHref struct
// This model "extends" VolumeIdentity
type VolumeIdentityByHref struct {
	// The URL for this volume.
	Href *string `json:"href" validate:"required"`
}

// NewVolumeIdentityByHref : Instantiate VolumeIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewVolumeIdentityByHref(href string) (model *VolumeIdentityByHref, err error) {
	model = &VolumeIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumeIdentityByHref) isaVolumeIdentity() bool {
	return true
}

// UnmarshalVolumeIdentityByHref constructs an instance of VolumeIdentityByHref from the specified map.
func UnmarshalVolumeIdentityByHref(m map[string]interface{}) (result *VolumeIdentityByHref, err error) {
	obj := new(VolumeIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeIdentityByHrefSlice unmarshals a slice of VolumeIdentityByHref instances from the specified list of maps.
func UnmarshalVolumeIdentityByHrefSlice(s []interface{}) (slice []VolumeIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeIdentityByHref'")
			return
		}
		obj, e := UnmarshalVolumeIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeIdentityByHrefAsProperty unmarshals an instance of VolumeIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalVolumeIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *VolumeIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalVolumeIdentityByHref(objMap)
	}
	return
}

// UnmarshalVolumeIdentityByHrefSliceAsProperty unmarshals a slice of VolumeIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalVolumeIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeIdentityByHrefSlice(vSlice)
	}
	return
}

// VolumeIdentityByID : VolumeIdentityByID struct
// This model "extends" VolumeIdentity
type VolumeIdentityByID struct {
	// The unique identifier for this volume.
	ID *string `json:"id" validate:"required"`
}

// NewVolumeIdentityByID : Instantiate VolumeIdentityByID (Generic Model Constructor)
func (*VpcV1) NewVolumeIdentityByID(id string) (model *VolumeIdentityByID, err error) {
	model = &VolumeIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumeIdentityByID) isaVolumeIdentity() bool {
	return true
}

// UnmarshalVolumeIdentityByID constructs an instance of VolumeIdentityByID from the specified map.
func UnmarshalVolumeIdentityByID(m map[string]interface{}) (result *VolumeIdentityByID, err error) {
	obj := new(VolumeIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeIdentityByIDSlice unmarshals a slice of VolumeIdentityByID instances from the specified list of maps.
func UnmarshalVolumeIdentityByIDSlice(s []interface{}) (slice []VolumeIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeIdentityByID'")
			return
		}
		obj, e := UnmarshalVolumeIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeIdentityByIDAsProperty unmarshals an instance of VolumeIdentityByID that is stored as a property
// within the specified map.
func UnmarshalVolumeIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *VolumeIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalVolumeIdentityByID(objMap)
	}
	return
}

// UnmarshalVolumeIdentityByIDSliceAsProperty unmarshals a slice of VolumeIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalVolumeIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeIdentityByIDSlice(vSlice)
	}
	return
}

// VolumeProfileIdentityByHref : VolumeProfileIdentityByHref struct
// This model "extends" VolumeProfileIdentity
type VolumeProfileIdentityByHref struct {
	// The URL for this volume profile.
	Href *string `json:"href" validate:"required"`
}

// NewVolumeProfileIdentityByHref : Instantiate VolumeProfileIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewVolumeProfileIdentityByHref(href string) (model *VolumeProfileIdentityByHref, err error) {
	model = &VolumeProfileIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumeProfileIdentityByHref) isaVolumeProfileIdentity() bool {
	return true
}

// UnmarshalVolumeProfileIdentityByHref constructs an instance of VolumeProfileIdentityByHref from the specified map.
func UnmarshalVolumeProfileIdentityByHref(m map[string]interface{}) (result *VolumeProfileIdentityByHref, err error) {
	obj := new(VolumeProfileIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeProfileIdentityByHrefSlice unmarshals a slice of VolumeProfileIdentityByHref instances from the specified list of maps.
func UnmarshalVolumeProfileIdentityByHrefSlice(s []interface{}) (slice []VolumeProfileIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeProfileIdentityByHref'")
			return
		}
		obj, e := UnmarshalVolumeProfileIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeProfileIdentityByHrefAsProperty unmarshals an instance of VolumeProfileIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalVolumeProfileIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *VolumeProfileIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeProfileIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalVolumeProfileIdentityByHref(objMap)
	}
	return
}

// UnmarshalVolumeProfileIdentityByHrefSliceAsProperty unmarshals a slice of VolumeProfileIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalVolumeProfileIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeProfileIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeProfileIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeProfileIdentityByHrefSlice(vSlice)
	}
	return
}

// VolumeProfileIdentityByName : VolumeProfileIdentityByName struct
// This model "extends" VolumeProfileIdentity
type VolumeProfileIdentityByName struct {
	// The name for this volume profile.
	Name *string `json:"name" validate:"required"`
}

// NewVolumeProfileIdentityByName : Instantiate VolumeProfileIdentityByName (Generic Model Constructor)
func (*VpcV1) NewVolumeProfileIdentityByName(name string) (model *VolumeProfileIdentityByName, err error) {
	model = &VolumeProfileIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumeProfileIdentityByName) isaVolumeProfileIdentity() bool {
	return true
}

// UnmarshalVolumeProfileIdentityByName constructs an instance of VolumeProfileIdentityByName from the specified map.
func UnmarshalVolumeProfileIdentityByName(m map[string]interface{}) (result *VolumeProfileIdentityByName, err error) {
	obj := new(VolumeProfileIdentityByName)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeProfileIdentityByNameSlice unmarshals a slice of VolumeProfileIdentityByName instances from the specified list of maps.
func UnmarshalVolumeProfileIdentityByNameSlice(s []interface{}) (slice []VolumeProfileIdentityByName, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeProfileIdentityByName'")
			return
		}
		obj, e := UnmarshalVolumeProfileIdentityByName(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeProfileIdentityByNameAsProperty unmarshals an instance of VolumeProfileIdentityByName that is stored as a property
// within the specified map.
func UnmarshalVolumeProfileIdentityByNameAsProperty(m map[string]interface{}, propertyName string) (result *VolumeProfileIdentityByName, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeProfileIdentityByName'", propertyName)
			return
		}
		result, err = UnmarshalVolumeProfileIdentityByName(objMap)
	}
	return
}

// UnmarshalVolumeProfileIdentityByNameSliceAsProperty unmarshals a slice of VolumeProfileIdentityByName instances that are stored as a property
// within the specified map.
func UnmarshalVolumeProfileIdentityByNameSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeProfileIdentityByName, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeProfileIdentityByName'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeProfileIdentityByNameSlice(vSlice)
	}
	return
}

// VolumePrototypeVolumeByCapacity : VolumePrototypeVolumeByCapacity struct
// This model "extends" VolumePrototype
type VolumePrototypeVolumeByCapacity struct {
	// The bandwidth for the volume.
	Iops *int64 `json:"iops,omitempty"`

	// The unique user-defined name for this volume.
	Name *string `json:"name,omitempty"`

	// The profile to use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile" validate:"required"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The location of the volume.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// The capacity of the volume in gigabytes.
	Capacity *int64 `json:"capacity" validate:"required"`
}

// NewVolumePrototypeVolumeByCapacity : Instantiate VolumePrototypeVolumeByCapacity (Generic Model Constructor)
func (*VpcV1) NewVolumePrototypeVolumeByCapacity(profile VolumeProfileIdentityIntf, zone ZoneIdentityIntf, capacity int64) (model *VolumePrototypeVolumeByCapacity, err error) {
	model = &VolumePrototypeVolumeByCapacity{
		Profile:  profile,
		Zone:     zone,
		Capacity: core.Int64Ptr(capacity),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumePrototypeVolumeByCapacity) isaVolumePrototype() bool {
	return true
}

// UnmarshalVolumePrototypeVolumeByCapacity constructs an instance of VolumePrototypeVolumeByCapacity from the specified map.
func UnmarshalVolumePrototypeVolumeByCapacity(m map[string]interface{}) (result *VolumePrototypeVolumeByCapacity, err error) {
	obj := new(VolumePrototypeVolumeByCapacity)
	obj.Iops, err = core.UnmarshalInt64(m, "iops")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Profile, err = UnmarshalVolumeProfileIdentityAsProperty(m, "profile")
	if err != nil {
		return
	}
	obj.ResourceGroup, err = UnmarshalResourceGroupIdentityAsProperty(m, "resource_group")
	if err != nil {
		return
	}
	obj.Zone, err = UnmarshalZoneIdentityAsProperty(m, "zone")
	if err != nil {
		return
	}
	obj.Capacity, err = core.UnmarshalInt64(m, "capacity")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumePrototypeVolumeByCapacitySlice unmarshals a slice of VolumePrototypeVolumeByCapacity instances from the specified list of maps.
func UnmarshalVolumePrototypeVolumeByCapacitySlice(s []interface{}) (slice []VolumePrototypeVolumeByCapacity, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumePrototypeVolumeByCapacity'")
			return
		}
		obj, e := UnmarshalVolumePrototypeVolumeByCapacity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumePrototypeVolumeByCapacityAsProperty unmarshals an instance of VolumePrototypeVolumeByCapacity that is stored as a property
// within the specified map.
func UnmarshalVolumePrototypeVolumeByCapacityAsProperty(m map[string]interface{}, propertyName string) (result *VolumePrototypeVolumeByCapacity, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumePrototypeVolumeByCapacity'", propertyName)
			return
		}
		result, err = UnmarshalVolumePrototypeVolumeByCapacity(objMap)
	}
	return
}

// UnmarshalVolumePrototypeVolumeByCapacitySliceAsProperty unmarshals a slice of VolumePrototypeVolumeByCapacity instances that are stored as a property
// within the specified map.
func UnmarshalVolumePrototypeVolumeByCapacitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumePrototypeVolumeByCapacity, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumePrototypeVolumeByCapacity'", propertyName)
			return
		}
		slice, err = UnmarshalVolumePrototypeVolumeByCapacitySlice(vSlice)
	}
	return
}

// ZoneIdentityByHref : ZoneIdentityByHref struct
// This model "extends" ZoneIdentity
type ZoneIdentityByHref struct {
	// The URL for this zone.
	Href *string `json:"href" validate:"required"`
}

// NewZoneIdentityByHref : Instantiate ZoneIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewZoneIdentityByHref(href string) (model *ZoneIdentityByHref, err error) {
	model = &ZoneIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*ZoneIdentityByHref) isaZoneIdentity() bool {
	return true
}

// UnmarshalZoneIdentityByHref constructs an instance of ZoneIdentityByHref from the specified map.
func UnmarshalZoneIdentityByHref(m map[string]interface{}) (result *ZoneIdentityByHref, err error) {
	obj := new(ZoneIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalZoneIdentityByHrefSlice unmarshals a slice of ZoneIdentityByHref instances from the specified list of maps.
func UnmarshalZoneIdentityByHrefSlice(s []interface{}) (slice []ZoneIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ZoneIdentityByHref'")
			return
		}
		obj, e := UnmarshalZoneIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalZoneIdentityByHrefAsProperty unmarshals an instance of ZoneIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalZoneIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *ZoneIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ZoneIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalZoneIdentityByHref(objMap)
	}
	return
}

// UnmarshalZoneIdentityByHrefSliceAsProperty unmarshals a slice of ZoneIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalZoneIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ZoneIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ZoneIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalZoneIdentityByHrefSlice(vSlice)
	}
	return
}

// ZoneIdentityByName : ZoneIdentityByName struct
// This model "extends" ZoneIdentity
type ZoneIdentityByName struct {
	// The name for this zone.
	Name *string `json:"name" validate:"required"`
}

// NewZoneIdentityByName : Instantiate ZoneIdentityByName (Generic Model Constructor)
func (*VpcV1) NewZoneIdentityByName(name string) (model *ZoneIdentityByName, err error) {
	model = &ZoneIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*ZoneIdentityByName) isaZoneIdentity() bool {
	return true
}

// UnmarshalZoneIdentityByName constructs an instance of ZoneIdentityByName from the specified map.
func UnmarshalZoneIdentityByName(m map[string]interface{}) (result *ZoneIdentityByName, err error) {
	obj := new(ZoneIdentityByName)
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalZoneIdentityByNameSlice unmarshals a slice of ZoneIdentityByName instances from the specified list of maps.
func UnmarshalZoneIdentityByNameSlice(s []interface{}) (slice []ZoneIdentityByName, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'ZoneIdentityByName'")
			return
		}
		obj, e := UnmarshalZoneIdentityByName(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalZoneIdentityByNameAsProperty unmarshals an instance of ZoneIdentityByName that is stored as a property
// within the specified map.
func UnmarshalZoneIdentityByNameAsProperty(m map[string]interface{}, propertyName string) (result *ZoneIdentityByName, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'ZoneIdentityByName'", propertyName)
			return
		}
		result, err = UnmarshalZoneIdentityByName(objMap)
	}
	return
}

// UnmarshalZoneIdentityByNameSliceAsProperty unmarshals a slice of ZoneIdentityByName instances that are stored as a property
// within the specified map.
func UnmarshalZoneIdentityByNameSliceAsProperty(m map[string]interface{}, propertyName string) (slice []ZoneIdentityByName, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'ZoneIdentityByName'", propertyName)
			return
		}
		slice, err = UnmarshalZoneIdentityByNameSlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref : LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref struct
// This model "extends" LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity
type LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref struct {
	// The pool's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref : Instantiate LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref(href string) (model *LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref, err error) {
	model = &LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref) isaLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity() bool {
	return true
}

func (*LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref) isaLoadBalancerListenerPolicyPatchTarget() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref constructs an instance of LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref from the specified map.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref(m map[string]interface{}) (result *LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref, err error) {
	obj := new(LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHrefSlice unmarshals a slice of LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHrefSlice(s []interface{}) (slice []LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHrefAsProperty unmarshals an instance of LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHrefSliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHrefSlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID : LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID struct
// This model "extends" LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity
type LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id" validate:"required"`
}

// NewLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID : Instantiate LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID(id string) (model *LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID, err error) {
	model = &LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID) isaLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity() bool {
	return true
}

func (*LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID) isaLoadBalancerListenerPolicyPatchTarget() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID constructs an instance of LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID from the specified map.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID(m map[string]interface{}) (result *LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID, err error) {
	obj := new(LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByIDSlice unmarshals a slice of LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByIDSlice(s []interface{}) (slice []LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByIDAsProperty unmarshals an instance of LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByIDSliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByIDSlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref : LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref struct
// This model "extends" LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity
type LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref struct {
	// The pool's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref : Instantiate LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref(href string) (model *LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref, err error) {
	model = &LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref) isaLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity() bool {
	return true
}

func (*LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref) isaLoadBalancerListenerPolicyPrototypeTarget() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref constructs an instance of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref from the specified map.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref(m map[string]interface{}) (result *LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref, err error) {
	obj := new(LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHrefSlice unmarshals a slice of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHrefSlice(s []interface{}) (slice []LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHrefAsProperty unmarshals an instance of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHrefSliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHrefSlice(vSlice)
	}
	return
}

// LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID : LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID struct
// This model "extends" LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity
type LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id" validate:"required"`
}

// NewLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID : Instantiate LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID(id string) (model *LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID, err error) {
	model = &LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID) isaLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity() bool {
	return true
}

func (*LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID) isaLoadBalancerListenerPolicyPrototypeTarget() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID constructs an instance of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID from the specified map.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID(m map[string]interface{}) (result *LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID, err error) {
	obj := new(LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByIDSlice unmarshals a slice of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID instances from the specified list of maps.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByIDSlice(s []interface{}) (slice []LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID'")
			return
		}
		obj, e := UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByIDAsProperty unmarshals an instance of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID that is stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID(objMap)
	}
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByIDSliceAsProperty unmarshals a slice of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByIDSlice(vSlice)
	}
	return
}

// PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress : PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress struct
// This model "extends" PublicGatewayPrototypeFloatingIpFloatingIPIdentity
type PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress struct {
	// The globally unique IP address.
	Address *string `json:"address" validate:"required"`
}

// NewPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress : Instantiate PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress(address string) (model *PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress, err error) {
	model = &PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress) isaPublicGatewayPrototypeFloatingIpFloatingIPIdentity() bool {
	return true
}

func (*PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress) isaPublicGatewayPrototypeFloatingIp() bool {
	return true
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress constructs an instance of PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress from the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress(m map[string]interface{}) (result *PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress, err error) {
	obj := new(PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress)
	obj.Address, err = core.UnmarshalString(m, "address")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddressSlice unmarshals a slice of PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress instances from the specified list of maps.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddressSlice(s []interface{}) (slice []PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress'")
			return
		}
		obj, e := UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddressAsProperty unmarshals an instance of PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress that is stored as a property
// within the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddressAsProperty(m map[string]interface{}, propertyName string) (result *PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress'", propertyName)
			return
		}
		result, err = UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress(objMap)
	}
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddressSliceAsProperty unmarshals a slice of PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress instances that are stored as a property
// within the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddressSliceAsProperty(m map[string]interface{}, propertyName string) (slice []PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddress'", propertyName)
			return
		}
		slice, err = UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByAddressSlice(vSlice)
	}
	return
}

// PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN : PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN struct
// This model "extends" PublicGatewayPrototypeFloatingIpFloatingIPIdentity
type PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN struct {
	// The CRN for this floating IP.
	Crn *string `json:"crn" validate:"required"`
}

// NewPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN : Instantiate PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN(crn string) (model *PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN, err error) {
	model = &PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN) isaPublicGatewayPrototypeFloatingIpFloatingIPIdentity() bool {
	return true
}

func (*PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN) isaPublicGatewayPrototypeFloatingIp() bool {
	return true
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN constructs an instance of PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN from the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN(m map[string]interface{}) (result *PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN, err error) {
	obj := new(PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRNSlice unmarshals a slice of PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN instances from the specified list of maps.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRNSlice(s []interface{}) (slice []PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN'")
			return
		}
		obj, e := UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRNAsProperty unmarshals an instance of PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN that is stored as a property
// within the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRNAsProperty(m map[string]interface{}, propertyName string) (result *PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN'", propertyName)
			return
		}
		result, err = UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN(objMap)
	}
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRNSliceAsProperty unmarshals a slice of PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN instances that are stored as a property
// within the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRNSliceAsProperty(m map[string]interface{}, propertyName string) (slice []PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRN'", propertyName)
			return
		}
		slice, err = UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByCRNSlice(vSlice)
	}
	return
}

// PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref : PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref struct
// This model "extends" PublicGatewayPrototypeFloatingIpFloatingIPIdentity
type PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref struct {
	// The URL for this floating IPs.
	Href *string `json:"href" validate:"required"`
}

// NewPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref : Instantiate PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref(href string) (model *PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref, err error) {
	model = &PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref) isaPublicGatewayPrototypeFloatingIpFloatingIPIdentity() bool {
	return true
}

func (*PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref) isaPublicGatewayPrototypeFloatingIp() bool {
	return true
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref constructs an instance of PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref from the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref(m map[string]interface{}) (result *PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref, err error) {
	obj := new(PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHrefSlice unmarshals a slice of PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref instances from the specified list of maps.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHrefSlice(s []interface{}) (slice []PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref'")
			return
		}
		obj, e := UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHrefAsProperty unmarshals an instance of PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref(objMap)
	}
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHrefSliceAsProperty unmarshals a slice of PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByHrefSlice(vSlice)
	}
	return
}

// PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID : PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID struct
// This model "extends" PublicGatewayPrototypeFloatingIpFloatingIPIdentity
type PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID struct {
	// The unique identifier for this floating IP.
	ID *string `json:"id" validate:"required"`
}

// NewPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID : Instantiate PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID(id string) (model *PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID, err error) {
	model = &PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID) isaPublicGatewayPrototypeFloatingIpFloatingIPIdentity() bool {
	return true
}

func (*PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID) isaPublicGatewayPrototypeFloatingIp() bool {
	return true
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID constructs an instance of PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID from the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID(m map[string]interface{}) (result *PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID, err error) {
	obj := new(PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByIDSlice unmarshals a slice of PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID instances from the specified list of maps.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByIDSlice(s []interface{}) (slice []PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID'")
			return
		}
		obj, e := UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByIDAsProperty unmarshals an instance of PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID that is stored as a property
// within the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID(objMap)
	}
	return
}

// UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByIDSliceAsProperty unmarshals a slice of PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'PublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalPublicGatewayPrototypeFloatingIpFloatingIPIdentityFloatingIPIdentityByIDSlice(vSlice)
	}
	return
}

// SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN : SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN struct
// This model "extends" SecurityGroupRulePatchRemoteSecurityGroupIdentity
type SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN struct {
	// The security group's CRN.
	Crn *string `json:"crn" validate:"required"`
}

// NewSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN : Instantiate SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(crn string) (model *SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	model = &SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN) isaSecurityGroupRulePatchRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN) isaSecurityGroupRulePatchRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN constructs an instance of SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN from the specified map.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(m map[string]interface{}) (result *SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	obj := new(SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSlice unmarshals a slice of SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN instances from the specified list of maps.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSlice(s []interface{}) (slice []SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNAsProperty unmarshals an instance of SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSliceAsProperty unmarshals a slice of SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSlice(vSlice)
	}
	return
}

// SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref : SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref struct
// This model "extends" SecurityGroupRulePatchRemoteSecurityGroupIdentity
type SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref struct {
	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref : Instantiate SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(href string) (model *SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	model = &SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref) isaSecurityGroupRulePatchRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref) isaSecurityGroupRulePatchRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref constructs an instance of SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref from the specified map.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(m map[string]interface{}) (result *SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	obj := new(SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSlice unmarshals a slice of SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref instances from the specified list of maps.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSlice(s []interface{}) (slice []SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefAsProperty unmarshals an instance of SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSliceAsProperty unmarshals a slice of SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSlice(vSlice)
	}
	return
}

// SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID : SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID struct
// This model "extends" SecurityGroupRulePatchRemoteSecurityGroupIdentity
type SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID struct {
	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`
}

// NewSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID : Instantiate SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID(id string) (model *SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	model = &SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID) isaSecurityGroupRulePatchRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID) isaSecurityGroupRulePatchRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID constructs an instance of SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID from the specified map.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID(m map[string]interface{}) (result *SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	obj := new(SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSlice unmarshals a slice of SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID instances from the specified list of maps.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSlice(s []interface{}) (slice []SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByIDAsProperty unmarshals an instance of SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSliceAsProperty unmarshals a slice of SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN : SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN struct
// This model "extends" SecurityGroupRulePrototypeRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN struct {
	// The security group's CRN.
	Crn *string `json:"crn" validate:"required"`
}

// NewSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN : Instantiate SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(crn string) (model *SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	model = &SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN) isaSecurityGroupRulePrototypeRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN) isaSecurityGroupRulePrototypeRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN constructs an instance of SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN from the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(m map[string]interface{}) (result *SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	obj := new(SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSlice unmarshals a slice of SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSlice(s []interface{}) (slice []SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNAsProperty unmarshals an instance of SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref : SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref struct
// This model "extends" SecurityGroupRulePrototypeRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref struct {
	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref : Instantiate SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(href string) (model *SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	model = &SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref) isaSecurityGroupRulePrototypeRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref) isaSecurityGroupRulePrototypeRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref constructs an instance of SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref from the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(m map[string]interface{}) (result *SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	obj := new(SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSlice unmarshals a slice of SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSlice(s []interface{}) (slice []SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefAsProperty unmarshals an instance of SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID : SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID struct
// This model "extends" SecurityGroupRulePrototypeRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID struct {
	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`
}

// NewSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID : Instantiate SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID(id string) (model *SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	model = &SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID) isaSecurityGroupRulePrototypeRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID) isaSecurityGroupRulePrototypeRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID constructs an instance of SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID from the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID(m map[string]interface{}) (result *SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	obj := new(SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSlice unmarshals a slice of SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSlice(s []interface{}) (slice []SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByIDAsProperty unmarshals an instance of SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN : SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN struct {
	// The security group's CRN.
	Crn *string `json:"crn" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(crn string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(m map[string]interface{}) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref : SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref struct {
	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(href string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(m map[string]interface{}) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID : SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID struct {
	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID(id string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID(m map[string]interface{}) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByIDAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN : SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN struct {
	// The security group's CRN.
	Crn *string `json:"crn" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(crn string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(m map[string]interface{}) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref : SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref struct {
	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(href string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(m map[string]interface{}) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID : SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID struct {
	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID(id string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID(m map[string]interface{}) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByIDAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolICMPRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN : SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN struct {
	// The security group's CRN.
	Crn *string `json:"crn" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(crn string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(m map[string]interface{}) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByCRNSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref : SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref struct {
	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(href string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(m map[string]interface{}) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByHrefSlice(vSlice)
	}
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID : SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID struct {
	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID(id string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID constructs an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID from the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID(m map[string]interface{}) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSlice unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID instances from the specified list of maps.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSlice(s []interface{}) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID'")
			return
		}
		obj, e := UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByIDAsProperty unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID that is stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID(objMap)
	}
	return
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSliceAsProperty unmarshals a slice of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDPRemoteSecurityGroupIdentitySecurityGroupIdentityByIDSlice(vSlice)
	}
	return
}

// VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN : VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN struct
// This model "extends" VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity
type VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN struct {
	// The CRN for this volume.
	Crn *string `json:"crn" validate:"required"`
}

// NewVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN : Instantiate VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN(crn string) (model *VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN, err error) {
	model = &VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN) isaVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity() bool {
	return true
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN) isaVolumeAttachmentPrototypeInstanceContextVolume() bool {
	return true
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN constructs an instance of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN from the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN(m map[string]interface{}) (result *VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN, err error) {
	obj := new(VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN)
	obj.Crn, err = core.UnmarshalString(m, "crn")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRNSlice unmarshals a slice of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN instances from the specified list of maps.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRNSlice(s []interface{}) (slice []VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN'")
			return
		}
		obj, e := UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRNAsProperty unmarshals an instance of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN that is stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRNAsProperty(m map[string]interface{}, propertyName string) (result *VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN'", propertyName)
			return
		}
		result, err = UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN(objMap)
	}
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRNSliceAsProperty unmarshals a slice of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN instances that are stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRNSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRNSlice(vSlice)
	}
	return
}

// VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref : VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref struct
// This model "extends" VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity
type VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref struct {
	// The URL for this volume.
	Href *string `json:"href" validate:"required"`
}

// NewVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref : Instantiate VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref(href string) (model *VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref, err error) {
	model = &VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref) isaVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity() bool {
	return true
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref) isaVolumeAttachmentPrototypeInstanceContextVolume() bool {
	return true
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref constructs an instance of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref from the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref(m map[string]interface{}) (result *VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref, err error) {
	obj := new(VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref)
	obj.Href, err = core.UnmarshalString(m, "href")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHrefSlice unmarshals a slice of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref instances from the specified list of maps.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHrefSlice(s []interface{}) (slice []VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref'")
			return
		}
		obj, e := UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHrefAsProperty unmarshals an instance of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref that is stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHrefAsProperty(m map[string]interface{}, propertyName string) (result *VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref'", propertyName)
			return
		}
		result, err = UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref(objMap)
	}
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHrefSliceAsProperty unmarshals a slice of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref instances that are stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHrefSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHrefSlice(vSlice)
	}
	return
}

// VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID : VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID struct
// This model "extends" VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity
type VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID struct {
	// The unique identifier for this volume.
	ID *string `json:"id" validate:"required"`
}

// NewVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID : Instantiate VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID(id string) (model *VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID, err error) {
	model = &VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID) isaVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity() bool {
	return true
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID) isaVolumeAttachmentPrototypeInstanceContextVolume() bool {
	return true
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID constructs an instance of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID from the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID(m map[string]interface{}) (result *VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID, err error) {
	obj := new(VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID)
	obj.ID, err = core.UnmarshalString(m, "id")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByIDSlice unmarshals a slice of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID instances from the specified list of maps.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByIDSlice(s []interface{}) (slice []VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID'")
			return
		}
		obj, e := UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByIDAsProperty unmarshals an instance of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID that is stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByIDAsProperty(m map[string]interface{}, propertyName string) (result *VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID'", propertyName)
			return
		}
		result, err = UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID(objMap)
	}
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByIDSliceAsProperty unmarshals a slice of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID instances that are stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByIDSliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByIDSlice(vSlice)
	}
	return
}

// VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity : VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity struct
// This model "extends" VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext
type VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity struct {
	// The bandwidth for the volume.
	Iops *int64 `json:"iops,omitempty"`

	// The unique user-defined name for this volume.
	Name *string `json:"name,omitempty"`

	// The profile to use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile" validate:"required"`

	// The capacity of the volume in gigabytes.
	Capacity *int64 `json:"capacity" validate:"required"`
}

// NewVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity : Instantiate VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity(profile VolumeProfileIdentityIntf, capacity int64) (model *VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity, err error) {
	model = &VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity{
		Profile:  profile,
		Capacity: core.Int64Ptr(capacity),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity) isaVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext() bool {
	return true
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity) isaVolumeAttachmentPrototypeInstanceContextVolume() bool {
	return true
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity constructs an instance of VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity from the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity(m map[string]interface{}) (result *VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity, err error) {
	obj := new(VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity)
	obj.Iops, err = core.UnmarshalInt64(m, "iops")
	if err != nil {
		return
	}
	obj.Name, err = core.UnmarshalString(m, "name")
	if err != nil {
		return
	}
	obj.Profile, err = UnmarshalVolumeProfileIdentityAsProperty(m, "profile")
	if err != nil {
		return
	}
	obj.Capacity, err = core.UnmarshalInt64(m, "capacity")
	if err != nil {
		return
	}
	result = obj
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacitySlice unmarshals a slice of VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity instances from the specified list of maps.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacitySlice(s []interface{}) (slice []VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity, err error) {
	for _, v := range s {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("slice element should be a map containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity'")
			return
		}
		obj, e := UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity(objMap)
		if e != nil {
			err = e
			return
		}
		slice = append(slice, *obj)
	}
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacityAsProperty unmarshals an instance of VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity that is stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacityAsProperty(m map[string]interface{}, propertyName string) (result *VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		objMap, ok := v.(map[string]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a map containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity'", propertyName)
			return
		}
		result, err = UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity(objMap)
	}
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacitySliceAsProperty unmarshals a slice of VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity instances that are stored as a property
// within the specified map.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacitySliceAsProperty(m map[string]interface{}, propertyName string) (slice []VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity, err error) {
	v, foundIt := m[propertyName]
	if foundIt {
		vSlice, ok := v.([]interface{})
		if !ok {
			err = fmt.Errorf("map property '%s' should be a slice of maps, each containing an instance of 'VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity'", propertyName)
			return
		}
		slice, err = UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacitySlice(vSlice)
	}
	return
}
